<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CPP易懂文章记录</title>
      <link href="/p/4162491037.html"/>
      <url>/p/4162491037.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录一些看到的易懂的C++文章</p></blockquote><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体内存对齐： <a href="https://www.cnblogs.com/hyacinthLJP/p/16041690.html">https://www.cnblogs.com/hyacinthLJP/p/16041690.html</a></p><p>静态绑定和动态绑定：<a href="https://www.cnblogs.com/lizhenghn/p/3657717.html">https://www.cnblogs.com/lizhenghn/p/3657717.html</a></p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux命令详解及自定义配置</title>
      <link href="/p/4190388149.html"/>
      <url>/p/4190388149.html</url>
      
        <content type="html"><![CDATA[<h1 id="Tmux命令"><a href="#Tmux命令" class="headerlink" title="Tmux命令"></a>Tmux命令</h1><p><code>tmux</code> 是一个终端复用器，可以在一个窗口中运行多个终端会话。</p><p>一个 <code>tmux</code> 可以包含多个 <code>session</code> ，一个 <code>session</code> 可以包含多个 <code>window</code> ，一个 <code>window</code> 可以包含多个 <code>pane</code> 。</p><p>结构如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux:</span><br><span class="line">    session 0:</span><br><span class="line">        window 0:</span><br><span class="line">            pane 0</span><br><span class="line">            pane 1</span><br><span class="line">            pane 2</span><br><span class="line">            ...</span><br><span class="line">        window 1</span><br><span class="line">        window 2</span><br><span class="line">        ...</span><br><span class="line">    session 1</span><br><span class="line">    session 2</span><br></pre></td></tr></table></figure><h2 id="1-会话命令-session"><a href="#1-会话命令-session" class="headerlink" title="1 会话命令-session"></a>1 会话命令-session</h2><ul><li>开始新会话</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux</span><br></pre></td></tr></table></figure><ul><li>开始新会话指定会话名称</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux new -s <span class="string">&quot;新名称&quot;</span></span><br></pre></td></tr></table></figure><ul><li>连接现有会话</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux attach -t <span class="string">&quot;名字&quot;</span></span><br></pre></td></tr></table></figure><ul><li>列出所有运行的会话</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><ul><li>结束特定会话</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux kill-session -t <span class="string">&quot;名字&quot;</span></span><br></pre></td></tr></table></figure><ul><li>打开之前挂起的会话</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux a</span><br></pre></td></tr></table></figure><ul><li><p>进入会话界面后，切换其他会话：<code>Ctrl + a + s</code> ，之后上下键操作选择即可</p></li><li><p>从当前会话中断开连接（挂起，会在后台继续运行）： <code>Ctrl + a + d</code></p></li></ul><blockquote><p>注意： <code>Ctrl+b</code> 是 <code>tmux</code> 命令的默认前缀键组合。而我修改了配置文件，自定义前缀为 <code>Ctrl+a</code></p></blockquote><h2 id="2-窗口命令-window"><a href="#2-窗口命令-window" class="headerlink" title="2 窗口命令-window"></a>2 窗口命令-window</h2><ul><li><p>创建新窗口： <code>Ctrl + a + c</code></p></li><li><p>切换到前一个&#x2F;下一个窗口： <code>Ctrl + a + p/n</code> </p></li><li><p>切换其他窗口： <code>Ctrl + a + w</code> ，之后上下键操作选择即可</p></li></ul><h2 id="3-窗格命令-pane"><a href="#3-窗格命令-pane" class="headerlink" title="3 窗格命令-pane"></a>3 窗格命令-pane</h2><ul><li><p>左右分割窗格： <code>Ctrl + a + :</code></p></li><li><p>上下分割窗格： <code>Ctrl + a + &quot;</code></p></li></ul><blockquote><p>上面两条在我的配置文件中配置了</p></blockquote><ul><li>切换窗格： <code>Ctrl + a + 方向键</code> ，可以在窗格之间任意切换</li></ul><blockquote><p>同时鼠标可以点击选择窗格。</p></blockquote><ul><li>关闭当前窗格： <code>Ctrl + a + x</code> 或 <code>Ctrl + d</code></li></ul><blockquote><p>对于 <code>Ctrl + d</code> ，如果当前 <code>window</code> 的所有 <code>pane</code> 均已关闭，则自动关闭 <code>window</code> ；如果当前 <code>session</code> 的所有 <code>window</code> 均已关闭，则自动关闭 <code>session</code> 。</p></blockquote><ul><li>调整窗格大小： <code>Ctrl + a + Ctrl + 方向键</code></li></ul><blockquote><p>同时鼠标可以拖动分割线进行调整大小。</p></blockquote><ul><li><p>将当前窗格全屏&#x2F;取消全屏： <code>Ctrl + a + z</code></p></li><li><p>翻阅当前pane内的内容：鼠标滚轮。</p></li><li><p><code>tmux</code> 中复制&#x2F;粘贴文本的通用方式：按下 <code>Ctrl + a</code> 后松开手指，然后按 <code>[</code> ，用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板，按下 <code>Ctrl + a</code> 后松开手指，然后按 <code>]</code>，会将剪贴板中的内容粘贴到光标处。</p></li></ul><h1 id="Tmux配置"><a href="#Tmux配置" class="headerlink" title="Tmux配置"></a>Tmux配置</h1><h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1 配置文件"></a>1 配置文件</h2><p>将 <code>.tmux.conf</code> 文件放置在用户目录下。</p><p>我的配置，基本也是从网上整理的：</p><p>也可见：<a href="https://github.com/anda522/config/blob/main/tmux/.tmux.conf">https://github.com/anda522/config/blob/main/tmux/.tmux.conf</a> </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Note:</span></span><br><span class="line"><span class="comment"># -1 If the config is not valid, run the command &quot;tmux source-file ~/.tmux.conf&quot;, </span></span><br><span class="line"><span class="comment"># then try your config again!</span></span><br><span class="line"><span class="comment"># -2 This is my personal config file according to my likes.</span></span><br><span class="line"></span><br><span class="line">set-option -g status-keys vi</span><br><span class="line">setw -g mode-keys vi</span><br><span class="line"></span><br><span class="line">setw -g monitor-activity on</span><br><span class="line"></span><br><span class="line"><span class="comment"># setw -g c0-change-trigger 10</span></span><br><span class="line"><span class="comment"># setw -g c0-change-interval 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setw -g c0-change-interval 50</span></span><br><span class="line"><span class="comment"># setw -g c0-change-trigger  75</span></span><br><span class="line"></span><br><span class="line">set-window-option -g automatic-rename on</span><br><span class="line">set-option -g set-titles on</span><br><span class="line"><span class="built_in">set</span> -g history-limit 100000</span><br><span class="line"></span><br><span class="line"><span class="comment">#set-window-option -g utf8 on</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set command prefix</span></span><br><span class="line">set-option -g prefix C-a</span><br><span class="line">unbind-key C-b</span><br><span class="line">bind-key C-a send-prefix</span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span> h select-pane -L</span><br><span class="line"><span class="built_in">bind</span> j select-pane -D</span><br><span class="line"><span class="built_in">bind</span> k select-pane -U</span><br><span class="line"><span class="built_in">bind</span> l select-pane -R</span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span> -n M-Left select-pane -L</span><br><span class="line"><span class="built_in">bind</span> -n M-Right select-pane -R</span><br><span class="line"><span class="built_in">bind</span> -n M-Up select-pane -U</span><br><span class="line"><span class="built_in">bind</span> -n M-Down select-pane -D</span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span> &lt; resize-pane -L 7</span><br><span class="line"><span class="built_in">bind</span> &gt; resize-pane -R 7</span><br><span class="line"><span class="built_in">bind</span> - resize-pane -D 7</span><br><span class="line"><span class="built_in">bind</span> + resize-pane -U 7</span><br><span class="line"></span><br><span class="line">bind-key -n M-l next-window</span><br><span class="line">bind-key -n M-h previous-window</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -g status-interval 1</span><br><span class="line"><span class="comment"># status bar</span></span><br><span class="line"><span class="built_in">set</span> -g status-bg black</span><br><span class="line"><span class="built_in">set</span> -g status-fg blue</span><br><span class="line"></span><br><span class="line"><span class="comment">#set -g status-utf8 on</span></span><br><span class="line"><span class="built_in">set</span> -g status-justify centre</span><br><span class="line"><span class="built_in">set</span> -g status-bg default</span><br><span class="line"><span class="built_in">set</span> -g status-left <span class="string">&quot; #[fg=green]#S@#H #[default]&quot;</span></span><br><span class="line"><span class="built_in">set</span> -g status-left-length 20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mouse support</span></span><br><span class="line"><span class="comment"># for tmux 2.1</span></span><br><span class="line"><span class="comment"># set -g mouse-utf8 on</span></span><br><span class="line"><span class="built_in">set</span> -g mouse on</span><br><span class="line"></span><br><span class="line"><span class="comment"># for previous version</span></span><br><span class="line"><span class="comment">#set -g mode-mouse on</span></span><br><span class="line"><span class="comment">#set -g mouse-resize-pane on</span></span><br><span class="line"><span class="comment">#set -g mouse-select-pane on</span></span><br><span class="line"><span class="comment">#set -g mouse-select-window on</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#set -g status-right-length 25</span></span><br><span class="line"><span class="built_in">set</span> -g status-right <span class="string">&quot;#[fg=green]%H:%M:%S #[fg=magenta]%a %m-%d #[default]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Split the pane into left and right.</span></span><br><span class="line"><span class="comment"># Command: ctrl + a + &quot;</span></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;&quot;&#x27;</span> split-window -vc <span class="string">&quot;#&#123;pane_current_path&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Split the pane into up and down.</span></span><br><span class="line"><span class="comment"># Command: ctrl + a + :</span></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;:&#x27;</span> split-window -hc <span class="string">&quot;#&#123;pane_current_path&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span> <span class="string">&#x27;c&#x27;</span> new-window -c <span class="string">&quot;#&#123;pane_current_path&#125;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2-配置文件不生效"><a href="#2-配置文件不生效" class="headerlink" title="2 配置文件不生效"></a>2 配置文件不生效</h2><p>在根目录下输入这个回车即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux source-file ~/.tmux.conf</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建私有git发布博客</title>
      <link href="/p/3211658549.html"/>
      <url>/p/3211658549.html</url>
      
        <content type="html"><![CDATA[<h1 id="自建私有git进行项目发布"><a href="#自建私有git进行项目发布" class="headerlink" title="自建私有git进行项目发布"></a>自建私有git进行项目发布</h1><p>之前尝试过通过建立私有git仓库，来发布自己的hexo静态博客，但是失败了，今天尝试了一下午，算是有了结果。下面记录我的过程。</p><p>我的需求：</p><p>我有一个服务器，希望在服务器端建一个<code>git</code>仓库，本地部署时会同时往GitHub，服务器多个地方部署，但是主要的访问是通过服务器端的 <code>nginx</code> 。</p><p>即本地 <code>hexo d</code> 命令能够往服务器 <code>git</code> 的进行部署，同时在 <code>github</code> 留有备份。服务器中 <code>nginx</code> 会设置网站根目录为指定的某个目录。</p><h1 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h1><p>本地项目通过<code>git</code> 上传至服务器端建立的 裸仓库<code>git</code> ，<code>push</code> 操作会触发 <code>git</code> 的钩子函数， 钩子函数进入在我们的项目目标目录，执行 <code>pull</code> 操作，将所有的改变拉取到项目目录并合并。</p><p><code>nginx</code> 会将网站根目录设置为项目目录，就可以正常访问了。</p><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>建议使用有 <code>sudo</code> 权限的用户新建 <code>git</code> 用户，而不是 <code>root</code> 用户。</p><h2 id="1-新建一个Git用户"><a href="#1-新建一个Git用户" class="headerlink" title="1 新建一个Git用户"></a>1 新建一个Git用户</h2><blockquote><p>首先需要安装 <code>git</code> ，具体方法根据自己系统搜索进行安装。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo useradd git</span><br></pre></td></tr></table></figure><h2 id="2-配置访问权限"><a href="#2-配置访问权限" class="headerlink" title="2 配置访问权限"></a>2 配置访问权限</h2><p>我们需要无需密码验证登录 <code>git</code> 账户，需要将本机的公钥文件内容 <code>C:\Users\用户名\.ssh\id_rsa.pub</code> 复制到 <code>/home/git/.ssh/authorized_keys</code> 中。</p><p>这样就能无密码登录 <code>git</code> 用户，可以使用 <code> ssh -T git@101.35.203.216</code> 命令进行验证。</p><h2 id="3-建立裸仓库"><a href="#3-建立裸仓库" class="headerlink" title="3 建立裸仓库"></a>3 建立裸仓库</h2><p>选定目录建立裸仓库，我的是 <code>/home/git/blog.git</code> ，在 <code>/home/git</code> 目录下执行命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo git init --bare blog.git</span><br><span class="line"><span class="comment"># 同时还要将仓库所属用户修改为git</span></span><br><span class="line">sudo <span class="built_in">chown</span> -R git:git blog.git</span><br></pre></td></tr></table></figure><blockquote><p>裸仓库没有工作区，也就是你根本没法看到上传上来的文件。之后我所有的静态博客文件即 <code>public</code> 目录下的文件都会上传到裸仓库。那如何拿到文件呢？</p><p>我采用 <code>git</code> 钩子函数的特性，当有本地有 <code>push</code> 代码到裸仓库的操作时，便自动执行一个脚本，把仓库中的文件拉取到我的项目目录 <code>/home/git/public</code> 中，这样我就可以正常的用 <code>nginx</code> 访问我的博客项目了。</p></blockquote><h2 id="4-添加钩子函数"><a href="#4-添加钩子函数" class="headerlink" title="4 添加钩子函数"></a>4 添加钩子函数</h2><p>在裸仓库 <code>/home/git/blog.git/hooks</code> 目录中，新建 <code>post-receive</code> 文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim post-receive <span class="comment"># 新建文件</span></span><br></pre></td></tr></table></figure><p>输入内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">unset</span> GIT_DIR <span class="comment"># 似乎挺重要的，可能与环境变量有关</span></span><br><span class="line">DIR=/home/git/public <span class="comment"># 项目目录</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Starting Upadte!&quot;</span> <span class="comment"># 调试用的</span></span><br><span class="line">git config --global --add safe.directory /home/git/public <span class="comment"># 中途代码提示建议我添加的，我就加上了</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$DIR</span> <span class="comment"># 进入项目目录</span></span><br><span class="line">git pull /home/git/blog.git main <span class="comment"># 拉取裸仓库并与本地分支合并</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Update Sucess!&quot;</span> <span class="comment"># 调试用的</span></span><br></pre></td></tr></table></figure><blockquote><p>其实这里大部分操作和 <code>git</code> 命令和 <code>bash</code> 环境相关，看来还是需要去学习下了。</p></blockquote><p>注意还要将 <code>post-receive</code> 文件所属用户改为 <code>git</code> ，且添加执行权限，不然无权访问。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R git:git post-receive</span><br><span class="line">sudo <span class="built_in">chmod</span> +x post-receive</span><br></pre></td></tr></table></figure><h2 id="5-禁止Git用户登录Shell"><a href="#5-禁止Git用户登录Shell" class="headerlink" title="5 禁止Git用户登录Shell"></a>5 禁止Git用户登录Shell</h2><p>编辑 <code>/etc/passwd</code> 文件，找到下面类似内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git:x:1009:1009:git daemon user:/:/bin/bash</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git:x:1009:1009::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><p>这样 <code>git</code> 用户就无法登录shell了。</p><h2 id="6-添加项目目录"><a href="#6-添加项目目录" class="headerlink" title="6 添加项目目录"></a>6 添加项目目录</h2><p>在自己想要的地方添加项目目录，我的是 <code>/home/git/public</code> ， 在目录中需要进行仓库初始化，因为这个目录之后要执行 <code>pull</code> 操作</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init <span class="comment"># 初始化仓库</span></span><br></pre></td></tr></table></figure><blockquote><p>还要注意，这个项目文件要让 git 用户有权限访问</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R git:git /home/git/public <span class="comment"># 让git所有</span></span><br></pre></td></tr></table></figure><h1 id="本地客户端"><a href="#本地客户端" class="headerlink" title="本地客户端"></a>本地客户端</h1><h2 id="1-本地调试"><a href="#1-本地调试" class="headerlink" title="1 本地调试"></a>1 本地调试</h2><p>本地可以新建一个文件夹进行调试。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@101.35.203.216:/home/git/blog.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;test&quot;</span></span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><blockquote><p>注意调试之后还要让服务器端的项目commit记录为空，因为正式使用时会有 git 记录不一致的情况。</p><p>当然如果 <code>git</code> 操作一流，能够处理此种情况，算我没说。</p></blockquote><h2 id="2-博客配置"><a href="#2-博客配置" class="headerlink" title="2 博客配置"></a>2 博客配置</h2><p>本地Hexo博客项目配置文件 <code>_config.yml</code> 中我进行了修改：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- <span class="built_in">type</span>: git</span><br><span class="line">  repository:</span><br><span class="line">    github: git@github.com:anda522/anda522.github.io.git</span><br><span class="line">    gitee: git@gitee.com:wyqz/wyqz.git</span><br><span class="line">  branch: master</span><br><span class="line">- <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@101.35.203.216:/home/git/blog.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>执行 <code>hexo d</code> 命令后，就会将生成的前端文件上传至自建的裸仓库。</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul><li>各种权限问题，登录账户为 <code>git</code> ，需要时刻注意某些文件能不能用 <code>git</code> 用户访问</li><li><code>git</code> 的各种命令的理解， <code>pull push</code> 等，需要了解</li><li><code>bash</code> 的环境变量问题，没有了解过很容易出问题</li></ul><blockquote><p>参考：</p><ul><li><p><a href="https://52gvim.com/post/git-server">https://52gvim.com/post/git-server</a></p></li><li><p><a href="https://blog.csdn.net/Shen_Junxiao/article/details/85245390">https://blog.csdn.net/Shen_Junxiao/article/details/85245390</a></p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023年度总结</title>
      <link href="/p/3216805600.html"/>
      <url>/p/3216805600.html</url>
      
        <content type="html"><![CDATA[<h1 id="2023年度总结"><a href="#2023年度总结" class="headerlink" title="2023年度总结"></a>2023年度总结</h1><blockquote><p>2023马上结束，为了继承惯例，特拟总结，以备回顾。</p></blockquote><p>一年就这样过去了，发现自己能记住的不是很多，大量且冗杂的信息让我的记忆不堪重负，我不得不翻开我的日程表去回顾匆匆离去的一年。</p><p>这篇文章打算以类别划分来整合整年的碎片。</p><blockquote><p>文前总结：今年应该算是总共干了三样事情：推免 + 比赛 + 自我探索，每一件都很耗费心神。</p></blockquote><h1 id="学业微进程"><a href="#学业微进程" class="headerlink" title="学业微进程"></a>学业微进程</h1><h2 id="1-线下自由的校内"><a href="#1-线下自由的校内" class="headerlink" title="1 线下自由的校内"></a>1 线下自由的校内</h2><p>年初寒假期间一直在搞软著，同时跟着校内某项目组希望搞篇论文，可惜最终论文这方面实打实地失败，软著倒是水了两篇。</p><p>上半年可以算是解封第一学期，一切都是新的，所有陈旧的疫情规则面临瓦解，这下领导的面子是不是就挂不住了（。</p><p>可能因为学校撑不住了提前放假，期末考试暂时延期，然后又在假期经历解封，期末就推到了开学。还算行吧，假期复习了一点时间，开学后又复习了一点时间。只记得数据库考崩溃了，其他只剩下了空白。</p><p>那么整个3月和4月都在刻意准备保研材料，找老师签推荐信，然后关注着自己的软著进程。</p><p>期间参加了推迟到三月份的六级，第二次裸考，竟然上了500。</p><p>5月开始，各校的保研事项便零星开始了，各种报名材料的整理和填写，作为在推免方面毫无经验和见识的学生一枚，只能拟定海投策略。</p><p>6月初，期末考试和超多推免报名夹杂，真的非常焦虑和紧张，既要抓紧复习期末考试，又要在截止时间之前提交完报名材料，复习时间基本都被占的差不多了。而且最后一个学期的课程还很多，学分还有一些，决定着之后的保研情况，不容小觑。这段时间非常考验人。</p><p>考完试就是紧接着的其他的学校报名，线下夏令营，必定很卷，而且计算机真的就是卷死了，往上走真的非常难，其他人有论文，有竞赛，有科研，有学校背景，有排名。我这种小兵小将根本没有机会。</p><p>真的出乎所料，这学期的考试都考得非常强，我直接跌落十几名排名（综测），绩点排名也落了一名。好多人真的就是基本科科满绩，比不起啊。</p><p>这次考试，出了一点小情况，有一门RFID我复习的时间非常久，比一些同学复习的都详细，但是分却比一些基本在考前一两天复习的人的分还低，我直接找老师了，老师表示大题主观题给分很低，愿意给我申请复核修改，但是最后还是没改成（学院驳回）。只能说老师把卷子让给了研究生来改，研究生对这个主观题也不是很懂，只知道看答案去给分，我写的就是课件上的答案，可能和答案不太一样把，他硬是给我了低分。就因为这几分，我绩点发生了变化，绩点排名落后了一名。（我用这个落后的名次报了复旦，不然复旦还有可能，也只是这么说说，还真不一定去成）没想到之后我就要成为我的一生之敌（研究生）了，哎。</p><p>之后就是推免进程，回校之后先是推免，结束后又是比赛，见下文。</p><h2 id="2-各地的升学探访"><a href="#2-各地的升学探访" class="headerlink" title="2 各地的升学探访"></a>2 各地的升学探访</h2><h3 id="2-1-旅游篇"><a href="#2-1-旅游篇" class="headerlink" title="2.1 旅游篇"></a>2.1 旅游篇</h3><p>真的是全国各地到处跑啊，真的很花钱，但是某几次也是玩的真不错。</p><p>前面几次可能还不是那么有经验，没有规划好时间去当地旅游下，后面就逐渐上手了。</p><p>光是夏令营和预推免就去了好几个地方，北京（2次），天津，南京，武汉，宁波，长沙和上海都有机会去，但因为某些原因拒绝了。</p><p>北京一直想去人大，可惜太难了。前期没准备好，后面它预推免就不收人了。北航因为是第一次夏令营，且自己很多方面准备不充分，直接就没有了。第二次来北京的时候，来的是北师大的郊区，直接用机试拿下了。但是考虑到北师大的title，没有选择北师大。</p><p>北京，天津，南京，宁波四个地方，都和同行之人去当地旅游了一番，去的地方还挺多的，可谓是非常不错。很可惜去武汉的时候没有好好在当地转转。</p><p>留了很多照片纪念，但是想着还没有结果，而且那段时间都挺紧张焦虑的，就没发出来。</p><h3 id="2-2-面试篇"><a href="#2-2-面试篇" class="headerlink" title="2.2 面试篇"></a>2.2 面试篇</h3><p>为了推免的面试准备的挺多的，我专业课问的不多，发现基本都和项目有关，而我项目基本没有，非常惨，转眼一想，现在这个结果其实很不错了。</p><p>发现很多时候全是靠机试成绩撑着，不然真的没学上了。</p><p>总结下，夏令营+预推免本来可以去的学校：吉大CS，北师大AI，天大智算学部，东南计专，浙大软院，中科大网安。因为title优先权较高，只剩下浙大和中科大两个选择，又因为浙软的地理位置、学费以及网上评价等原因选择了中科大， 中科大地理位置不算好，但也算有华五名头，我也没有更好的选择了，没有其他选择只能落得一个“菜”字。</p><p><img src="/3216805600/image-20231231125452150.png" alt="投递院校记录"></p><blockquote><p>详情点击 <a href="https://wyqz.top/p/2802848655.html">推免那些事</a> 查看</p></blockquote><h1 id="拖沓的比赛生涯"><a href="#拖沓的比赛生涯" class="headerlink" title="拖沓的比赛生涯"></a>拖沓的比赛生涯</h1><p>今年算是省赛和区域赛都参加了，也算没有真的留下什么参赛的遗憾了。只能留下实力不够的遗憾。</p><h2 id="1-省内竞技"><a href="#1-省内竞技" class="headerlink" title="1 省内竞技"></a>1 省内竞技</h2><p>年初2月的牛客寒假多校还在参加，但是感觉假期训练的不是很足够了。回到学校后感觉训练的也不多了，因为要专注于推免了。</p><p>大概在3月，参加了郑轻的邀请赛，拿了300块钱，虽然只分到100，真不错~可能算是疫情后第一次出去线下参赛了</p><p>参加了4月的天梯赛，虽然在校内第2组，但还是很幸运能够拿到个人奖国三的。没想到校内多名著名选手竞双双开演，远远落后，开了我的眼。</p><p>线下参加了5月份的CCPC省赛（5.7）和ICPC省赛（5.21）。在队友的强力带领下，双双拿金。</p><p>CCPC省赛，取名“日子会越来越甜的”和校内某队”孔乙己在流水线上哭着要回古代”有异曲同工之妙。</p><p>ICPC省赛，虽说参赛体验并不是很好，但是远跋洛师，算得上小旅游？很多方面对我来说都是初次体验。（第一次坐高铁，我就是那么没见过世面）</p><p>参加了六月的校赛，老队友，老实力，与第一失之交臂，很是痛心。</p><h2 id="2-走出旮旯"><a href="#2-走出旮旯" class="headerlink" title="2 走出旮旯"></a>2 走出旮旯</h2><p>本来想着上半年参加完省赛，就退役专心准备推免，下半年的区域赛也不打了。但回到学校后因为有某队邀请，我也同意了，只能在推免结束后尽力让过期的实力恢复正常了，但似乎真的恢复的不多。</p><p>推免后，参加了三站。南京，深圳，济南。都是跑的很远，可恨的是，这个恶心北区不报销，朝令夕改，一直在挑战他们的下限，之后我也不再唱好北区。</p><p>深圳拿了铜，体验很好。至于另外两站，因为诸多原因，都差一点，只能遗憾退场了。</p><p>不管区域赛的成绩怎么样，这只能说花钱买教训，没有报销。期间还是思考了很多的，去了很多的地方，走出了这个犄角旮旯的地方。</p><p>在深圳时还去找了在腾讯的学长聊，相当值得此行。发现似乎就去深圳收获了很多，难道…？</p><blockquote><p>详情点击 <a href="https://wyqz.top/p/2569313091.html">ACM退役记 </a> </p></blockquote><h1 id="生活破碎与重建"><a href="#生活破碎与重建" class="headerlink" title="生活破碎与重建"></a>生活破碎与重建</h1><h2 id="1-建立日志"><a href="#1-建立日志" class="headerlink" title="1 建立日志"></a>1 建立日志</h2><p>今年突发奇想，建个日志记录会怎么样。然后我就干了这件事。想记录就写，没想到记录就不写，主打一个自适应调节。</p><p>同时，今年也算是使用TickTick比较完全的一年，使用方式不断发生更新和变化，记录内容变得多元化。标签不断进行更新调整，日程管理也更多样。</p><p><img src="/3216805600/image-20231231125742058.png" alt="断断续续的日志记录"></p><p><img src="/3216805600/73e699ef6f41f3016ff0063be9bea51c.jpg" alt="TickTick记录"></p><h2 id="2-思维重构"><a href="#2-思维重构" class="headerlink" title="2 思维重构"></a>2 思维重构</h2><p>我想如果从一开始接受的思想教育就是错的，那么什么又是对的，那么如何去学对的思想，便因此开了此题目。</p><p>已有的思维方式根深蒂固，最新的模式还未形成体系，且极难替代旧模式。这完全是很难形容且很难定形的东西。</p><p>下半年不断探索，虽然思维没有发生变化，但是我已经倾向转换思维来思考了。我也不知道怎么表达，而且想法也不成熟，就是一丝观念。</p><h2 id="3-习惯试探"><a href="#3-习惯试探" class="headerlink" title="3 习惯试探"></a>3 习惯试探</h2><p>听过21天形成一个习惯的理论，我想着能不能试试，看看是否有效，那么我就去干了。</p><p>一共建了3个习惯，截止12-17至今分别执行了90、90、85天，根据贪心法，习惯执行结果只会更好，不会更差，所以我考虑先执行下去，看看最后是否会得到一个最优结果。</p><p><img src="/3216805600/image-20231231130106031.png" alt="习惯试探"></p><h1 id="时间轴纵观"><a href="#时间轴纵观" class="headerlink" title="时间轴纵观"></a>时间轴纵观</h1><h2 id="1-年初印象"><a href="#1-年初印象" class="headerlink" title="1 年初印象"></a>1 年初印象</h2><p>年初算是正式的寒假了，迎来了长久未到的解封。疫情对我造成了严重的打击，也让我对公信力产生了严重的怀疑。</p><h2 id="2-年中羁旅"><a href="#2-年中羁旅" class="headerlink" title="2 年中羁旅"></a>2 年中羁旅</h2><p>很庆幸一些该做的事情都做了，不然没有现在这个结果了。</p><p>还是要抓住可能出现的每一次机会，不然真的没有现在的情况了。</p><h2 id="3-年末微探"><a href="#3-年末微探" class="headerlink" title="3 年末微探"></a>3 年末微探</h2><p>基本已经完全自由了，没有什么任务的压迫了，可以找点感兴趣的东西去玩，去看，去干了，可以开启探索模式了。</p><h1 id="2024-Flags"><a href="#2024-Flags" class="headerlink" title="2024 Flags"></a>2024 Flags</h1><p>另外，从来没有立过flags，既然要重构，那么不知成效就先去试，故次年立之。</p><p>目标应该是以学习上为主，当然其他方面的怎么会放上来。</p><h2 id="1-阅读"><a href="#1-阅读" class="headerlink" title="1 阅读"></a>1 阅读</h2><ul><li>阅书15本</li></ul><p>要求应该不算很高吧，虽然说有点小挑战，按照下半年进度来看，基本一月能看完一本，但为凑好看的数字，15也算有点小挑战，毕竟初次实施，不能一下子打击到信心。</p><h2 id="2-开发能力"><a href="#2-开发能力" class="headerlink" title="2 开发能力"></a>2 开发能力</h2><ul><li>操作系统、数据库和计算机网络三大LAB做完</li><li>看一个源码（STL，DB，NGINX等）</li></ul><h2 id="3-博客写作"><a href="#3-博客写作" class="headerlink" title="3 博客写作"></a>3 博客写作</h2><ul><li>75篇博客</li></ul><p>这个完全不过分吧，只是想要延续写博客的传统，完全不是为了完成目的而存在的。</p><ul><li>写12篇月总结</li></ul><p>这个数字一下子就小了很多，应该不会完不成吧。</p><h2 id="3-玄学目标"><a href="#3-玄学目标" class="headerlink" title="3 玄学目标"></a>3 玄学目标</h2><ul><li>心态方面是不是要改变下，自信点，高中就是容易紧张，大学因为疫情又锻炼的不多，又很容易在强者环境中畏畏缩缩，希望改变下。下年再来看，看下年的自己怎么说。</li><li>完全贯彻解决问题型思维。</li><li>基本具有”高速公路-结构-模型”思维，可能需要刻意训练。</li></ul><blockquote><p>玄学目标完全是个人主观想法，不太有依据而言。</p></blockquote><p>总之24年目标还是有些挑战性的，玄学目标更是毫无目的性，完全需要自主探索，说不定就掉进一个深坑。</p>]]></content>
      
      
      <categories>
          
          <category> 哲思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阶段性总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++指针操作详细整理</title>
      <link href="/p/360366309.html"/>
      <url>/p/360366309.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-指针操作整理"><a href="#C-C-指针操作整理" class="headerlink" title="C&#x2F;C++指针操作整理"></a>C&#x2F;C++指针操作整理</h1><blockquote><p>面向曾经学习过指针的人，并非针对究极初学者。</p></blockquote><h1 id="一维指针"><a href="#一维指针" class="headerlink" title="一维指针"></a>一维指针</h1><p>数据类型存储的地址，指向数据存储的地址，可以使用 <code>&amp;</code>运算符取变量的地址，将其赋给指针变量。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure><p>同时因为C&#x2F;C++中数组是连续存储的，所以一个指针可以间接访问一个数组，可以通过指针的<strong>解引用</strong>访问该地址处存储的值。</p><p>知识点：</p><ul><li>一个数组的数组名默认代表这个数组的地址。</li><li>可以通过 <code>地址加减</code> 和 <code>下标法</code> 访问连续存储的数据。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 下面两行代码等价,</span></span><br><span class="line"><span class="comment">//    std::cout &lt;&lt; p[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    std::cout &lt;&lt; *(p + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，对于 <code>char</code> 类型，也有：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;ABCDEF&quot;</span>;</span><br><span class="line"><span class="type">char</span> *p = s; <span class="comment">// s代表字符串首地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(<span class="built_in">strlen</span>(s)); ++i) &#123;</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; p[i];</span></span><br><span class="line">    std::cout &lt;&lt; *(p + i); <span class="comment">// 输出单个字符</span></span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出整个字符串</span></span><br></pre></td></tr></table></figure><p>特别的：针对 <code>char</code> 类型，可以直接输出首地址，编译器会自动将地址加一往后输出，直到遇到 <code>\0</code> 字符，即字符串结尾字符。（注意 <code>string</code> 类型没有 <code>\0</code> 结尾字符）</p><p>其他数据类型基本同理。</p><h1 id="二维指针"><a href="#二维指针" class="headerlink" title="二维指针"></a>二维指针</h1><p>即指针的指针，就是指针存储的是一个指针变量的存储地址，输出的时候就需要两层解引用了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;val;</span><br><span class="line"><span class="type">int</span> **p2 = &amp;p1;</span><br><span class="line">std::cout &lt;&lt; **p2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="数组指针和指针数组"><a href="#数组指针和指针数组" class="headerlink" title="数组指针和指针数组"></a>数组指针和指针数组</h1><h2 id="1-数组指针"><a href="#1-数组指针" class="headerlink" title="1 数组指针"></a>1 数组指针</h2><p>即数组的指针，代表整个数组的地址。由于 <code>[]</code> 优先级大于 <code>*</code>， 所以需要使用 <code>()</code> 代表 <code>p</code> 存储一个长度为 <code>3</code> 的数组的地址。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2 指针数组"></a>2 指针数组</h2><p>即数组中存储的是指针变量， <code>*</code> 首先和 <code>int</code> 结合。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h1 id="一些指针操作"><a href="#一些指针操作" class="headerlink" title="一些指针操作"></a>一些指针操作</h1><blockquote><p>需要了解下new操作</p></blockquote><h2 id="1-创建二维动态数组"><a href="#1-创建二维动态数组" class="headerlink" title="1 创建二维动态数组"></a>1 创建二维动态数组</h2><ul><li>方法一：利用<strong>二维指针</strong>，C++ new操作</li></ul><p>定义一个二维指针，二维指针指向的是长度为 <code>n</code> 的数组（数组中存储的是指针变量）的地址，即定义 <code>f</code> 时就指向了一个数组的首地址，而这个数组中的每个指针元素代表了二维数组每一行的首地址。</p><blockquote><p>可以这样理解：一个 <code>*</code> 代表的是地址，去掉这个 <code>*</code> 剩下的就是这个地址指向值的类型，那么 <code>int **f</code> 去掉一个 <code>*</code> 就剩下了 <code>int *</code> ，也就是这个指针指向值的类型为 <code>int*</code> 。</p></blockquote><p>然后利用循环，对二维指针进行操作，每维申请一个长度为 <code>m</code> 的数组，刚好 <code>new</code> 操作返回的就是一个数组的首地址，就可以赋给 <code>f[i]</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **f = <span class="keyword">new</span> <span class="type">int</span>*[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    f[i] = <span class="keyword">new</span> <span class="type">int</span>[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同样可以以数组形式输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">f[i][j] = i * n + j;</span><br><span class="line">std::cout &lt;&lt; f[i][j] &lt;&lt; <span class="string">&quot; \n&quot;</span>[j == m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：利用<strong>二维指针</strong>，C malloc操作</li></ul><blockquote><p>这种方法其实是对二维数组的拙劣模仿，正常二维数组是一次寻址就能找到数据，而这种方法是二次寻址。</p><ul><li>一次寻址是因为编译器会直接去找  <code>i * m + j</code> 位置的元素</li><li>二次寻址是因为首先最外层指针对第一维寻址，然后再对第二维寻址</li></ul></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **f = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    f[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法三：使用<strong>数组指针</strong></li></ul><p>直接定义个数组指针指向整个二维数组</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)[<span class="number">3</span>] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line"><span class="comment">// *(*(p + i) + j) = ++cnt;</span></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; *(*(p + i) + j) &lt;&lt; &quot; \n&quot;[j == 2];</span></span><br><span class="line">p[i][j] = ++cnt;</span><br><span class="line">std::cout &lt;&lt; p[i][j] &lt;&lt; <span class="string">&quot; \n&quot;</span>[j == <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法四：使用C++ <code>vector</code></li></ul><p>声明了等价于 <code>a[n][m]</code> 的数组</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><h2 id="2-数组传参"><a href="#2-数组传参" class="headerlink" title="2 数组传参"></a>2 数组传参</h2><blockquote><p>注意：数组传参数会退化成指针，一维数组传递退化成指向数组首元素的指针。</p></blockquote><h3 id="2-1-一维数组传参"><a href="#2-1-一维数组传参" class="headerlink" title="2.1 一维数组传参"></a>2.1 一维数组传参</h3><ul><li>使用一维指针传参，传入数组首地址</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> *b, <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">print(a, length);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用数组指针传参，传入数组地址</li></ul><p>此时， <code>b</code> 指向了一个长度为 <code>3</code> 的数组，<code>*b</code> 先对第二维解引用，然后才是对第一维（即传入的 <code>a[3]</code> ）操作。 </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (*b)[<span class="number">3</span>], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*b + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> length = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">print</span>(&amp;a, length); <span class="comment">// 注意此时传入了数组的地址</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传入数组指针，传入数组的首地址</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> b[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> length = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">print</span>(a, length);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CPP：传引用</li></ul><blockquote><p>可以防止数组退化成指针</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;b)[<span class="number">3</span>], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> length = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">print</span>(a, length);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-二维数组传参"><a href="#2-2-二维数组传参" class="headerlink" title="2.2 二维数组传参"></a>2.2 二维数组传参</h3><ul><li>使用数组指针传参，传入第二维数组的首地址</li></ul><blockquote><p>同样会退化成指针，二维数组传递会退化成指向数组一维元素（即 <code>[3]</code> 这一维）的指针，指向的是一个长度为 3 的数组。</p><p>传参时，二维必须固定</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (*b)[<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*(b + i) + j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用数组指针传参，传入第二维数组的首地址</li></ul><blockquote><p>传参时，一维可以不固定，二维必须固定。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> b[][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*(b + i) + j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CPP：使用引用传参</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;b)[<span class="number">2</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(*(b + i) + j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>折腾长久，终退役-致我的ACM生涯</title>
      <link href="/p/2569313091.html"/>
      <url>/p/2569313091.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>先留坑，打完终幕场便填上，静候。</p><p>从2023-11-20建文件，打完最后一场济南就算正式退了，打完比赛还要立马交一个实训课的证明，还需搞一下，所以先起个草稿，打算写一篇正式的退役记来记录和纪念我这跌跌撞撞、无所成绩的ACM生涯。</p></blockquote><p>对我的生涯总结一句话：在众多ACMer中相对来说可以算是比较失败，但是考虑到零基础和其他的精力分配，也算是不那么惨的。</p><h1 id="大一-初遇ACM"><a href="#大一-初遇ACM" class="headerlink" title="大一-初遇ACM"></a>大一-初遇ACM</h1><h2 id="1-大一上-幸运的眷顾"><a href="#1-大一上-幸运的眷顾" class="headerlink" title="1 大一上-幸运的眷顾"></a>1 大一上-幸运的眷顾</h2><p>作为一个完全没有任何计算机基础的人（大学之前可能在初中和高中上过小于等于10次的微机课），我对计算机的感觉可以说是完全没有。从大学上来不了解ACM，敲键盘还是需要从头开始学起，一个接一个字母看着敲。</p><p>大一前的暑假，被某些Python培训班的广告蛊惑了（但没交智商税，毕竟没钱），励志学好Python赚大钱，所以可能暑假跟着他们的试听课照着敲了点Python程序，但是对程序的概念是完全的没有，至此我照模照样的会敲点Python，怀着学技术赚大钱的志向来到了大学。</p><p>来到大学，青涩、无知，我就是从计协社团来寝室宣传才知道ACM的，但是并无概念。他们当时办了新生赛，我当时还对“比赛”这两个字有着崇高的敬意，便和舍友开黑跟着打了四场，至此便算是开端。</p><p>那么大一上我就跟着某个群内学长的意见刷了院OJ前50道题，杭电刷了20道左右的题目，以此就应对12月份的招新赛，最终以5题拿下进入实验室的资格，就在排名边缘，很吓人。（此时想一下，如果没有写出来5道题，我就可能没有现在所有的情况了，庆幸。）</p><blockquote><p>在刷题时期，我斗胆投了创新创业某个团队的简历，然后去面试，现在还记得，套了个很花哨的PPT模板，内容写了一大堆，写我会思维导图，记忆宫殿，态度，认几个Python语句，真实好笑。没想到最后竟然进了，至此我认为我的学习生活出现了第一个转折点，我有了学习的工位，同时学姐要求每周进行学习总结然后发到邮箱中，我硬是坚持了好几个学期，我认为真的很重要。（感谢学姐，也感谢我的坚持总结。）没有创新创业团队的入选，没有学姐总结汇报的要求，没有长达几个学期的坚持，就没有今天。</p></blockquote><p>有了进ACM实验室的资格，心惊胆战不敢去实验室，也庆幸有哈爹的某些言语和不拘小节的行事作风让我在ACM实验室能够继续呆下去，距离期末还是有个几周，我实验室工位和北三团队工位交叉去坐，实验室里可能在继续写C语言的入门语法题，没人指导，没人引导，北三工位就学Python的爬虫知识（不知道哪来的网课资源）。期末前直接不去ACM实验室，在北三复习期末。</p><p>那么，大一上基本就要结束了，临近期末，C语言也是没有学到多熟练，C++基本都不会，写题才开始应着学长的要求去照搬C++的输入输出语句去写。</p><p>因为是疫情，没有复习周，直接考试，所幸期末竟然没有考的很差，记得排名年级第三，这也为后面各种事情锚定了风向。</p><h2 id="2-大一下-缓慢起步"><a href="#2-大一下-缓慢起步" class="headerlink" title="2 大一下-缓慢起步"></a>2 大一下-缓慢起步</h2><p>大一下，延续了交叉去实验室和北三的惯例，此时算法还没学，一直在写入门的题目，北三事务还比较多，实验室和北三团队交叉去。</p><p>实验室的招新赛和训练赛我是一场没有落下，不过实验室拉的算法专题我是基本很难进行下去，便去写自己的题了，真后悔当初没有坚持去写算法专题。下学期再强力哈爹的带领下，拿到了ICPC省赛的参赛名额，也很幸运能够拿到银奖，记得当时我只做出了一个微积分求积分的题目（仅仅是因为我高数写题写的多一点，现在已经忘完了）和签到题，其他的基本都由队友操刀，真的太菜了。不过能够见到sw，菜瓜，浩哥齐聚，还是非常有幸的。</p><p>所幸是实验室次数去的比较多，期间一直在刷题，进展缓慢，算法也没学多少，可能还得靠视频去学，所幸去的次数多引起了浩哥的注意，比较幸运当了计协的会长，现在看来，确实算是转折。</p><p>那么本学期，训练的比较多，但是学的很是缓慢。拿了ICPC省银，期末考试前复习同样没去实验室，成绩有所倒退，炸了物理和概率论两门大学分课，学期平均绩点是3.63。</p><p>暑假参加了创新创业团队那报名的比赛，线上参赛，拿了一等奖，可能就正式宣告后来我在该团队的隐退。</p><h1 id="大二-夹杂提升"><a href="#大二-夹杂提升" class="headerlink" title="大二-夹杂提升"></a>大二-夹杂提升</h1><blockquote><p>疫情已经让我忘记了很多细节，基本没有留下记忆的事件。</p></blockquote><p>大二上，有幸拿到了ICPC沈阳的参赛资格，线上牛客参赛，但是那时候肯定打铁啊，啥都不会，只做了2个签到，校内倒数。</p><p>参加了推迟的CCPC省赛，拿了银，这场我只记得我做了一个DP题，其他的都忘记了。本场比赛也算是我这种新生的一次独舞吧，虽然舞的不是那么漂亮。</p><hr><p>大二下，有幸接过了实验室的管理任务，但是那时我还很菜，好多算法都没学会，又深感责任重大。</p><p>感觉这学期才是我算真真正正开始学算法刷难题的时候，对着CF比自己rating高几百分的题目刷，算法埋着头学，也算实力有所增长。很遗憾没有很早明白到，刷题补题才是提升实力的关键。</p><p>这学期本来是有CCPC省赛参加的，但比赛日临近期末，省内流传出疫情提前放假回家的消息，最终确认这消息是真的，省赛只能推迟。只能说疫情又一次阻隔了进程。</p><p>这学期我提升了很多方面，计协会长和ACM培养了我极大的责任感，计协会长这个职务又极大程度push我学了很多Linux服务器相关的东西（当然没有皮卡丘学长我的推销我是没有今天的），工程能力有了一定的提升，管理思维也发生了很多转变。</p><p>北三创新创业团队那边我正常参加会议，但是由于疫情会是没有开几次，这边几乎所有的团队感觉算是停摆了，这就是疫情的冲击！我也打算慢慢隐退这边的事务了，将中心逐渐向ACM这边移动，两者之间抉择，我毫无疑问地选择ACM。</p><h1 id="大三-时摆时训-或有微光"><a href="#大三-时摆时训-或有微光" class="headerlink" title="大三-时摆时训,或有微光"></a>大三-时摆时训,或有微光</h1><p>刚开学几周内参加了上半年推迟的省赛，只能说这次比赛办的很及时，办完整个省立马进入了封锁状态，然后就是封宿舍到放假的日子。</p><p>大三上，参加了CCPC广州站，ICPC沈阳，ICPC南京，但是那时候疫情封校，已经封在宿舍里面了，根本打不了，打基本都是队伍里面一个人单挑，然后线上人数一般都是七八百队，只有210队有奖，很难拿奖。</p><p>而且封在宿舍，训练变得越来越少，最后直接摆了。整天都是接受着疫情的各种消息，已经被疫情整焦虑了，整整封在了宿舍一个学期，而且还是提前放假回家。</p><p>一会是富士康的消息，一会又是哪里封城的消息，一会又是哪里bao乱的消息，一会又是哪里火灾的消息，消息声不绝于耳，只能说让人麻木了，更多的只剩下了失望。</p><p>ICPC南京那时候，社会面上已经公布解封的消息了，那时正是新冠第一波大流行，阳的很多，都放假在家，队友又在不同的地方，很难在一起打。</p><blockquote><p>大一，大二，大三基本都是疫情，在实验室训练体系不够健全的情况下，根本没有办法快速的去了解正确的方向，基本都是自己去摸索。所以算法学的进度慢，刷题刷的没有体系，各种学习方式以现在的我看来都是不太合理。</p><p>而且疫情产生的影响可以说是非常之大，无法线下去实验室训练，在寝室封闭意味着效率低下及无法持续坚持刷题，最后沦为娱乐之星。</p></blockquote><hr><p>大三下，这学期就是疫情解封后的第一个学期，什么东西基本都要转成线下，算是没有给大学留下无线下参赛经历的遗憾。我感觉基本就与ACM渐行渐远了，因为本学期要准备保研的诸多事情，而且还要保证期末考试成绩不会下滑，可谓是非常之艰难。训练前期还能加训一下，到学期后期就很难加训了，一方面要准备保研材料报名学校，一方面期末压力，如果退步就意味着未来保研学校的变化，两大巨石压制，难以让我转向训练。</p><p>所幸这学期先打的天梯赛，在学期前，但没想到队友双双开演，我有幸没落伍，拿了个人国三。</p><p>我感觉已经到了训练的末声了，且打算打完省赛就全力准备推免，之后退役。在CCPC省赛和ICPC省赛中，由于队友强大的助力，都拿了金，队友功不可没，没有队友支持，我没有现在的境况。</p><p>打完比赛，也就完全去进行保研方面的准备了，这学期末真的很是紧张，真的惊心动魄。</p><blockquote><p>有关推免，请移步：<a href="https://wyqz.top/p/2802848655.html">https://wyqz.top/p/2802848655.html</a> </p></blockquote><h1 id="大四-迟来的终幕"><a href="#大四-迟来的终幕" class="headerlink" title="大四-迟来的终幕"></a>大四-迟来的终幕</h1><p>大三下和大四初全力准备了保研，很幸运能够保到一个理想的学校。保完之后基本就要去找其他事干了，比如找个实习。</p><p>本学期本来就要退役去找其他事情干的，基本就算是终幕了。但是有个队伍缺队友找我组队，我就直接答应了，进而给我的ACM生涯带来更长的拖尾。</p><p>第一场ICPC南京站，自认为队友之间的配合太离谱了，最终与奖牌错失了一个罚时，与奖牌失之交臂。</p><p>第二场CCPC深圳站，吸取了第一场的教训，先各自想题，理性讨论。最后顺利拿牌，虽然是个铜吧。</p><p>第三场ICPC济南，怎么会被一个恶心的签到题卡一整场，不然又拿牌了，还有一个题一直被卡常数，一直T，$Nlog^2N$  的复杂度，多了一个log，最后还没有优化掉。</p><p> 打完正式宣告退役，我的ACM生涯进行的并不好，但也不至于太差。也希望这个中肯的评价更加激励我之后的进程，当初选择打ACM可能并不是为了那一个结果，本身过程就艰难曲折，但还是毅然投入，可能就是别人说的瘾吧。</p><blockquote><p>没想到三场都在现场见了杜老师，真的很有缘分，一下子把对神的想象拉到了实际中，更振奋更激荡。</p></blockquote><h1 id="一些感受"><a href="#一些感受" class="headerlink" title="一些感受"></a>一些感受</h1><p>我的ACM之旅，基本每年都要换队友，有一个个队友不打了，我还在打。每年的队友都不一样，实力水平和训练意愿都截然不同，所以我能达到这样的结果已经够感到知足且满足了。那么接下来便是总结期间的教训，以防后来继续犯错误。</p><p>只能说，前三年我被疫情耽误的太多了。可能还会有人说，如果没有疫情，你会好到哪去，难道不是因为自己的原因吗？我想，没有疫情起码我不会变得比现在的情况更差，我会更早的了解到关于ACM的学习方式，我可能会懈怠，但疫情是整整把我要走的路硬生生地延长了周期，导致后面能走的路越来越少。</p><p> 计算机零基础搞ACM整个历程真就难受，最后走出来的结果也基本都是不好的，中间有很多次机会放弃ACM，但是还是选择坚持打了下去，可能这就是那一股愚蠢的执念吧。</p>]]></content>
      
      
      <categories>
          
          <category> 哲思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阶段性总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Mit6.s081】课程记录</title>
      <link href="/p/2589851505.html"/>
      <url>/p/2589851505.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>实验代码记录：<a href="https://github.com/anda522/LabCode/tree/main/Mit6.S081">https://github.com/anda522/LabCode/tree/main/Mit6.S081</a> </p><p>课程教材翻译：<a href="https://xv6.dgs.zone/">https://xv6.dgs.zone/</a> ，对理解感觉很重要</p></blockquote><p>xv6系统为 <code>RISC-V</code> </p><h1 id="1-Unix-utilities"><a href="#1-Unix-utilities" class="headerlink" title="1 Unix utilities"></a>1 Unix utilities</h1><h2 id="Knowledge"><a href="#Knowledge" class="headerlink" title="Knowledge"></a>Knowledge</h2><p>操作系统结构：</p><ul><li><p>用户空间程序：正在运行的程序，他们处于同一个空间</p></li><li><p>Kernel：Kernel程序只有一个，维护数据管理每一个用户空间进程，维护硬件资源</p></li></ul><blockquote><p>Kernel中存在各种服务：文件系统、进程管理系统、访问控制等等</p></blockquote><p>应用程序访问Kernel通过 <strong>系统调用</strong> 来完成，Kernel具有对硬件操作的特殊权限。</p><p>管道 <code>pipe</code> 特性：</p><ul><li>管道具有先进先出(FIFO)的特性。数据写入管道的一端，从管道的另一端读出时是按写入顺序读取的。</li><li>父进程在写入管道后,会通过 read 操作等待子进程的响应。该 read 操作会被阻塞，直到有数据可读。</li></ul><h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><p><code>/user</code> 目录为用户区代码，所有用户区相关的函数都在此处。</p><p><code>/kernel</code> 目录为内核区代码，所有内核区相关的操作都在此处，如系统调用实现，内存映射，中断处理等。</p><p>如要使用 <code>sleep</code> 命令时，需要将 <code>sleep</code> 程序添加进 <code>Makefile</code> 文件的 <code>UPROGS</code> 中，将其纳入编译范围，否则操作系统将不能识别你的命令。后续程序同理。</p><blockquote><p><code>UPROGS</code> 列表：添加在之中说明用户区可以执行对应的可执行程序，例如在命令行执行对应命令。而其他无需生成可执行程序的系统调用可以不用添加在其中。</p></blockquote><blockquote><p>参考：</p><p>[1] <a href="https://blog.rayzhang.top/2022/06/27/mit-6.s081-lab-util/">MIT 6.S081 Lab Util 实验</a></p></blockquote><h1 id="2-System-calls"><a href="#2-System-calls" class="headerlink" title="2 System calls"></a>2 System calls</h1><h2 id="Knowledge-1"><a href="#Knowledge-1" class="headerlink" title="Knowledge"></a>Knowledge</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有相关的系统调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>**)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">short</span>, <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>部分系统调用解释：</p><p><code>exit(int)</code> ：导致进程停止执行并释放资源。<code>exit</code>接受一个整数状态参数，通常0表示成功，1表示失败。</p><p><code>fork(void)</code> ：拷贝当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。</p><p>之后就拥有了一个完全一样内存的进程，在原始进程中 <code>fork()</code> 系统调用返回大于 <code>0</code> 的数，这个数为子类的 <code>PID</code> ， 在子进程中，返回的数为 <code>0</code> 。</p><p><code>exec(char*, char**)</code> ：以新的进程代替原来的进程，该系统调用不会返回，因为exec会完全替换当前进程的内存，相当于当前进程不复存在了。并没有创建新的进程，还是原来进程的 <code>PID</code> 。</p><blockquote><p><code>exec</code>有两个参数：可执行文件的文件名和字符串参数数组。</p></blockquote><p><code>wait(int*)</code> ：等待之前创建的子进程退出。如果当前进程有任何子进程，并且其中一个已经退出了，那么wait会返回。</p><blockquote><p><code>wait</code>系统调用返回当前进程的已退出(或已杀死)子进程的PID，并将子进程的退出状态复制到传递给<code>wait</code>的地址；如果调用方的子进程都没有退出，那么wait等待一个子进程退出。如果调用者没有子级，<code>wait</code>立即返回-1。如果父进程不关心子进程的退出状态，它可以传递一个0地址给<code>wait</code>。</p></blockquote><p><code>write(fd, buf, n)</code> ：将 <code>buf</code> 中的 <code>n</code> 字节写入文件描述符，并返回写入的字节数。只有发生错误时才会写入小于 <code>n</code> 字节的数据。</p><p><code>read(fd, buf, n)</code> ：从文件描述符读取最多 <code>n</code> 字节，将它们复制到 <code>buf</code> ，并返回读取的字节数。</p><blockquote><p>文件描述符是一个小整数(small integer)，表示进程可以读取或写入的由内核管理的对象，进程从文件描述符0读取（标准输入），将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）</p></blockquote><h3 id="系统调用执行过程"><a href="#系统调用执行过程" class="headerlink" title="系统调用执行过程"></a>系统调用执行过程</h3><p>系统调用在内核区，执行时需要从用户态过渡到核心态，CPU提供一个特殊的指令，将CPU从用户模式切换到管理模式，并在内核指定的入口点进入内核（RISC-V为此提供<code>ecall</code>指令）。</p><p>一个进程可以通过执行RISC-V的<code>ecall</code>指令进行系统调用，该指令提升硬件特权级别，并将程序计数器（PC）更改为内核定义的入口点，入口点的代码切换到内核栈，执行实现系统调用的内核指令，当系统调用完成时，内核切换回用户栈，并通过调用<code>sret</code>指令返回用户空间，该指令降低了硬件特权级别，并在系统调用指令刚结束时恢复执行用户指令。</p><h2 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab"></a>Lab</h2><h1 id="3-Page-tables"><a href="#3-Page-tables" class="headerlink" title="3 Page tables"></a>3 Page tables</h1><h2 id="Knowledge-2"><a href="#Knowledge-2" class="headerlink" title="Knowledge"></a>Knowledge</h2><p>Xv6为每个进程维护一个单独的页表，定义了该进程的地址空间。一个进程的虚拟地址空间分布如下。首先是指令，然后是全局变量，然后是栈区，最后是一个堆区域。有许多因素限制了进程地址空间的最大范围： RISC-V上的指针有64位宽；硬件在页表中查找虚拟地址时只使用低39位；xv6只使用这39位中的38位。因此，最大地址是 <code>2^38-1=0x3fffffffff</code> ，即<code>MAXVA</code>（定义在kernel&#x2F;riscv.h:348）在地址空间的顶部，xv6为<code>trampoline</code>（用于在用户和内核之间切换）和映射进程切换到内核的<code>trapframe</code>分别保留了一个页面。</p><p><img src="https://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c2/p2.png"></p><h2 id="Lab-2"><a href="#Lab-2" class="headerlink" title="Lab"></a>Lab</h2><p><code>argaddr()</code> 和 <code>argint()</code> 函数都是从用户栈空间中提取参数。当用户调用系统调用时，需要将参数传给内核。参数通常会放到用户的栈中。</p><p><code>walk</code> 函数在操作系统中通常用于页表的遍历和访问。在虚拟内存管理中，页表是一种数据结构，用于将虚拟地址映射到物理地址。<code>walk</code> 函数的主要作用是在给定的页表中查找特定虚拟地址对应的页表项。</p><p><code>copyout</code> 函数通常用于从内核空间将数据复制到用户空间。</p><p><code>PTE_A</code> 的默认值是第六位</p><blockquote><p>参考：</p><p>[1] <a href="https://zhuanlan.zhihu.com/p/429304672">MIT 6.S081 2021: Lab page tables</a> </p><p>[2] <a href="https://blog.rayzhang.top/2022/07/22/mit-6.s081-lab-pgtbl/">MIT 6.S081 Lab Pgtbl 实验</a> （非常详细）</p></blockquote><h1 id="4-Traps"><a href="#4-Traps" class="headerlink" title="4 Traps"></a>4 Traps</h1><h2 id="Knowledge-3"><a href="#Knowledge-3" class="headerlink" title="Knowledge"></a>Knowledge</h2><p>Trap机制：用户空间和内核空间的切换，目的是实现操作系统的安全和隔离</p><blockquote><p>用户空间和内核空间的切换发生的场景：</p><ul><li>程序执行系统调用</li><li>程序出现页面错误、除以零等错误</li><li>触发中断导致程序需要响应内核设备驱动</li></ul></blockquote><h2 id="Lab-3"><a href="#Lab-3" class="headerlink" title="Lab"></a>Lab</h2><p><code>proc</code> 结构体包含了进程中的所有信息，可以通过 <code>myproc()</code> 获取当前运行的进程的结构体。</p><h1 id="5-Copy-on-Write"><a href="#5-Copy-on-Write" class="headerlink" title="5 Copy-on-Write"></a>5 Copy-on-Write</h1><h2 id="Knowledge-4"><a href="#Knowledge-4" class="headerlink" title="Knowledge"></a>Knowledge</h2><h2 id="Lab-4"><a href="#Lab-4" class="headerlink" title="Lab"></a>Lab</h2><ul><li>我们很有可能需要标记当前的 PTE 为 COW 内存页映射，因此我们可以使用 RSW（reserved for software）标识位来实现：</li></ul><p><img src="https://blog.rayzhang.top/2022/10/01/mit-6.s081-lab-cow/rsw-bits.png"></p><ul><li><p>如果 COW 下的缺页中断产生了，但是也没有足够的物理内存空间，那么进程应当被杀死。</p></li><li><p>设置引用计数，将物理内容RAM划分成 <code>(PHYSTOP - KERNBASE) / PGSIZE</code> 个页面，对每个页面设置一个引用计数（代表页面被引用的次数，当引用计数变为0时，就要释放对应的空间）。</p></li></ul><p><img src="https://blog.rayzhang.top/2022/10/01/mit-6.s081-lab-cow/mem.png"></p><h1 id="6-Multithreading"><a href="#6-Multithreading" class="headerlink" title="6 Multithreading"></a>6 Multithreading</h1><h2 id="Knowledge-5"><a href="#Knowledge-5" class="headerlink" title="Knowledge"></a>Knowledge</h2><p>Xv6有两种类型的锁：自旋锁（spinlocks）和睡眠锁（sleep-locks）。</p><p>自旋锁和中断的交互引发了潜在的危险。假设<code>sys_sleep</code>持有<code>tickslock</code>，并且它的CPU被计时器中断中断。<code>clockintr</code>会尝试获取<code>tickslock</code>，意识到它被持有后等待释放。在这种情况下，<code>tickslock</code>永远不会被释放：只有<code>sys_sleep</code>可以释放它，但是<code>sys_sleep</code>直到<code>clockintr</code>返回前不能继续运行。所以CPU会死锁，任何需要锁的代码也会冻结。</p><p>为了避免这种情况，如果一个自旋锁被中断处理程序所使用，那么CPU必须保证在启用中断的情况下永远不能持有该锁。Xv6更保守：当CPU获取任何锁时，xv6总是禁用该CPU上的中断。中断仍然可能发生在其他CPU上，此时中断的<code>acquire</code>可以等待线程释放自旋锁；由于不在同一CPU上，不会造成死锁。</p><p>自旋锁的另一个缺点是，一个进程在持有自旋锁的同时不能让出（yield）CPU，然而我们希望持有锁的进程等待磁盘I&#x2F;O的时候其他进程可以使用CPU。</p><p>Xv6以睡眠锁（sleep-locks）的形式提供了这种锁。<code>acquiresleep</code> (<strong>kernel&#x2F;sleeplock.c</strong>:22) 在等待时让步CPU</p><h2 id="Lab-5"><a href="#Lab-5" class="headerlink" title="Lab"></a>Lab</h2>]]></content>
      
      
      <categories>
          
          <category> 课程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码中的技巧或习惯</title>
      <link href="/p/3703005386.html"/>
      <url>/p/3703005386.html</url>
      
        <content type="html"><![CDATA[<hr><p>1.需要一个数组或者字符串的目前的元素和前一个元素做相关运算时:<br><strong>直接遍历这个序列，当 i 等于0时不满足条件，只有i 等于 1时才会执行if语句</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>( i &amp;&amp; 相关的运算) ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>2.与前一个元素做相关运算<br><strong>我偏向定义一个变量pre代表前一个元素，然后从第二个位置开始遍历</strong><br>感觉这样的代码确实有点多了，而且每次要更新pre的值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pre = num[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">相关的运算</span><br><span class="line">pre = num[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>3.存ASCII是否访问过，直接vis[200],开足够大的空间，ASCII本身也是一个数，直接用字符操作就行</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vis[s[i]] ++;</span><br></pre></td></tr></table></figure><hr><p>4.判断一个序列是否是等差数列<br>遍历这个序列，将每个差分插入到一个集合中，如果最后集合的大小等于1，则为等差数列，还可以判断不同差分值的个数。<br>还可以通过set的方法访问首值和尾值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="type">int</span> x = *s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="type">int</span> y = *s.<span class="built_in">rbegin</span>();</span><br></pre></td></tr></table></figure><hr><p>5.在局部区域定义一个初始值为0的数组</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[N]&#123;&#125;;</span><br></pre></td></tr></table></figure><p>可以发现最后a数组中的值都为0，和全局域定义的数组效果几乎一样。</p><p><strong>vector数组第二维还可以赋值，将一个一维动态数组赋给一个二维数组的第二维</strong></p><p>有一个定义数组的小技巧</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个二维数组，第一维长度为200，第二维长度为0</span></span><br><span class="line"> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bk</span>(<span class="number">200</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//m*n的二维vector，所有元素为0</span></span><br><span class="line"> vector&lt;vector &lt;<span class="type">int</span>&gt; &gt; <span class="built_in">num</span>(m ,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>6.枚举二进制时的思路：一般数据范围比较小，需要枚举$0\backsim2 ^{cnt}-1$每个数，然后再对每个二进制位进行判断</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;cnt);i++)<span class="comment">//对每个数进行枚举</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;cnt;j++)<span class="comment">//对每个二进制位数进行判断</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))<span class="comment">// i 代表这个数  1&lt;&lt;j是每个二进制位为1循环一遍，进行与运算，判断i的二进制位</span></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p>7.定义vector用简单代码的输入，从0位置开始</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : a)&#123;cin &gt;&gt; x;&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="8-获得vector中的最大值-最小值-max-element-v-begin-v-end-返回的是最大值所在的迭代器，即位置min-element-v-begin-v-end-返回的是最大值所在的迭代器，即位置"><a href="#8-获得vector中的最大值-最小值-max-element-v-begin-v-end-返回的是最大值所在的迭代器，即位置min-element-v-begin-v-end-返回的是最大值所在的迭代器，即位置" class="headerlink" title="8.获得vector中的最大值(最小值)max_element(v.begin(),v.end()) 返回的是最大值所在的迭代器，即位置min_element(v.begin(),v.end()) 返回的是最大值所在的迭代器，即位置"></a>8.获得vector中的最大值(最小值)<br>max_element(v.begin(),v.end()) 返回的是最大值所在的迭代器，即位置<br>min_element(v.begin(),v.end()) 返回的是最大值所在的迭代器，即位置<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span> &gt;v;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mx = *<span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> mn = *<span class="built_in">min_element</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></h2><p>9.c++结构体也可以写成员函数，通过打点来访问</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt[N], ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><hr><h2 id="10-卡空格写法"><a href="#10-卡空格写法" class="headerlink" title="10.卡空格写法"></a>10.卡空格写法<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(f)f=<span class="number">0</span>; <span class="comment">//如果为第一个元素，不输出空格，f置为0，接下来输出空格</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>11.求区间交集<br>有两个区间[a,b] [c,d],求区间交集长度</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(b&lt;c||a&gt;d) cout&lt;&lt;<span class="string">&quot;无交集\n&quot;</span>; </span><br><span class="line"><span class="keyword">else</span> ll len = <span class="built_in">min</span>(b,d)-<span class="built_in">max</span>(a,c);</span><br></pre></td></tr></table></figure><hr><p>12.结构体也可以进行强制转化，真的是没想到</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line">&#125;a[<span class="number">105</span>];<span class="comment">//如果要添加构造函数的话，创建结构体数组就会出错，因为没有传入参数，无法调用构造函数</span></span><br><span class="line"> a[<span class="number">1</span>] = (node)&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//将1,2，3强行转换为结构体类型，顺便还能赋值</span></span><br></pre></td></tr></table></figure><hr><p>13.前缀和还可以这样来求</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] += a[i<span class="number">-1</span>];</span><br><span class="line">&#125;<span class="comment">//直接用一个数组替代了两个数组</span></span><br></pre></td></tr></table></figure><blockquote><p>14.结论一条：<br>偏序定理：序列中 <strong>递减子序列的个数</strong>等于序列的<strong>最长上升子序列的长度</strong></p></blockquote><ul><li>用于求最长上升子序列和最长非上升子序列</li></ul><hr><p>15.输入的结束标志<br>当输入的数都是0时，便结束输入</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;x&gt;&gt;y&gt;&gt;z,x||y||z)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>16.等于运算符(&#x3D;&#x3D;)的优先级高于位运算符的优先级</p><p>乘除余 &gt; 加减 &gt; 左右移 &gt; 关系运算符（&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;） &gt; 与 异或 或 非 &gt; 逻辑与或（&amp;&amp; || ）&gt; 赋值运算符 &gt; (&#x2F;&#x3D;, %&#x3D; ,*&#x3D;)</p><hr><p>17.找树的直径</p><ul><li>任取一点作为起点，找到距该点最远的一个点u，(dfs,bfs)</li><li>再找距离u最远的一个点v,(dfs,bfs)</li><li>那么u和v之间的路径就是树的直径</li></ul><hr><p>18.输入输出同步解除和puts（）不能同时使用</p><hr><h2 id="19-移位运算时一定要注意数据范围，要不然很容易吃这方面的亏结果的数据类型取决于前面的数字"><a href="#19-移位运算时一定要注意数据范围，要不然很容易吃这方面的亏结果的数据类型取决于前面的数字" class="headerlink" title="19.移位运算时一定要注意数据范围，要不然很容易吃这方面的亏结果的数据类型取决于前面的数字"></a>19.移位运算时一定要注意数据范围，要不然很容易吃这方面的亏<br>结果的数据类型取决于前面的数字<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1ll</span>&lt;&lt;i;</span><br><span class="line"><span class="comment">//一定要注意前面的数字1数据为long long类型</span></span><br></pre></td></tr></table></figure></h2><h2 id="20-数组切段技巧，将相同元素的数组分段"><a href="#20-数组切段技巧，将相同元素的数组分段" class="headerlink" title="20.数组切段技巧，将相同元素的数组分段"></a>20.数组切段技巧，将相同元素的数组分段<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">1</span>;l&lt;=n;l=r+<span class="number">1</span>,r=l)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(r &lt; n &amp;&amp; a[l]==a[r+<span class="number">1</span>]) r++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,l,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>21.lamda表达式排序操作<br>例对数组进行从大到小的排序</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, [](<span class="type">const</span> <span class="type">int</span>&amp;A, <span class="type">const</span> <span class="type">int</span>&amp;B) &#123;</span><br><span class="line">     <span class="keyword">return</span> A &gt; B;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br></pre></td></tr></table></figure><hr><p>22.格式控制技巧</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//res数组是答案，进行输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n];</span><br></pre></td></tr></table></figure><p><code>&quot; \n&quot;[i==n]</code>是格式控制，前面当作string字符串，后面是下标的表达式，当<code>i!=n</code>时，下标取0，输出空格，当<code>i==n</code>下标取1，输出换行。</p><hr><p>23.Mex操作<br>数组<code>a</code>的前缀取Mex操作：</p><p><code>vis[i]</code>:代表数组中数字<code>i</code>是否出现,<strong>需要从前往后进行维护，不能一下预处理完</strong><br><code>tmp</code>:代表从第一个元素开始到当前的元素，<code>mex</code>值为<code>tmp</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">vis[a[i]] = <span class="literal">true</span>;<span class="comment">//维护vis</span></span><br><span class="line"><span class="keyword">while</span>(vis[tmp]) tmp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>24.浮点比较方法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(a-b)&lt;eps) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>25.取反操作：对正整数的每一位取反，除去符号位和前面的无效位。定义<code>c(x)</code>为取反操作<br>例<code>c(000101)=000010</code>，即只看后面的三位<br>设<code>n</code>为2的幂次方，则$c(x) &#x3D; x \oplus (n-1),n-1&#x3D;111…111_2$</p><hr><p>26.<code>__builtin_popcount()</code>c++内置函数：统计一个数<code>x</code>二进制中有多少个<code>1</code></p><hr><p>27.<code>map</code>查找元素是否存在时，可以使用<br>:one:<code>mp.find()</code> :two: <code>mp.count()</code> :three: <code>mp[key]</code><br>但是第三种情况，如果不存在对应的<code>key</code>时，会自动创建一个键值对（产生一个额外的键值对空间）<br>所以为了不增加额外的空间负担，最好使用前两种方法</p><hr><h2 id="28-让n变成小于等于n且是m的倍数（把n削减成最大的m的倍数）"><a href="#28-让n变成小于等于n且是m的倍数（把n削减成最大的m的倍数）" class="headerlink" title="28.让n变成小于等于n且是m的倍数（把n削减成最大的m的倍数）"></a>28.让<code>n</code>变成小于等于<code>n</code>且是<code>m</code>的倍数（把<code>n</code>削减成最大的<code>m</code>的倍数）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">n = n / m * m;</span><br></pre></td></tr></table></figure></h2><p>29.位运算枚举子集<br>一个数的初始值的二进制代表集合中的元素取和不取，1代表取，0代表不取。<br>$s0$代表初始集合，<code>i</code>代表每次产生的新的子集<br>集合统一使用一个数进行表示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = s0; i ; i = (i - <span class="number">1</span>) &amp; s0)<span class="comment">//递减和原集合进行位运算</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>30.对一个数组排序的最小操作数 &#x3D; <code>n - 环数</code></p><p>详情看：<a href="https://blog.csdn.net/yunxiaoqinghe/article/details/113153795">https://blog.csdn.net/yunxiaoqinghe/article/details/113153795</a></p><p>31.有<code>m</code>个区间，区间可能会有重合相交，每个区间都会对区间内的数字产生影响（可认为是区间加和），如果要单独剖出所有单个点不受影响的情况，可以进行如下想法：<br>区间存储可用以下数组：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">L</span>(n + <span class="number">1</span>), <span class="built_in">R</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//每次的读入</span></span><br><span class="line">cin &gt;&gt; seg[i].first &gt;&gt; seg[i].second;</span><br><span class="line">L[seg[i].first].<span class="built_in">push_back</span>(seg[i].second);</span><br><span class="line">R[seg[i].second].<span class="built_in">push_back</span>(seg[i].first);</span><br></pre></td></tr></table></figure><p><code>L[i]</code>代表以左端点<code>i</code>为起始点的右端点数组<br><code>R[i]</code>代表以右端点<code>i</code>为终端点的右端点数组<br>先将所有区间加和操作执行完，然后进行循环（类似<strong>扫描线</strong>），<strong>遇到区间开头就消除以此为左端点区间的影响，离开区间结尾就加上以此为右端点区间的影响</strong>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">int</span>(L[i].<span class="built_in">size</span>()); j++)</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, i, L[i][j], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(tr[<span class="number">1</span>].mx - tr[<span class="number">1</span>].mn &gt; ans)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//区间不包括端点i的处理</span></span><br><span class="line">        pos = i;</span><br><span class="line">        ans = tr[<span class="number">1</span>].mx - tr[<span class="number">1</span>].mn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">int</span>(R[i].<span class="built_in">size</span>()); j++)</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, R[i][j], i, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>32.最长路采用的是double乘法计算最长路（即边权相乘），将边权log一下，转化为边权相加，防止爆精度。即边权求$log(w)$当做新的边权，然后跑最短路或者最长路时，比较的是<code>dis + w</code></p><p>33.<code>sqrt</code>函数可能会有精度误差，里面是<code>double</code>的类型，如果传入<code>long long</code>类型，强转为<code>double</code>会有误差，建议<code>sqrt</code>加强一下。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll t = <span class="built_in">sqrt</span>(x);</span><br><span class="line"><span class="keyword">while</span>(t * t &gt; x) t--;</span><br><span class="line"><span class="keyword">while</span>((t + <span class="number">1</span>) * (t + <span class="number">1</span>) &lt;= x) t++;</span><br></pre></td></tr></table></figure><p>或者使用<code>sqrtl</code>，参数类型是<code>long double</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll t = <span class="built_in">sqrtl</span>(x);</span><br><span class="line"><span class="keyword">while</span>(t * t &gt; x) t--;</span><br><span class="line"><span class="keyword">while</span>((t + <span class="number">1</span>) * (t + <span class="number">1</span>) &lt;= x) t++;</span><br></pre></td></tr></table></figure><p>或者在里面直接转换为<code>long double</code>类型。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll t = <span class="built_in">sqrt</span>((<span class="type">long</span> <span class="type">double</span>) x);</span><br></pre></td></tr></table></figure><p>34.统计一个数的二进制下的位数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">ll x = <span class="number">114514232</span>;</span><br><span class="line"><span class="keyword">while</span> (x &gt;&gt; cnt) ++cnt;</span><br></pre></td></tr></table></figure><h2 id="持续更新中…-…"><a href="#持续更新中…-…" class="headerlink" title="持续更新中… …"></a>持续更新中… …</h2>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人算法题单整理</title>
      <link href="/p/542231525.html"/>
      <url>/p/542231525.html</url>
      
        <content type="html"><![CDATA[<p>记录个人刷过的算法经典题目（好题），以备复习回顾。</p><p>一级目录参考 <a href="https://oi-wiki.org/">OI Wiki</a> 进行设置。</p><h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h2 id="1-STL"><a href="#1-STL" class="headerlink" title="1 STL"></a>1 STL</h2><h3 id="1-1-set"><a href="#1-1-set" class="headerlink" title="1.1 set"></a>1.1 set</h3><table><thead><tr><th>知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td>multiset插入删除，异或运算性质：相邻元素值异或小于非相邻元素异或</td><td>ABC-600-Points</td><td><a href="https://atcoder.jp/contests/abc308/tasks/abc308_g">ABC308G</a></td></tr></tbody></table><h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h2 id="1-递归-分治"><a href="#1-递归-分治" class="headerlink" title="1 递归&amp;分治"></a>1 递归&amp;分治</h2><p>$nlogn$ 可以试着往分治上面想</p><table><thead><tr><th>知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td>分治</td><td></td><td>2023CCPC深圳A</td></tr></tbody></table><h2 id="2-贪心"><a href="#2-贪心" class="headerlink" title="2 贪心"></a>2 贪心</h2><table><thead><tr><th>知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td>贪心，排序，优先队列维护</td><td>ABC-500-Points</td><td><a href="https://atcoder.jp/contests/abc308/tasks/abc308_f">ABC308F</a> 23年天大预推免机试题摘自此处</td></tr></tbody></table><h2 id="3-二分"><a href="#3-二分" class="headerlink" title="3 二分"></a>3 二分</h2><table><thead><tr><th>知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td>二分中位数答案</td><td></td><td><a href="https://codeforces.com/gym/104768/problem/M">2023CCPC桂林</a></td></tr></tbody></table><h2 id="4-构造"><a href="#4-构造" class="headerlink" title="4 构造"></a>4 构造</h2><table><thead><tr><th>知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td><strong>构造-分治</strong>，二进制，二分图，思维</td><td>绿题</td><td><a href="https://www.luogu.com.cn/problem/P9384">LuoGuP9384&#x2F;THUPC2023决赛</a></td></tr></tbody></table><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="1-线性DP"><a href="#1-线性DP" class="headerlink" title="1 线性DP"></a>1 线性DP</h2><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">线性DP，前 $i$ 个选 $j$ 个的最优值</td><td>ABC-475-Points</td><td><a href="https://atcoder.jp/contests/abc327/tasks/abc327_e">ABC327E</a></td></tr></tbody></table><h2 id="2-背包DP"><a href="#2-背包DP" class="headerlink" title="2 背包DP"></a>2 背包DP</h2><h3 id="2-1-01背包"><a href="#2-1-01背包" class="headerlink" title="2.1 01背包"></a>2.1 01背包</h3><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">01背包+贪心</td><td>easy-medium</td><td><a href="https://qoj.ac/contest/1414">2023ICPC南京G</a></td></tr><tr><td align="left"><strong>bitset优化</strong>，数量上的二进制优化</td><td>CF-rating-2700</td><td><a href="https://codeforces.com/contest/1856/problem/E2">CF1856E2</a></td></tr><tr><td align="left">01背包+超大体积和价值，二进制拆分，分组背包思想</td><td>紫题</td><td><a href="https://www.luogu.com.cn/problem/P3188">LuoGuP3188</a></td></tr><tr><td align="left"><strong>前后缀背包</strong></td><td></td><td><a href="https://codeforces.com/gym/104090/problem/C">2022ICPC杭州C</a></td></tr><tr><td align="left"><strong>回退背包</strong> ，01背包计数回退</td><td>ABC-525-Points</td><td><a href="https://atcoder.jp/contests/abc321/tasks/abc321_f">ABC321F</a></td></tr></tbody></table><h3 id="2-2-多重背包"><a href="#2-2-多重背包" class="headerlink" title="2.2 多重背包"></a>2.2 多重背包</h3><h2 id="3-区间DP"><a href="#3-区间DP" class="headerlink" title="3 区间DP"></a>3 区间DP</h2><h2 id="4-树形DP"><a href="#4-树形DP" class="headerlink" title="4 树形DP"></a>4 树形DP</h2><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">经典换根DP</td><td>CF-Rating-1900</td><td><a href="https://codeforces.com/contest/1882/problem/D">CF1882D</a></td></tr><tr><td align="left">贪心 + 树形DP</td><td></td><td><a href="https://codeforces.com/gym/104768/problem/H">2023CCPC桂林H</a></td></tr></tbody></table><h2 id="5-状压DP"><a href="#5-状压DP" class="headerlink" title="5 状压DP"></a>5 状压DP</h2><h2 id="6-数位DP"><a href="#6-数位DP" class="headerlink" title="6 数位DP"></a>6 数位DP</h2><p>参考 <a href="https://zhuanlan.zhihu.com/p/613107701">知乎数位DP总结</a> </p><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">二进制拆分+组合计数+数位DP</td><td>银牌题</td><td><a href="https://codeforces.com/gym/104053/problem/M">2022CCPC广州M</a></td></tr><tr><td align="left">经典数位DP题目，需要注意pos为0时return的顺序，先判cnt，再判pos</td><td>CF-Rating-1900</td><td><a href="https://codeforces.com/problemset/problem/1036/C">CF1036C</a></td></tr></tbody></table><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="1-字典树Trie"><a href="#1-字典树Trie" class="headerlink" title="1 字典树Trie"></a>1 字典树Trie</h2><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">字典树，逆序字符串对统计</td><td></td><td><a href="https://codeforces.com/gym/104090/problem/K">2022ICPC杭州K</a></td></tr></tbody></table><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="1-数论"><a href="#1-数论" class="headerlink" title="1 数论"></a>1 数论</h2><h3 id="1-1-数论分块"><a href="#1-1-数论分块" class="headerlink" title="1.1 数论分块"></a>1.1 数论分块</h3><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">数论分块，找到 $l,r$ 很关键</td><td>蓝题</td><td><a href="https://www.luogu.com.cn/problem/P2261">LuoGuP2261</a></td></tr><tr><td align="left">整除分块+莫比乌斯反演</td><td>蓝题</td><td><a href="https://www.luogu.com.cn/problem/P3455">LuoGuP3455</a></td></tr></tbody></table><h2 id="2-线性代数"><a href="#2-线性代数" class="headerlink" title="2 线性代数"></a>2 线性代数</h2><h3 id="2-1-线性基"><a href="#2-1-线性基" class="headerlink" title="2.1 线性基"></a>2.1 线性基</h3><p><a href="https://taodaling.github.io/blog/2020/12/25/%E7%BA%BF%E6%80%A7%E5%9F%BA/">常见问题</a> </p><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">线性基</td><td>紫题</td><td><a href="https://www.luogu.com.cn/problem/P4151">LuoGuP4151</a></td></tr><tr><td align="left">线性基，统计子集异或和为0的所有元素个数之和</td><td></td><td><a href="https://ac.nowcoder.com/acm/contest/881/H">2019牛客多校1H</a> | <a href="https://blog.nowcoder.net/n/11e3e820640e4bbd8182566d4aa64be4">题解</a></td></tr><tr><td align="left">线性基，预处理因子，统计异或和为 0 和 x 的子集个数</td><td></td><td><a href="https://codeforces.com/gym/104768/problem/C">2023CCPC桂林C</a></td></tr></tbody></table><h2 id="3-博弈论"><a href="#3-博弈论" class="headerlink" title="3 博弈论"></a>3 博弈论</h2><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">找规律，sg函数，有向图游戏和</td><td></td><td><a href="https://codeforces.com/gym/104813/problem/J">2023CCPC哈尔滨J</a></td></tr></tbody></table><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1 并查集"></a>1 并查集</h2><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">区间合并，并查集判环</td><td></td><td><a href="https://codeforces.com/gym/104813/problem/G">2023CCPC哈尔滨G</a></td></tr></tbody></table><h2 id="2-线性数据结构"><a href="#2-线性数据结构" class="headerlink" title="2 线性数据结构"></a>2 线性数据结构</h2><h3 id="2-1-单调栈"><a href="#2-1-单调栈" class="headerlink" title="2.1 单调栈"></a>2.1 单调栈</h3><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">单调栈应用：求左（右）边第一个小（大）于 $a[i]$ 的位置<br />启发式分裂，两边都可以枚举统计答案，每次枚举数量较少的一遍</td><td>CF-rating-2300</td><td><a href="https://codeforces.com/contest/1849/problem/E">CF1849E</a></td></tr></tbody></table><h2 id="3-树状数组"><a href="#3-树状数组" class="headerlink" title="3 树状数组"></a>3 树状数组</h2><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">树状数组求区间不同颜色数+贪心+数据范围细节</td><td></td><td><a href="https://codeforces.com/gym/104768/problem/I">2023CCPC桂林I</a></td></tr></tbody></table><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="1-树上问题"><a href="#1-树上问题" class="headerlink" title="1 树上问题"></a>1 树上问题</h2><h3 id="1-1-树链剖分"><a href="#1-1-树链剖分" class="headerlink" title="1.1 树链剖分"></a>1.1 树链剖分</h3><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">长链剖分+贪心</td><td></td><td><a href="https://codeforces.com/gym/104077/problem/L">2022ICPC西安L</a></td></tr><tr><td align="left">长链剖分优化DP模板题</td><td>CF-Rating-2300</td><td><a href="https://codeforces.com/problemset/problem/1009/F">CF1009F</a></td></tr></tbody></table><h3 id="1-2-树哈希"><a href="#1-2-树哈希" class="headerlink" title="1.2 树哈希"></a>1.2 树哈希</h3><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">树同构+树哈希+基环树找环</td><td></td><td><a href="https://codeforces.com/gym/104090/problem/G">2022ICPC杭州G</a> （判断一个图的所有生成树是否同构）</td></tr></tbody></table><h2 id="2-最短路"><a href="#2-最短路" class="headerlink" title="2 最短路"></a>2 最短路</h2><h3 id="2-1-Dijkstra"><a href="#2-1-Dijkstra" class="headerlink" title="2.1 Dijkstra"></a>2.1 Dijkstra</h3><table><thead><tr><th align="left">知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td align="left">最短路径树板题（直接用dijkstra求从根出发的最短路，根到其他节点的最短路就形成一棵树，记一下pre就行）</td><td>CF-Rating-2000</td><td><a href="https://codeforces.com/problemset/problem/545/E">CF545E</a></td></tr></tbody></table><h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="1-扫描线"><a href="#1-扫描线" class="headerlink" title="1 扫描线"></a>1 扫描线</h2><table><thead><tr><th>知识点</th><th>难度</th><th>来源</th></tr></thead><tbody><tr><td>一维数组上的扫描线</td><td>偏思维，easy</td><td><a href="https://codeforces.com/contest/1884/problem/C">CF1884C</a> <a href="https://atcoder.jp/contests/abc188/tasks/abc188_d">ABC188D</a></td></tr></tbody></table><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google搜索语法</title>
      <link href="/p/2127276366.html"/>
      <url>/p/2127276366.html</url>
      
        <content type="html"><![CDATA[<p>希望能够使用Google搜索进行精准搜索。</p><h1 id="Google搜索语法"><a href="#Google搜索语法" class="headerlink" title="Google搜索语法"></a>Google搜索语法</h1><h1 id="1-内容搜索"><a href="#1-内容搜索" class="headerlink" title="1 内容搜索"></a>1 内容搜索</h1><h2 id="标题相关"><a href="#标题相关" class="headerlink" title="标题相关"></a>标题相关</h2><p>作用：限定标题内容。</p><h3 id="intitle"><a href="#intitle" class="headerlink" title="intitle"></a>intitle</h3><p>例：<code>intitle:Google搜索技巧</code> ，搜索出来的标题会包含 <code>Google搜索技巧</code> 相关内容。</p><h3 id="allintitle"><a href="#allintitle" class="headerlink" title="allintitle"></a>allintitle</h3><p>例：<code>intitle:浙江大学 亚运会</code> ，搜索出来的标题必须包含 <code>浙江大学</code> 或 <code>亚运会</code> 两个相关内容。</p><h2 id="文本相关"><a href="#文本相关" class="headerlink" title="文本相关"></a>文本相关</h2><h3 id="intext"><a href="#intext" class="headerlink" title="intext"></a>intext</h3><p>例：<code>intext:&quot;浙江大学&quot; &quot;亚运会&quot;</code> ，搜索出来的文章内容中必须包含 <code>浙江大学</code> 和 <code>亚运会</code> 两个关键词。</p><p>作用：限定文章内容。</p><h3 id="“”"><a href="#“”" class="headerlink" title="“”"></a>“”</h3><p>例：<code>&quot;Google搜索技巧&quot;</code> ，链接中完全包含”Google搜索技巧”关键字</p><p>搜索结果中会完全包含英文双引号内的关键字</p><h3 id=""><a href="#" class="headerlink" title="-"></a>-</h3><p>有时候，我们搜索的内容可能有多层含义，或者不想看到和某个信息相关的搜索，就可以使用连字符进行排除。</p><p>比如，搜索JavaScript，排除维基百科中的相关内容：<code>JavaScript -wikipedia</code></p><h3 id="-1"><a href="#-1" class="headerlink" title="*"></a>*</h3><p>使用星号填充内容（*），可以使用星号来填充文本之间的空格，比如在搜索时，只记得其中一部分内容，另一部分忘记了，就可以这样用。</p><p>例如，我们忘记了Git中撤销commit命令的第二个单词，可以这样搜索：<code>git * --soft HEAD^</code>。</p><h2 id="链接相关"><a href="#链接相关" class="headerlink" title="链接相关"></a>链接相关</h2><h3 id="inurl"><a href="#inurl" class="headerlink" title="inurl"></a>inurl</h3><p>例：<code>李子柒 inurl:cctv</code> ，搜索出来的链接中必须包含 <code>cctv</code> 。</p><p>作用：限定链接包含内容。</p><h3 id="site"><a href="#site" class="headerlink" title="site"></a>site</h3><p>例：<code>intitle:浙江大学 亚运会 site:www.zhihu.com</code> ，限定搜索的结果中全是知乎的链接，同时链接标题中包含 <code>浙江大学</code> 或 <code>亚运会</code> 两个相关内容。</p><p>作用：限定网址来源。</p><h1 id="2-图片搜索"><a href="#2-图片搜索" class="headerlink" title="2 图片搜索"></a>2 图片搜索</h1><h2 id="限定图片大小"><a href="#限定图片大小" class="headerlink" title="限定图片大小"></a>限定图片大小</h2><p>例：<code>elon musk imagesize:2560x1440</code> ，搜索出来的图片的大小为所示大小，乘号为英文字母<code>x</code>，大小写均可。</p><h1 id="3-文件搜索"><a href="#3-文件搜索" class="headerlink" title="3 文件搜索"></a>3 文件搜索</h1><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>例：<code>filetype:pdf</code> ，搜索出来的文件类型为<code>PDF</code>。</p><p>还有其他：<code>filetype:png</code>， <code>filetype:jpg</code></p><h1 id="4-其他命令"><a href="#4-其他命令" class="headerlink" title="4 其他命令"></a>4 其他命令</h1><h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><p><code>search：网站域名 搜索内容</code> 在指定网站内搜索内容。</p><h2 id="and"><a href="#and" class="headerlink" title="and"></a>and</h2><p>如果我们查找的内容包含多个关键字，可以使用and命令。</p><h2 id="or"><a href="#or" class="headerlink" title="or"></a>or</h2><p>使用or来查询多个关键词中的一个。</p><h2 id="define"><a href="#define" class="headerlink" title="define"></a>define</h2><p>使用Define关键词来查搜索关键词的定义。</p><p>例如：<code>define: JavaScript</code></p><h2 id="before-after"><a href="#before-after" class="headerlink" title="before&#x2F;after"></a>before&#x2F;after</h2><p>可以使用after来搜索指定时间之后的内容，使用before搜索指定时间之前的内容。</p><p>例如：<code>after: 2021 learn python</code>，搜索指定时间之后的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 开发知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Google搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于推免的那些事</title>
      <link href="/p/2802848655.html"/>
      <url>/p/2802848655.html</url>
      
        <content type="html"><![CDATA[<p>平生第一次搞推免，也是最后一次。错失了一些机会，也有幸获得了一些机会，值得祝庆，也值得反思。</p><p>以下记录为个人流水账。</p><hr><h1 id="个人背景"><a href="#个人背景" class="headerlink" title="个人背景"></a>个人背景</h1><p>我的背景可以算不是非常好了，况且今年211受歧视比较严重。</p><ul><li><p>学校：211，zzu，物联网工程</p></li><li><p>排名：夏令营时 3&#x2F;240，预推免时 4&#x2F;240，最终总排名 5&#x2F;240（基本用不上）</p></li><li><p>荣誉：国家励志，一等奖学金，三好学生</p></li><li><p>竞赛：一些XCPC省赛奖，CCPC区域银，个别水PPT类竞赛国奖（这个老师好像基本不看）</p></li><li><p>科研：基本没有，甚至连简历项目都没有，套的都是那种非常简单的那种项目，例如纯YOLO的目标检测，没有改进，纯数据相关工作。</p></li><li><p>最终去向：中科大网安学硕</p></li></ul><h1 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a>夏令营</h1><p>基本上是海投策略，能投的都投了，中等985至华五级别，最后结果可以算是很惨烈。下面只列出有些许进展的。</p><table><thead><tr><th>夏令营（部分）</th><th>入营结果</th><th>优营结果</th><th></th></tr></thead><tbody><tr><td>北航计院</td><td>入营</td><td>未优营</td><td>压力面</td></tr><tr><td>吉大计院</td><td>入营</td><td>优营（线上）</td><td>背景面</td></tr><tr><td>天大智算学部</td><td>入营</td><td>未优营</td><td>需要联系老师</td></tr><tr><td>武大测国重</td><td>入营</td><td>未优营</td><td>排名倒数第二</td></tr><tr><td>中南计院</td><td>入营（应该是之后侯补上的）</td><td>鸽</td><td>和武大衔接，没心力连跑两个</td></tr><tr><td>西交软院</td><td>入营</td><td>不安排面试</td><td>入营即预推免入场券</td></tr><tr><td>浙大软院</td><td>入营</td><td>未优营</td><td>做项目，随便交了个半成品</td></tr></tbody></table><ul><li>北航计院（6.30 - 7.2）</li></ul><p>第一个营，材料准备不是很到位，面试很硬核，专业知识+项目，20min拷打。包括英语(翻译)、高数、线代、概率论、离散、408和项目科研，问到不会为止。</p><p>刚开始还担心机试过不去，无法去面试，因为机试就两道大模拟，第二道我没有调出来，很久都没有敲代码了，没想到竟然还是能够面试。所有面试结束的当天晚上似乎就出了结果，结果当然是无了，连候补也没有。</p><p>第一个线下当然是去游玩了。也是第一次去北京，第一次出省，感受很不一样。</p><p>逛北航航空纪念馆，看飞机；游天坛公园，好热啊，好难受，似乎要中暑的感觉；看天安门，庄严肃穆的感觉，我好像真的中暑了，走走停停，晚时才缓过来；入景山公园，俯瞰故宫全貌；夜坐公交环天安门。整个旅途提前一天结束，浪费一天的订房费。</p><ul><li>吉大计院（7.4）</li></ul><p>好像按第一志愿筛，必须第一志愿才能入，营开的很早，又是线上，自然很多人报名，然后大批入营，大批优营，本校生入了很多，基本都有优营。所以说基本都是鸽子。</p><ul><li>武大测国重（7.9 - 7.11）</li></ul><p>夏令营报销普通火车额度车费，70元总饭费，包酒店住宿。此方面体验良好。</p><p>老师似乎不懂ACM，然后我项目被问穿了，排名倒二，之后简历痛删2个项目。</p><p>入汉后当然先来碗武汉热干面，入校签到收到厚厚一本科研记录书，然后寻好友，成功借小电车夜逛学校。这样的结果就是，纵然看着地图导航，也成功地迷路了，走进小道之中，且车电量不多，整个游的过程就是黑灯瞎摸基本啥都看不见，只有骑电车，走走停停看地图导航，心里只剩一个大字。</p><p>最终旅途以突然的大雨告终，本人淋雨些多，还车尤其狼狈，终于走向归途。</p><p>接下来的一天，上午坐公交集体游珞珈实验室，天气很热，看的不多，基本都是卫星遥感之类的。下午学长学姐进行讲座，讲述一些他们的故事。之后应该就是老师的见面环节，可以递简历聊天了。我递出了一份老版的简历，简单询问老师一些情况。（此时回看时，发现我是非常不擅长和老师交流）</p><p>下一天，只有面试，全程问项目。面完试好友带我简单逛一下校园，带着喝茶颜悦色，好哇！下午回程。</p><ul><li>天大智算学部（6.29）</li></ul><p>夏令营一千多人入营，机试筛一遍，机试非零分的可以面试。然后线上面试，纯背景面，结果迟迟不公布，8月下旬才公布。最后才发现是联系老师才有优营。</p><h1 id="预推免"><a href="#预推免" class="headerlink" title="预推免"></a>预推免</h1><p>夏令营没有收获，只有一个吉大offer，更加坚定海投策略，下面列出有结果的。</p><table><thead><tr><th>预推免（部分）</th><th>入营结果</th><th>推免结果</th><th></th></tr></thead><tbody><tr><td>北师大人工智能（第二批夏令营）</td><td>入营</td><td>优营</td><td>机试捞的我</td></tr><tr><td>东南大学计院（专硕）</td><td>入营</td><td>候补54</td><td></td></tr><tr><td>西交软院</td><td>入营</td><td>未优营</td><td></td></tr><tr><td>天大智算学部（预推免第一批）</td><td>入营</td><td>优营A+</td><td>机试捞的我</td></tr><tr><td>中科大网安</td><td>入营</td><td>优营且达成双选</td><td></td></tr><tr><td>华南理工</td><td>入营</td><td>放弃面试（9.25-9.26，太远太贵，紧接浙软结束时间）</td><td></td></tr><tr><td>华东师范计院</td><td>入营</td><td>放弃面试（9.26-9.27，浙软面试期间通知，已买回程票，无心再去）</td><td></td></tr><tr><td>浙大软院</td><td>入营</td><td>优营（排名50+）</td><td>机试捞的我</td></tr></tbody></table><ul><li>东南大学计院（专硕）（8.17 - 8.18）</li></ul><p>夏令营和预推免在一起，老师推荐才能入营，学专博分开排名。</p><p>线下自费参加，入营四五百人，学专共优营六十人左右，有本校保护。</p><p>线下PPT展示，介绍个人背景，竞赛科研，兴趣爱好以及项目。面试中有英语问答，老师问题主要针对项目，一定对自己展示的项目内容熟稔于心。</p><p>和好友一同前去，完全不报销。背包十年民宿，条件不是很好。</p><p>游良久几条商业街，反复逛，趣味渐退。后8.18上午复习，下午前去面试，基本也是项目。晚上预留了时间去旅游，便是夫子庙目的地，又有另一好友相伴。人超多，人挤人，看夫子庙，看秦淮河，或其他微小之地，后返程修整。</p><p>下一天，上午中山陵，然后看鸽子，下午总统府，同时有两位熊姓好友相伴，天气还是很热。总统府很大，满是历史痕迹。下午晚时便踏上返程。</p><ul><li>北师大人工智能（第二轮）（8.24 - 8.26）</li></ul><p>机试：ACM赛制，4道题，机试高分，面试基本能稳。我做了三道半，排名前几。</p><p>面试：群面机制，5个人一起，共20min，每个人回答问题机会和时间有限，必要时可抢答能给老师留下不错印象。面试基本没有太多项目类问题。</p><p>不报销，包吃住，吃大龙虾自主餐，住冬奥会志愿者住宿。去坐硬座，回有无座。</p><p>下午到达，吃完自助，领取物资，入住时还发生一点小插曲，处理好就好。遇到新舍友，识吉大好友。晚上当即打算面完就旅游去，延后一天回去，预留旅游时间。</p><p>下一天，上午宣讲致辞，稍微行欢迎之礼。下午机试，分数350&#x2F;400，感觉良好。晚饭破冰仪式，吃大龙虾自主，很多零食，很好的体验。晚上不再计划旅游，校园内图书馆、健身房等地闲逛。下一天上午面试便只觉机试至关重要，问题很水。中午抓紧吃完饭，前去旅游。</p><p>先是颐和园，再是圆明园。很大，耗时很长，走的很多，看的也很多。颐和园看十七孔桥，圆明园看断壁残垣。湖景众多，两园皆有。前有人多，后渐荒芜。现在还历历在目。</p><ul><li>天津大学智算学部（9.11）</li></ul><p>第一批五百人入营，机试筛到二百人；第二批近千人入营，同样机试筛人，通过机试才可前往线下面试。机试面试各占50%，面试主要为PPT介绍，介绍个人项目。</p><p>我没有较好的项目，面试多个问题没回答上来，优营后才知道机试成绩间接影响了面试成绩。（预推免优营人数少，只有将近20人，候补较多。）</p><p>又隔半月之久，天大机试应该全对，前往面试之途，此行同施姓好友。面试仅为一天，去程和回程均硬卧火车，睡眠不佳。</p><p>早上即到，面试进度尤其快，上午即面完。中午有幸让朱学长请两人吃饭，哈哈，破费了。下午交谈甚久，感触尤深（我之后确实要好好自我优化一下了）。施好友联系另一朋友，遂一行人混进南开大学，交谈、闲逛，又不幸让施好友的朋友破费了，太热情了，晚上即回。</p><p>下一天，去天津五大道逛，基本没有景点，均为西式和古时建筑。中午看天津之眼，拍照良久。又受施好友的朋友邀请，尝天津菜，再次体会到了热情。下午简单逛逛，趁机走到火车站，便返程。</p><ul><li>中科大网安（9.20） - 该日只是学院面时间</li></ul><p>夏令营报名了计院，当时联系了计院的一位老师，实验室前期考核通过，但因为专业被卡，未入营。</p><p>网安院是弱com，和老师<strong>达成双选</strong>大于一切。</p><p>预推免通知开始时，开始联系老师，9.4号套磁3位老师，9.6面试1个课题组，当晚收到通过结果。面试似乎是课题组的多位学生面，内容涉及简历中的各方面，如算法、计网、项目、ACM和其他。</p><p>经老师推荐我入营预推免，学院面试5min左右，我多个问题回答不太好，最后绝大部分优营，所以学院面应该是走流程。最后需要和老师达成双选才能拿到offer。</p><ul><li>浙大软院（9.22 - 9.24）</li></ul><p>约800人入营，去的约450人（还有人只参加机试试水，然后去华科面试），录取220人。</p><p>机试：4道题，IOI赛制，机试满分面试只要不拉跨就稳了。</p><p>面试：基本是闲聊，项目基本没被问到，一直在问其他的东西。面试根据其他同学说法，可能每个同学不一样，机试分数不同，面试难度也不同。</p><p>还是和北师大舍友同行，来时高铁，回去第一次体验飞机，全程自费。</p><p>下午到，一同吃完饭便简单逛了校园，之后稍作休息，准备晚上的机试。没想到晚上机试AK。</p><p>下一天不面试，便计划今日出游宁波几处景点-河姆渡、慈城古县城、东钱湖。</p><p>次日上午修改面试内容，下午一点多便进去面试，面完前往新酒店地点。下午逛宁波博物馆-三体拍摄之地，甚好。然后下一天上午暂时休息，提前就前往机场准备返程。</p><blockquote><p>另：今年是9.29填报系统</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 哲思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阶段性总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源停靠站</title>
      <link href="/p/1473860796.html"/>
      <url>/p/1473860796.html</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>2023-09-28之后再详细进行更新，之前要忙于某事务</li><li>2023-11-08本文打算转型，希望记录个人觉得好用的工具，专注打造个人工作流。</li><li>2023-11-28本文紧急改造中，致力于打造总资源分享库</li></ul></blockquote><hr><blockquote><p>资源失效时，及时在本文最后或公众号【行码棋】回复，看到后我会立马更新。</p></blockquote><h1 id="技术类"><a href="#技术类" class="headerlink" title="技术类"></a>技术类</h1><h2 id="1-编程语言"><a href="#1-编程语言" class="headerlink" title="1 编程语言"></a>1 编程语言</h2><ul><li>Python基础知识 学习视频，公众号【行码棋】回复【python资料】获取（内容可能已过时，谨慎选择）</li><li>大量算法相关的电子书，公众号【行码棋】回复【算法书籍】获取</li></ul><h2 id="2-专业知识"><a href="#2-专业知识" class="headerlink" title="2 专业知识"></a>2 专业知识</h2><ul><li>算法yxc基础提高课，公众号【行码棋】私聊我询问</li></ul><h1 id="AI类"><a href="#AI类" class="headerlink" title="AI类"></a>AI类</h1><h2 id="1-AI工具"><a href="#1-AI工具" class="headerlink" title="1 AI工具"></a>1 AI工具</h2><ul><li>Meta SAM图像分割demo，分割一切</li></ul><p>链接：<a href="https://segment-anything.com/demo">https://segment-anything.com/demo</a></p><ul><li>AI检测器</li></ul><p>链接：<a href="https://learningprompt.wiki/docs/midjourney-learning-path">https://learningprompt.wiki/docs/midjourney-learning-path</a></p><p>号称世界排名第一的 AI 检测器,逃避用 AI 写文章可能被抓到的工具。</p><p>工作原理：它会扰乱每个句子，并完全掩盖了任何文本（最多 5000 个单词），同时保留原意，直到所有 LLM 的痕迹都消失。</p><p>它结合使用了 NLP 技术，包括使用 GPT4 进行释义和谷歌 T5 模型的微调版本。</p><ul><li>设计师AI工具集合</li></ul><p>链接：<a href="https://designtools.ai/">https://designtools.ai/</a></p><p>专门收集设计师需要使用的ai工具的网站，工具是否收费已标明。</p><h2 id="2-AI教程"><a href="#2-AI教程" class="headerlink" title="2 AI教程"></a>2 AI教程</h2><ul><li>Midjourney教程</li></ul><p>链接：<a href="https://learningprompt.wiki/docs/midjourney-learning-path">https://learningprompt.wiki/docs/midjourney-learning-path</a></p><h2 id="3-chatgpt"><a href="#3-chatgpt" class="headerlink" title="3 chatgpt"></a>3 chatgpt</h2><blockquote><p>2023-11-08近期ChatGPT发展较快，链接可能失效，内容可能过时，且近期我关注较少，之后有时间再整理。</p></blockquote><h3 id="3-1-站点"><a href="#3-1-站点" class="headerlink" title="3.1 站点"></a>3.1 站点</h3><ul><li><p>Poe ChatGPT集成站 链接：<a href="https://poe.com/">https://poe.com</a></p></li><li><p>Claude 链接：<a href="https://claude.ai/chats">https://claude.ai/chats</a></p></li><li><p>可用站点（可能无效）</p><ul><li><a href="https://theb.ai/">https://theb.ai/</a></li><li><a href="https://dev.yqcloud.top/">https://dev.yqcloud.top/</a></li></ul></li><li><p><a href="https://1lib.ink/">https://1lib.ink/</a> （重定向至ChatGPT汇总站）</p></li></ul><h3 id="3-2-资料"><a href="#3-2-资料" class="headerlink" title="3.2 资料"></a>3.2 资料</h3><ul><li><p>ChatGPT 提示语大全 地址：<a href="https://prompts.fresns.cn/">https://prompts.fresns.cn/</a></p></li><li><p>ChatGPT 提示创建分享 地址：<a href="https://openprompt.co/">https://openprompt.co/</a></p></li><li><p>ChatGPT提示词Prompt ChatGPT Shortcut：<a href="https://www.aishort.top/">https://www.aishort.top/</a></p></li><li><p>ChatGPT资料汇总 地址：<a href="https://github.com/dalinvip/Awesome-ChatGPT">https://github.com/dalinvip/Awesome-ChatGPT</a></p></li><li><p>ChatGPT知识库网站 地址：<a href="https://chatgpt.moyucm.xyz/">https://chatgpt.moyucm.xyz/</a></p></li></ul><h1 id="素材类"><a href="#素材类" class="headerlink" title="素材类"></a>素材类</h1><h2 id="1-素材制作"><a href="#1-素材制作" class="headerlink" title="1 素材制作"></a>1 素材制作</h2><ul><li>AI制作PPT（似乎效果不太好，而且不知道怎么获得PPT）</li></ul><p>链接：<a href="https://gamma.app/">https://gamma.app/</a></p><ul><li>VectorizerAI – AI 位图转矢量</li></ul><p>链接：<a href="https://vectorizer.ai/">https://vectorizer.ai/</a></p><p>利用人工智能将 JPG、PNG 等位图转成矢量 SVG 格式。先用 MidJourney 生成插图，再用这个工具转成矢量略加修改，岂不美哉。</p><h2 id="2-素材资源"><a href="#2-素材资源" class="headerlink" title="2 素材资源"></a>2 素材资源</h2><ul><li>免费PPT模板 链接：<a href="https://www.1ppt.com/">https://www.1ppt.com/</a></li><li><strong>两万套PPT模板</strong>，公众号【行码棋】回复【两万套PPT模板】获取</li></ul><h1 id="前后端类"><a href="#前后端类" class="headerlink" title="前后端类"></a>前后端类</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li>静态资源JS、CSS开源库</li></ul><p>链接：<a href="https://cdn.baomitu.com/">https://cdn.baomitu.com/</a></p><p>极好用的CDN，可以用在个人静态博客界面上，减轻访问压力。</p><ul><li><p>某CDN 链接：<a href="https://unpkg.com/">https://unpkg.com/</a></p></li><li><p>博客：分享9个可免费使用的网站CDN加速服务 <a href="https://www.vvhan.com/cdn-web.html">https://www.vvhan.com/cdn-web.html</a></p></li></ul><h1 id="软件类"><a href="#软件类" class="headerlink" title="软件类"></a>软件类</h1><h2 id="1-编辑类"><a href="#1-编辑类" class="headerlink" title="1 编辑类"></a>1 编辑类</h2><ul><li><p>Typora 1.5.10（破解版） 公众号【行码棋】回复【0001】获取</p></li><li><p>Sublime Text（破解版）  公众号【行码棋】回复【0002】获取</p></li><li><p>Notion，可以多端同步，一款笔记软件，目前正在尝试，之前的有道云笔记感觉不是太好用，一直没有找到新的可用的笔记软件。</p></li></ul><h2 id="2-视频图像类"><a href="#2-视频图像类" class="headerlink" title="2 视频图像类"></a>2 视频图像类</h2><ul><li><p>当贝播放器TV版（电视播放阿里云盘视频） 链接：<a href="https://pan.lanzoub.com/b0ahxs82j">https://pan.lanzoub.com/b0ahxs82j</a></p></li><li><p>【Android】Wallcandy1.10.52 移动端壁纸软件 破解版  公众号【行码棋】回复【0003】获取</p></li></ul><h2 id="3-网络类"><a href="#3-网络类" class="headerlink" title="3 网络类"></a>3 网络类</h2><ul><li><del>clash for Windows <a href="https://github.com/Fndroid/clash_for_windows_pkg/releases/download/0.20.15/Clash.for.Windows-0.20.15-win.7z">点击下载</a></del></li></ul><hr><blockquote><p>如有获取资源需求，请关注个人公众号【行码棋】，抱歉了大家😭😭😭。</p></blockquote><p><img src="https://wyqz.top/medias/gzh.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib画图</title>
      <link href="/p/3804173379.html"/>
      <url>/p/3804173379.html</url>
      
        <content type="html"><![CDATA[<p>相关设置：</p><p>如果是在notebook中想使用<strong>嵌入式绘图</strong>，需添加</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure><p>如果想使用<strong>交互式绘图</strong>，需添加</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib notebook</span><br></pre></td></tr></table></figure><h1 id="折线图绘制"><a href="#折线图绘制" class="headerlink" title="折线图绘制"></a>折线图绘制</h1><h1 id="子图操作"><a href="#子图操作" class="headerlink" title="子图操作"></a>子图操作</h1><p><code>figure</code>相当于一张画布，画布中可以添加子图</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment"># fig = plt.figure(figsize=(4, 3)) 画的图大小宽4高3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2*2 方格中（假设画布被分成了4个网格） 显示在第1,2,4个位置(从1开始)</span></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>) <span class="comment"># 还可以简写参数为224</span></span><br><span class="line">plt.show() <span class="comment"># 此时就可以显示出图像了，此时图像具有横纵坐标相关信息</span></span><br></pre></td></tr></table></figure><p>对子图分别进行操作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax1.plot()</span><br><span class="line">ax2.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="操作-显示图片"><a href="#操作-显示图片" class="headerlink" title="操作-显示图片"></a>操作-显示图片</h1><p>第一种：使用<code>IPython + PIL</code>进行显示</p><p>下面代码显示多张图片，多张图片在一列显示，看着可能不美观。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示多张图像</span></span><br><span class="line"><span class="keyword">for</span> file_path <span class="keyword">in</span> file_list:</span><br><span class="line">    img = Image.<span class="built_in">open</span>(file_path)</span><br><span class="line"><span class="comment"># 同时还可以修改显示图片的尺寸 修改成180 * 180</span></span><br><span class="line">    img.resize((<span class="number">180</span>, <span class="number">180</span>))</span><br><span class="line">    display(img)</span><br></pre></td></tr></table></figure><p>第二种：使用<code>matplotlib</code> 子图功能进行显示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;&#x27;</span></span><br><span class="line">img = cv2.imread(path)</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax1.imshow(img) <span class="comment"># 此时第一个位置就显示出对应路径的图像了，此时具有坐标轴信息</span></span><br><span class="line"></span><br><span class="line">ax2 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.imshow(img) <span class="comment"># 也可以这样写，默认图像显示到最新子图的位置</span></span><br><span class="line">ax3 = fig.add_subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>) <span class="comment"># 还可以简写参数为224</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 画图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas数据处理</title>
      <link href="/p/2946568862.html"/>
      <url>/p/2946568862.html</url>
      
        <content type="html"><![CDATA[<h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><h1 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(path) <span class="comment"># path为读取数据的路径</span></span><br></pre></td></tr></table></figure><h1 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mport pandas <span class="keyword">as</span> pd</span><br><span class="line"> </span><br><span class="line">df = pd.DataFrame(data = [[<span class="string">&#x27;lisa&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="number">22</span>], [<span class="string">&#x27;joy&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="number">22</span>], [<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;21&#x27;</span>]],</span><br><span class="line">                  index = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                  columns = [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;sex&#x27;</span>,<span class="string">&#x27;age&#x27;</span>]) <span class="comment"># 测试数据。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df</span><br><span class="line">   name sex age</span><br><span class="line"><span class="number">1</span>  lisa   f  <span class="number">22</span></span><br><span class="line"><span class="number">2</span>   joy   f  <span class="number">22</span></span><br><span class="line"><span class="number">3</span>   tom   m  <span class="number">21</span></span><br></pre></td></tr></table></figure><h2 id="1-head和tail"><a href="#1-head和tail" class="headerlink" title="1 head和tail"></a>1 head和tail</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.head() <span class="comment"># 打印数据的前5行</span></span><br><span class="line">df.head(<span class="number">10</span>) <span class="comment"># 打印数据的前10行</span></span><br><span class="line"></span><br><span class="line">df.tail() <span class="comment"># 打印数据的后5行</span></span><br><span class="line">df.tail(<span class="number">10</span>) <span class="comment"># 打印数据的后10行</span></span><br><span class="line"></span><br><span class="line">df.loc[<span class="number">8</span>] <span class="comment"># 打印id = 8的这一行 loc[]下标从0开始，故是打印第9行数据（排除首行的属性名）</span></span><br><span class="line">df.loc[<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>)] <span class="comment"># 打印id=1和2的这两行</span></span><br><span class="line">df.loc[[<span class="number">1</span>, <span class="number">3</span>]] <span class="comment"># 打印id=1，3的这两行</span></span><br></pre></td></tr></table></figure><h2 id="2-df-‘column-name’"><a href="#2-df-‘column-name’" class="headerlink" title="2 df[‘column_name’]"></a>2 df[‘column_name’]</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">df[<span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line">df[[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;gender&#x27;</span>]] <span class="comment">#选取多列，多列名字要放在list里</span></span><br></pre></td></tr></table></figure><h2 id="3-df-row-start-index-row-end-index"><a href="#3-df-row-start-index-row-end-index" class="headerlink" title="3 df[row_start_index, row_end_index]"></a>3 df[row_start_index, row_end_index]</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="number">0</span>:]<span class="comment">#第0行及之后的行，相当于df的全部数据，注意冒号是必须的</span></span><br><span class="line">df[:<span class="number">2</span>]<span class="comment">#第2行之前的数据（不含第2行）</span></span><br><span class="line">df[<span class="number">0</span>:<span class="number">1</span>]<span class="comment">#第0行</span></span><br><span class="line">df[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">#第1行到第2行（不含第3行）</span></span><br><span class="line">df[-<span class="number">1</span>:] <span class="comment">#最后一行</span></span><br><span class="line">df[-<span class="number">3</span>:-<span class="number">1</span>] <span class="comment">#倒数第3行到倒数第1行（不包含最后1行即倒数第1行，这里有点烦躁，因为从前数时从第0行开始，从后数就是-1行开始，毕竟没有-0）</span></span><br></pre></td></tr></table></figure><h2 id="4-df-loc-index-column"><a href="#4-df-loc-index-column" class="headerlink" title="4 df.loc[index,column]"></a>4 df.loc[index,column]</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df.loc[index, column_name],选取指定行和列的数据</span></span><br><span class="line">df.loc[<span class="number">0</span>,<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">df.loc[<span class="number">0</span>:<span class="number">2</span>, [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>]] <span class="comment"># 选取第0行到第2行，name列和age列的数据, 注意这里的行选取是包含下标的。</span></span><br><span class="line">df.loc[[<span class="number">2</span>,<span class="number">3</span>],[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>]] <span class="comment"># 选取指定的第2行和第3行，name和age列的数据</span></span><br><span class="line">df.loc[df[<span class="string">&#x27;gender&#x27;</span>]==<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;name&#x27;</span>] <span class="comment"># 选取gender列是M，name列的数据</span></span><br><span class="line">df.loc[df[<span class="string">&#x27;gender&#x27;</span>]==<span class="string">&#x27;M&#x27;</span>,[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>]] <span class="comment"># 选取gender列是M，name和age列的数据</span></span><br></pre></td></tr></table></figure><h2 id="5-iloc-row-index-column-index"><a href="#5-iloc-row-index-column-index" class="headerlink" title="5 iloc[row_index, column_index]"></a>5 iloc[row_index, column_index]</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.iloc[<span class="number">0</span>,<span class="number">0</span>]<span class="comment">#第0行第0列的数据</span></span><br><span class="line">df.iloc[<span class="number">1</span>,<span class="number">2</span>]<span class="comment">#第1行第2列的数据，32</span></span><br><span class="line">df.iloc[[<span class="number">1</span>,<span class="number">3</span>],<span class="number">0</span>:<span class="number">2</span>]<span class="comment">#第1行和第3行，从第0列到第2列（不包含第2列）的数据</span></span><br><span class="line">df.iloc[<span class="number">1</span>:<span class="number">3</span>,[<span class="number">1</span>,<span class="number">2</span>]<span class="comment">#第1行到第3行（不包含第3行），第1列和第2列的数据</span></span><br></pre></td></tr></table></figure><h1 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h1><h2 id="1-按列添加"><a href="#1-按列添加" class="headerlink" title="1 按列添加"></a>1 按列添加</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">citys = [<span class="string">&#x27;ny&#x27;</span>,<span class="string">&#x27;zz&#x27;</span>,<span class="string">&#x27;xy&#x27;</span>]</span><br><span class="line">df.insert(<span class="number">0</span>,<span class="string">&#x27;city&#x27;</span>,citys) <span class="comment">#在第0列，加上column名称为city，值为citys的数值。</span></span><br><span class="line">jobs = [<span class="string">&#x27;student&#x27;</span>,<span class="string">&#x27;AI&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>]</span><br><span class="line">df[<span class="string">&#x27;job&#x27;</span>] = jobs <span class="comment">#默认在df最后一列加上column名称为job，值为jobs的数据。</span></span><br><span class="line">df.loc[:,<span class="string">&#x27;salary&#x27;</span>] = [<span class="string">&#x27;1k&#x27;</span>,<span class="string">&#x27;2k&#x27;</span>,<span class="string">&#x27;2k&#x27;</span>,<span class="string">&#x27;2k&#x27;</span>,<span class="string">&#x27;3k&#x27;</span>] <span class="comment">#在df最后一列加上column名称为salary，值为等号右边数据。</span></span><br></pre></td></tr></table></figure><h2 id="2-按行添加"><a href="#2-按行添加" class="headerlink" title="2 按行添加"></a>2 按行添加</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[<span class="number">4</span>] = [<span class="string">&#x27;zz&#x27;</span>,<span class="string">&#x27;mason&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="number">24</span>,<span class="string">&#x27;engineer’]#若df中没有index为“4”的这一行的话，该行代码作用是往df中加一行index为“4”，值为等号右边值的数据。若df中已经有index为“4”的这一行，则该行代码作用是把df中index为“4”的这一行修改为等号右边数据。</span></span><br><span class="line"><span class="string">df_insert = pd.DataFrame(&#123;&#x27;</span>name<span class="string">&#x27;:[&#x27;</span>mason<span class="string">&#x27;,&#x27;</span>mario<span class="string">&#x27;],&#x27;</span>sex<span class="string">&#x27;:[&#x27;</span>m<span class="string">&#x27;,&#x27;</span><span class="string">f&#x27;],&#x27;</span>age<span class="string">&#x27;:[21,22]&#125;,index = [4,5])</span></span><br><span class="line"><span class="string">ndf = df.append(df_insert,ignore_index = True) #返回添加后的值，并不会修改df的值。ignore_index默认为False，意思是不忽略index值，即生成的新的ndf的index采用df_insert中的index值。若为True，则新的ndf的index值不使用df_insert中的index值，而是自己默认生成。</span></span><br></pre></td></tr></table></figure><h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><h2 id="1-loc"><a href="#1-loc" class="headerlink" title="1 loc"></a>1 loc</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[<span class="number">1</span>,<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;aa&#x27;</span> <span class="comment">#修改index为‘1’，column为‘name’的那一个值为aa。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[<span class="number">1</span>] = [<span class="string">&#x27;bb&#x27;</span>,<span class="string">&#x27;ff&#x27;</span>,<span class="number">11</span>] <span class="comment">#修改index为‘1’的那一行的所有值。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[<span class="number">1</span>,[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>]] = [<span class="string">&#x27;bb&#x27;</span>,<span class="number">11</span>]    <span class="comment">#修改index为‘1’，column为‘name’的那一个值为bb，age列的值为11。</span></span><br></pre></td></tr></table></figure><h2 id="2-iloc-row-index-column-index"><a href="#2-iloc-row-index-column-index" class="headerlink" title="2 iloc[row_index, column_index]"></a>2 iloc[row_index, column_index]</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.iloc[<span class="number">2</span>, <span class="number">1</span>] = <span class="number">12</span> <span class="comment"># 将3行2列的数据更新为12</span></span><br><span class="line">df.iloc[:,<span class="number">2</span>] = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>] <span class="comment">#修改一整列</span></span><br><span class="line">df.iloc[<span class="number">0</span>,:] = [<span class="string">&#x27;lily&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">15</span>] <span class="comment">#修改一整行</span></span><br></pre></td></tr></table></figure><h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><h2 id="1-删除行"><a href="#1-删除行" class="headerlink" title="1 删除行"></a>1 删除行</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop([<span class="number">1</span>,<span class="number">3</span>],axis = <span class="number">0</span>,inplace = <span class="literal">False</span>)<span class="comment">#删除index值为1和3的两行，</span></span><br></pre></td></tr></table></figure><h2 id="2-删除列"><a href="#2-删除列" class="headerlink" title="2 删除列"></a>2 删除列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop([<span class="string">&#x27;name&#x27;</span>],axis = <span class="number">1</span>,inplace = <span class="literal">False</span>) <span class="comment"># 删除name列。</span></span><br><span class="line"><span class="keyword">del</span> df[<span class="string">&#x27;name&#x27;</span>] <span class="comment"># 删除name列。</span></span><br><span class="line">ndf = df.pop(<span class="string">&#x27;age’) # 删除age列，操作后，df都丢掉了age列,age列返回给了ndf。</span></span><br></pre></td></tr></table></figure><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h1 id="与numpy的转换"><a href="#与numpy的转换" class="headerlink" title="与numpy的转换"></a>与numpy的转换</h1><ul><li><code>dataframe</code>转化为<code>array</code>：</li></ul><p><code>df.to_numpy()</code>返回的是一个 array 类型：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_numpy()</span><br></pre></td></tr></table></figure><ul><li><code>array</code>转换为<code>dataframe</code> ：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(array)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pandas </tag>
            
            <tag> 数据处理 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11 多线程</title>
      <link href="/p/2668140628.html"/>
      <url>/p/2668140628.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-11-多线程"><a href="#C-11-多线程" class="headerlink" title="C++11 多线程"></a>C++11 多线程</h1><blockquote><p>参考：</p><p>C++11 thread多线程：<a href="https://blog.csdn.net/sjc_0910/article/details/118861539">https://blog.csdn.net/sjc_0910/article/details/118861539</a></p><p>C++11 左右值引用：<a href="https://blog.csdn.net/Jacky_Feng/article/details/120742414">https://blog.csdn.net/Jacky_Feng/article/details/120742414</a></p><p>C++11 移动构造函数：<a href="https://zhuanlan.zhihu.com/p/365412262">https://zhuanlan.zhihu.com/p/365412262</a></p></blockquote><h1 id="C-11-std-thread"><a href="#C-11-std-thread" class="headerlink" title="C++11 std::thread"></a>C++11 std::thread</h1><p>在C中已经有一个叫做<code>pthread</code>的东西来进行多线程编程，但是并不好用 ，所以c++11标准库中出现了一个叫作<code>std::thread</code>的东西。</p><h2 id="1-成员函数"><a href="#1-成员函数" class="headerlink" title="1 成员函数"></a>1 成员函数</h2><p>构造函数和析构函数</p><table><thead><tr><th>函数</th><th>类别</th><th>作用</th></tr></thead><tbody><tr><td><code>thread() noexcept</code></td><td>默认构造函数</td><td>创建一个线程， 什么也不做</td></tr><tr><td><code>template &lt;class Fn, class… Args&gt; explicit thread(Fn&amp;&amp; fn, Args&amp;&amp;… args)</code></td><td>初始化构造函数</td><td>创建一个线程， 以<code>args</code>为参数 执行<code>fn</code>函数</td></tr><tr><td><code>thread(const thread&amp;) = delete</code></td><td>复制构造函数</td><td>（已删除）</td></tr><tr><td><code>thread(thread&amp;&amp; x) noexcept</code></td><td>移动构造函数</td><td>构造一个与<code>x</code> 相同的对象,会破坏<code>x</code>对象</td></tr><tr><td><code>~thread()</code></td><td>析构函数</td><td>析构对象</td></tr></tbody></table><p>成员函数</p><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>void join()</code></td><td align="center">等待子线程结束并清理资源（会阻塞）</td></tr><tr><td align="center"><code>bool joinable()</code></td><td align="center">返回线程是否可以执行join函数</td></tr><tr><td align="center"><code>void detach()</code></td><td align="center">将线程与调用其的线程分离，彼此独立执行（此函数必须在线程创建时立即调用，且调用此函数会使其不能被join）</td></tr><tr><td align="center"><code>std::thread::id get_id()</code></td><td align="center">获取线程id</td></tr><tr><td align="center"><code>thread&amp; operator=(thread &amp;&amp;rhs)</code></td><td align="center">见移动构造函数（如果对象是joinable的，那么会调用<code>std::terminate()</code>结果程序）</td></tr></tbody></table><h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2 示例"></a>2 示例</h2><ul><li><code>lambda</code>表达式传参</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;HiHiHi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">td1</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;Hello,&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span>, <span class="title">td2</span><span class="params">([] &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;World!&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span>, <span class="title">td3</span><span class="params">(func)</span></span>;</span><br><span class="line"></span><br><span class="line">td1.<span class="built_in">join</span>();</span><br><span class="line">td2.<span class="built_in">join</span>();</span><br><span class="line">td3.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程运行时是以异步方式执行的，异步方式可以同时执行多条语句。</p><p>在上面的例子中，我们定义了3个thread，这3个thread在执行时并不会按照一定的顺序。</p><p>输出可能以任意一个顺序输出。</p><ul><li>传入的函数带参数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Answer: &quot;</span> &lt;&lt; a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">std::thread <span class="title">td3</span><span class="params">(func, <span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">td3.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行带引用参数的函数</li></ul><p>注意观察构造函数：<code>Args&amp;&amp;... args</code></p><p>很明显的右值引用，那么我们该如何传递一个左值呢？<code>std::ref</code>和<code>std::cref</code>很好地解决了这个问题。</p><p><code>std::ref</code> 可以包装按引用传递的值。</p><p><code>std::cref</code> 可以包装按<code>const</code>引用传递的值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeValue</span><span class="params">(T&amp; x, T val)</span> </span>&#123;</span><br><span class="line">x = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::thread t[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> nums[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造函数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">t[i] = std::<span class="built_in">thread</span>(changeValue&lt;<span class="type">int</span>&gt;, std::<span class="built_in">ref</span>(nums[i]), i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">t[i].<span class="built_in">join</span>();</span><br><span class="line">std::cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注意"><a href="#3-注意" class="headerlink" title="3 注意"></a>3 注意</h2><ul><li>线程是在thread对象被定义的时候开始执行的，而不是在调用join函数时才执行的，调用join函数只是阻塞等待线程结束并回收资源。</li></ul><blockquote><p><code>join</code>函数是等待子线程完成，然后主线程再继续执行</p></blockquote><ul><li>分离的线程（执行过detach的线程）会在调用它的线程结束或自己结束时释放资源。</li><li>线程会在函数运行完毕后自动释放，不推荐利用其他方法强制结束线程，可能会因资源未释放而导致内存泄漏。</li><li><strong>没有执行<code>join</code>或<code>detach</code>的线程在程序结束时会引发异常</strong></li></ul><h1 id="C-11-std-mutex与std-atomic"><a href="#C-11-std-mutex与std-atomic" class="headerlink" title="C++11 std::mutex与std::atomic"></a>C++11 std::mutex与std::atomic</h1><h2 id="1-std-mutex"><a href="#1-std-mutex" class="headerlink" title="1 std::mutex"></a>1 std::mutex</h2><p>多线程操作同一变量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">val++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::thread t[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">t[i] = std::<span class="built_in">thread</span>(increase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">t[i].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现此代码输出并不是正常情况下的<code>2000000</code>，原因就是多线程访问并修改一个变量时造成了冲突，所以mutex派上用场</p><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>void lock()</code></td><td align="center">将mutex上锁。 <br />如果mutex已经被其它线程上锁， 那么会阻塞，直到解锁；<br /> 如果mutex已经被同一个线程锁住， 那么会产生死锁。</td></tr><tr><td align="center"><code>void unlock()</code></td><td align="center">解锁mutex，释放其所有权。 如果有线程因为调用lock()不能上锁而被阻塞，则调用此函数会将mutex的主动权随机交给其中一个线程； 如果mutex不是被此线程上锁，那么会引发未定义的异常。</td></tr><tr><td align="center"><code>bool try_lock()</code></td><td align="center">尝试将mutex上锁。 如果mutex未被上锁，则将其上锁并返回true； <br />如果mutex已被锁则返回false。</td></tr></tbody></table><p>可以利用mutex进行改进：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">mtx.<span class="built_in">lock</span>();</span><br><span class="line">val++;</span><br><span class="line">mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::thread t[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">t[i] = std::<span class="built_in">thread</span>(increase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">t[i].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-std-atomic"><a href="#2-std-atomic" class="headerlink" title="2 std::atomic"></a>2 std::atomic</h2><p>mutex每次循环都要加锁解锁，比较慢，而atomic比较快。将上述代码改成下面代码同样也可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic_int val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">val++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::thread t[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">t[i] = std::<span class="built_in">thread</span>(increase);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">t[i].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::atomic_int</code>只是<code>std::atomic&lt;int&gt;</code>的别名。</p><p>即使是多线程，也要像同步进行一样<strong>同步操作</strong>atomic对象，从而省去了mutex上锁、解锁的时间消耗。</p><table><thead><tr><th align="center">构造函数</th><th align="center">类型</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>atomic() noexcept = default</code></td><td align="center">默认构造函数</td><td align="center">构造一个atomic对象（未初始化，可通过atomic_init进行初始化）</td></tr><tr><td align="center"><code>constexpr atomic(T val) noexcept</code></td><td align="center">初始化构造函数</td><td align="center">构造一个atomic对象，用<code>val</code>的值来初始化</td></tr></tbody></table><h1 id="C-11-std-async"><a href="#C-11-std-async" class="headerlink" title="C++11 std::async"></a>C++11 std::async</h1><h2 id="1-async"><a href="#1-async" class="headerlink" title="1 async"></a>1 async</h2><blockquote><p>头文件<code>&lt;future&gt;</code></p></blockquote><p><strong>大多数情况下使用async而不用thread</strong></p><ul><li>thread可以快速、方便地创建线程，但在async面前，就是小巫见大巫了。</li><li>async可以根据情况选择同步执行或创建新线程来异步执行，当然也可以手动选择。对于async的返回值操作也比thread更加方便。</li></ul><p><strong>std::async参数：</strong></p><p>不同于thread，async是一个函数，所以没有成员函数。</p><table><thead><tr><th>重载版本</th><th>作用</th></tr></thead><tbody><tr><td>template &lt;class Fn, class… Args&gt; <br />future&lt;typename result_of&lt;Fn(Args…)&gt;::type&gt;  <br /><code>async (Fn&amp;&amp; fn, Args&amp;&amp;… args)</code></td><td>异步或同步（根据操作系统而定）以args为参数执行fn<br/>同样地，传递引用参数需要<code>std::ref</code>或<code>std::cref</code></td></tr><tr><td>template &lt;class Fn, class… Args&gt;<br/> future&lt;typename result_of&lt;Fn(Args…)&gt;::type&gt;<br/>  <code>async (launch policy, Fn&amp;&amp; fn, Args&amp;&amp;… args);</code></td><td>异步或同步（根据<code>policy</code>参数而定（见下文））以args为参数执行fn，引用参数同上</td></tr></tbody></table><h2 id="2-std-launch强枚举类（enum-class）"><a href="#2-std-launch强枚举类（enum-class）" class="headerlink" title="2 std::launch强枚举类（enum class）"></a>2 std::launch强枚举类（enum class）</h2><p>std::launch有2个枚举值和1个特殊值：</p><table><thead><tr><th>标识符</th><th>实际值</th><th>作用</th></tr></thead><tbody><tr><td>枚举值：launch::async</td><td>0x1（1）</td><td>异步启动</td></tr><tr><td>枚举值：launch::deferred</td><td>0x2（2）</td><td>在调用<code>future::get</code>、<code>future::wait</code>时同步启动（std::future见后文）</td></tr><tr><td>特殊值：launch::async | launch::deferred</td><td>0x3（3）</td><td>同步或异步，根据操作系统而定</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::<span class="built_in">async</span>(std::launch::async, [](<span class="type">const</span> <span class="type">char</span>* message) &#123;</span><br><span class="line">std::cout &lt;&lt; message;</span><br><span class="line">&#125;, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;World\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器可能会有警告，因为编译器不想让你丢弃async的返回值std::future，不过在这个例子中不需要它，忽略这个警告就行了。</p><h2 id="3-std-future"><a href="#3-std-future" class="headerlink" title="3 std::future"></a>3 std::future</h2><p>使用它获取函数返回值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">sum</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span> + ... + args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; val = std::<span class="built_in">async</span>(std::launch::async, sum&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; val.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h1 id="项目练习"><a href="#项目练习" class="headerlink" title="项目练习"></a>项目练习</h1><p>附上我以此为基的学习项目：</p><p>基于C++17的线程池：<a href="https://github.com/anda522/ThreadPool">https://github.com/anda522/ThreadPool</a></p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex语法</title>
      <link href="/p/917541138.html"/>
      <url>/p/917541138.html</url>
      
        <content type="html"><![CDATA[<h1 id="Latex语法"><a href="#Latex语法" class="headerlink" title="Latex语法"></a>Latex语法</h1><p>在<code>begin&#123;document&#125;</code>和<code>end&#123;document&#125;</code>之间的就是正文区，而在这之前的就是导言区。</p><h2 id="1-宏包导入"><a href="#1-宏包导入" class="headerlink" title="1 宏包导入"></a>1 宏包导入</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;宏包1, 宏包2&#125;</span><br></pre></td></tr></table></figure><h2 id="2-中文支持"><a href="#2-中文支持" class="headerlink" title="2 中文支持"></a>2 中文支持</h2><p>无论是在线工具还是本地工具，LaTeX默认都是不支持中文的，因此需要在源代码和配置上稍作修改才可以让LaTeX支持中文，步骤如下：</p><ol><li>编译器配置：<code>XeLaTeX</code></li><li><code>tex</code>文件编码：<code>utf-8</code></li><li>代码开头添加</li></ol><p>方式一：添加宏包</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% -- coding: UTF-8 --</span></span><br><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125; <span class="comment">% 在文件类型下面添加宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>[UTF8]&#123;ctex&#125;</span><br></pre></td></tr></table></figure><p>方式二：设置文档类型</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% -- coding: UTF-8 --</span></span><br><span class="line"><span class="keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;</span><br></pre></td></tr></table></figure><h2 id="3-注释"><a href="#3-注释" class="headerlink" title="3 注释"></a>3 注释</h2><ul><li>单行注释</li></ul><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 这是一个注释</span></span><br></pre></td></tr></table></figure><ul><li><p>多行注释</p><ul><li><p>方式一（推荐）</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\iffalse</span></span><br><span class="line">注释内容</span><br><span class="line"><span class="keyword">\fi</span></span><br></pre></td></tr></table></figure></li><li><p>方式二</p></li></ul><p>使用<code>\usepackage&#123;verbatim&#125;</code>宏包</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;comment&#125;</span><br><span class="line">注释内容</span><br><span class="line"><span class="keyword">\end</span>&#123;comment&#125; </span><br></pre></td></tr></table></figure></li></ul><h2 id="4-转义字符"><a href="#4-转义字符" class="headerlink" title="4 转义字符"></a>4 转义字符</h2><p>可以使用<code>\</code>来转义一些特殊字符，如<code>\%</code>，<code>\_</code></p><h1 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h1><h2 id="1-首行缩进"><a href="#1-首行缩进" class="headerlink" title="1 首行缩进"></a>1 首行缩进</h2><ul><li>缩进</li></ul><p>进行缩进若LaTeX默认没有段首缩进，因此要首行缩进需要进行修改。在导言区加入如下代码（距离单位一般为<code>pt</code>或<code>em</code>，<code>pt</code>是绝对单位；<code>em</code>是相对单位，表示1个中文字符宽度）</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 使用indentfirst宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;indentfirst&#125;</span><br><span class="line"><span class="comment">% 设置首行缩进距离</span></span><br><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\parindent</span>&#125;&#123;2em&#125;</span><br></pre></td></tr></table></figure><ul><li>不进行缩进</li></ul><ol><li>方式1（推荐）： 单段取消缩进，放在段首即可。</li></ol><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\noindent</span></span><br></pre></td></tr></table></figure><ol start="2"><li>方式2： 全局取消缩进，在想缩进的段落再进行缩进。</li></ol><p>放在导言区：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\parindent</span>&#125;&#123;0pt&#125;</span><br></pre></td></tr></table></figure><p>放在想要缩进的段落：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hspace</span>*&#123;2em&#125;段落<span class="keyword">\\</span></span><br></pre></td></tr></table></figure><h2 id="2-换行"><a href="#2-换行" class="headerlink" title="2 换行"></a>2 换行</h2><table><thead><tr><th align="center">源码</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><code>\\</code></td><td align="center">一般在一行的最后一行写</td></tr><tr><td align="center"><code>\\[offset]</code></td><td align="center">换行，并且与下一行的行间距为原来行间距+offset，offset单位一般是<code>em</code>或<code>pt</code></td></tr></tbody></table><h2 id="3-更换段落"><a href="#3-更换段落" class="headerlink" title="3 更换段落"></a>3 更换段落</h2><table><thead><tr><th align="center">源码</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">无</td><td align="center">源代码空一行即可进行换段</td></tr><tr><td align="center"><code>\par</code></td><td align="center">一般在一段的最后写</td></tr></tbody></table><h2 id="4-页面更换"><a href="#4-页面更换" class="headerlink" title="4 页面更换"></a>4 页面更换</h2><p><code>\newpage</code>进行换页</p><h2 id="5-纸张设置"><a href="#5-纸张设置" class="headerlink" title="5 纸张设置"></a>5 纸张设置</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 设置页面的环境,a4纸张大小，左右上下边距信息</span></span><br><span class="line"><span class="keyword">\usepackage</span>[a4paper,left=30mm,right=25mm,top=25mm,bottom=25mm]&#123;geometry&#125;</span><br></pre></td></tr></table></figure><h2 id="6-标题分级"><a href="#6-标题分级" class="headerlink" title="6 标题分级"></a>6 标题分级</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\section</span>&#123;一级标题&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;二级标题&#125; </span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;二级标题&#125; </span><br></pre></td></tr></table></figure><h2 id="7-使用模板"><a href="#7-使用模板" class="headerlink" title="7 使用模板"></a>7 使用模板</h2><h2 id="8-单双栏模式"><a href="#8-单双栏模式" class="headerlink" title="8 单双栏模式"></a>8 单双栏模式</h2><ul><li>单栏</li></ul><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[onecolumn]&#123;article&#125;</span><br></pre></td></tr></table></figure><ul><li>双栏</li></ul><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>[twocolumn]&#123;article&#125;</span><br></pre></td></tr></table></figure><h1 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h1><h2 id="1-空格"><a href="#1-空格" class="headerlink" title="1 空格"></a>1 空格</h2><p>源码：<code>a \quad b</code>，显示：<code>a b</code>，宽度为1个中文字符宽度</p><p>源码：<code>a \qquad b</code>，显示：<code>a  b</code>，宽度为2个中文字符宽度</p><p>源码：<code>a\ b</code>，显示：<code>a b</code>，宽度为$\frac{1}{3}$个字符宽度</p><h2 id="2-标题、作者与日期"><a href="#2-标题、作者与日期" class="headerlink" title="2 标题、作者与日期"></a>2 标题、作者与日期</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125; <span class="comment">% article 文档</span></span><br><span class="line"><span class="keyword">\usepackage</span>[UTF8]&#123;ctex&#125;  <span class="comment">% 使用宏包(为了能够显示汉字)</span></span><br><span class="line"><span class="comment">% 设置页面的环境,a4纸张大小，左右上下边距信息</span></span><br><span class="line"><span class="keyword">\usepackage</span>[a4paper,left=30mm,right=25mm,top=25mm,bottom=25mm]&#123;geometry&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;行码棋的文章&#125;  <span class="comment">% 文章标题</span></span><br><span class="line"><span class="keyword">\author</span>&#123;行码棋&#125;   <span class="comment">% 作者的名称</span></span><br><span class="line"><span class="keyword">\date</span>&#123;<span class="keyword">\today</span>&#125;       <span class="comment">% 当天日期</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 正文开始</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\maketitle</span>          <span class="comment">% 添加这一句才能够显示标题等信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 正文结束</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="3-摘要"><a href="#3-摘要" class="headerlink" title="3 摘要"></a>3 摘要</h2><p>在<code>\maketitle</code>下添加内容</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\maketitle</span>          <span class="comment">%添加这一句才能够显示标题等信息</span></span><br><span class="line"><span class="comment">%摘要开始部分</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;abstract&#125;</span><br><span class="line">该部分内容是放置摘要信息的。该部分内容是放置摘要信息的。该部分内容是放置摘要信息的。该部分内容是放置摘要信息的。该部分内容是放置摘要信息的。</span><br><span class="line"><span class="keyword">\end</span>&#123;abstract&#125;</span><br></pre></td></tr></table></figure><h2 id="4-引用、脚注"><a href="#4-引用、脚注" class="headerlink" title="4 引用、脚注"></a>4 引用、脚注</h2><ul><li>引用：写在<code>\begin&#123;quote&#125;</code>和<code>\end&#123;quote&#125;</code>之间</li></ul><h3 id="4-1-公式引用"><a href="#4-1-公式引用" class="headerlink" title="4.1 公式引用"></a>4.1 公式引用</h3><p>需导入<code>amsmath</code>宏包，代码为<code>\usepackage&#123;amsmath&#125;</code></p><p>公式：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">z = x + y</span><br><span class="line"><span class="keyword">\label</span>&#123;eq1&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><p>公式引用：</p><p>引用时只显示数字</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">Eq. (<span class="keyword">\ref</span>&#123;eq1&#125;)</span><br><span class="line"><span class="comment">% 或导入amsmath宏包，使用如下代码（推荐）：</span></span><br><span class="line">Eq. <span class="keyword">\eqref</span>&#123;eq1&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-图片引用"><a href="#4-2-图片引用" class="headerlink" title="4.2 图片引用"></a>4.2 图片引用</h3><p>图片显示：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp] <span class="comment">% htbp代表图片插入位置的设置</span></span><br><span class="line"><span class="keyword">\centering</span> <span class="comment">%图片居中</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[width=6cm]&#123;1.jpg&#125;</span><br><span class="line"><span class="keyword">\caption</span>&#123;这是一个图片标题&#125; <span class="comment">% 图片标题</span></span><br><span class="line"><span class="keyword">\label</span>&#123;pic&#125; <span class="comment">% 图片标签</span></span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><p>引用：<code>pic</code>是图片的label</p><p>引用时只显示数字</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ref</span>&#123;pic&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-参考文献引用"><a href="#4-3-参考文献引用" class="headerlink" title="4.3 参考文献引用"></a>4.3 参考文献引用</h3><p>下面的代码在文中使用，用于标注引用了哪篇文献</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\cite</span>&#123;b1&#125;</span><br><span class="line"><span class="keyword">\cite</span>&#123;b2&#125;</span><br><span class="line"><span class="keyword">\cite</span>&#123;b3&#125;</span><br></pre></td></tr></table></figure><p>下面代码一般在文末使用，会列举自己使用的参考文献</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;00&#125;</span><br><span class="line"><span class="keyword">\bibitem</span>&#123;b1&#125; Ben-Othman J, Yahya B. Energy efficient and QoS based routing protocol for wireless sensor networks. J Parallel Distrib Comput 2010;2010(70):849–57.</span><br><span class="line"><span class="keyword">\bibitem</span>&#123;b2&#125; Younis M, Youssef M, Arisha K. Energy-aware routing in cluster-based sensor networks. In: Proceedings of the IEEE 20th international symposium on modeling, analysis and simulation of computer and telecommunication systems; 2012. p. 0129. https://doi.org/10.1109/MASCOT.2002.1167069.</span><br><span class="line"><span class="keyword">\bibitem</span>&#123;b3&#125; Al-Karaki JN, Kamal AE. Routing techniques in wireless sensor networks: a survey. IEEE J Wirel Commun 2004;11(6):6–28. 2004.</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-脚注"><a href="#4-4-脚注" class="headerlink" title="4.4 脚注"></a>4.4 脚注</h3><p>脚注：在需要添加脚注的文字后添加<code>\footnote&#123;脚注内容&#125;</code>即可，会自动标序号，并将<code>脚注内容</code>填上去</p><h2 id="5-目录"><a href="#5-目录" class="headerlink" title="5 目录"></a>5 目录</h2><p>在<code>\begin&#123;document&#125;</code>内容中添加：<code>\tableofcontents</code></p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 生成目录设置</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\contentsname</span>&#125;&#123;目录&#125; <span class="comment">%将content转为目录,生成目录二字</span></span><br><span class="line"><span class="keyword">\tableofcontents</span></span><br></pre></td></tr></table></figure><h2 id="6-字体、大小与颜色"><a href="#6-字体、大小与颜色" class="headerlink" title="6 字体、大小与颜色"></a>6 字体、大小与颜色</h2><ul><li>字体</li></ul><p>使用<code>&#123;\字体 内容&#125;</code>（推荐此种），也可使用<code>\字体 &#123;内容&#125;</code></p><p>示例：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">\songti</span> 宋体&#125;</span><br><span class="line">&#123;<span class="keyword">\heiti</span> 黑体&#125;</span><br><span class="line">&#123;<span class="keyword">\fangsong</span> 仿宋&#125;</span><br><span class="line">&#123;<span class="keyword">\kaishu</span> 楷书&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="keyword">\bf</span> 粗体&#125;</span><br><span class="line">&#123;<span class="keyword">\it</span> 斜体&#125;</span><br><span class="line">&#123;<span class="keyword">\sl</span> 斜体&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\textbf</span>&#123;粗体&#125;</span><br><span class="line"><span class="keyword">\textit</span>&#123;斜体&#125;</span><br><span class="line"><span class="keyword">\textsl</span>&#123;斜体&#125;</span><br></pre></td></tr></table></figure><ul><li>大小</li></ul><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">&#123;<span class="keyword">\tiny</span> Hello&#125; <span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\scriptsize</span> Hello&#125; <span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\footnotesize</span> Hello&#125; <span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\small</span> Hello&#125; <span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\normalsize</span> Hello&#125; <span class="keyword">\\</span></span><br><span class="line">&#123;<span class="keyword">\large</span> Hello&#125; <span class="keyword">\\</span></span><br></pre></td></tr></table></figure><ul><li>颜色</li></ul><p>需要导入宏包<code>\usepackage&#123;xcolor&#125;</code></p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>[UTF8]&#123;ctex&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;color,xcolor&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\setlength</span>&#123;<span class="keyword">\parindent</span>&#125;&#123;0pt&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 预先定义好的颜色： red, green, blue, white, black, yellow, gray, darkgray, lightgray, brown, cyan, lime, magenta, olive, orange, pink, purple, teal, violet.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义颜色的5种方式</span></span><br><span class="line"><span class="keyword">\definecolor</span>&#123;light-gray&#125;&#123;gray&#125;&#123;0.95&#125;    <span class="comment">% 1.灰度</span></span><br><span class="line"><span class="keyword">\definecolor</span>&#123;orange&#125;&#123;rgb&#125;&#123;1,0.5,0&#125;      <span class="comment">% 2.rgb</span></span><br><span class="line"><span class="keyword">\definecolor</span>&#123;orange&#125;&#123;RGB&#125;&#123;255,127,0&#125;    <span class="comment">% 3.RGB</span></span><br><span class="line"><span class="keyword">\definecolor</span>&#123;orange&#125;&#123;HTML&#125;&#123;FF7F00&#125;      <span class="comment">% 4.HTML</span></span><br><span class="line"><span class="keyword">\definecolor</span>&#123;orange&#125;&#123;cmyk&#125;&#123;0,0.5,1,0&#125;   <span class="comment">% 5.cmyk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% \pagecolor&#123;yellow&#125;          %设置背景色为黄色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用颜色的常用方式</span></span><br><span class="line"><span class="keyword">\textcolor</span>&#123;green&#125;&#123;绿色&#125; <span class="comment">% textcolor+颜色</span></span><br><span class="line"><span class="keyword">\color</span>&#123;orange&#125;&#123;橙色&#125; <span class="comment">% color+颜色</span></span><br><span class="line"><span class="keyword">\textcolor</span>[rgb]&#123;0,1,0&#125;&#123;绿色&#125; <span class="comment">% textcolor+rgb</span></span><br><span class="line"><span class="keyword">\color</span>[rgb]&#123;1,0,0&#125;&#123;红色&#125; <span class="comment">% color+rgb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用底色</span></span><br><span class="line"><span class="keyword">\colorbox</span>&#123;red&#125;&#123;<span class="keyword">\color</span>&#123;black&#125;红底黑字&#125;</span><br><span class="line"><span class="keyword">\fcolorbox</span>&#123;red&#125;&#123;green&#125;&#123;红框绿底&#125; <span class="comment">% 框色+背景色</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125; </span><br></pre></td></tr></table></figure><h2 id="7-链接"><a href="#7-链接" class="headerlink" title="7 链接"></a>7 链接</h2><p>导入宏包：<code>\usepackage&#123;url&#125;</code><br>插入超链接：<code>\url&#123;www.baidu.com&#125;</code></p><h2 id="8-图片"><a href="#8-图片" class="headerlink" title="8 图片"></a>8 图片</h2><p>需要导入宏包：<code>\usepackage&#123;graphicx&#125;</code></p><ul><li>单张图片</li></ul><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%开始插入图片</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp] <span class="comment">% htbp代表图片插入位置的设置</span></span><br><span class="line"><span class="keyword">\centering</span> <span class="comment">%图片居中</span></span><br><span class="line"><span class="comment">%添加图片；[]中为可选参数，可以设置图片的宽高；&#123;&#125;中为图片的相对位置</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[width=6cm]&#123;image.jpg&#125;</span><br><span class="line"><span class="keyword">\caption</span>&#123;这是一个图片标题&#125; <span class="comment">% 图片标题</span></span><br><span class="line"><span class="keyword">\label</span>&#123;pic1&#125; <span class="comment">% 图片标签</span></span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>[htbp]</code>是可选参数，允许用户指定图片、表格等元素被放置的位置。这一可选参数项可以是下列字母的任意组合。</p><p><code>h(here)</code>: 当前位置；将图形放置在 正文文本中给出该图形环境的地方。如果本页所剩的页面不够， 这一参数将不起作用。</p><p><code>t(top)</code>: 顶部；将图形放置在页面的顶部。</p><p><code>b(bottom)</code>: 底部；将图形放置在页面的底部。</p><p><code>p(page)</code>: 浮动页；将图形放置在一只允许有浮动对象的页面上。</p><p>注：</p><ul><li>如果在图形环境中没有给出上述任一参数，则缺省为<code>[tbp]</code></li><li>给出参数的顺序不会影响到最后的结果。因为在考虑这些参数时LaTeX总是尝试以<code>h-t-b-p</code> 的顺序来确定图形的位置。所以<code>[hb]</code>和<code>[bh]</code>都以<code>h-b</code>的顺序来排版</li><li>给出的参数越多，LaTeX的排版结果就会越好。<code>[htbp]</code>， <code>[tbp]</code>， <code>[htp]</code>， <code>[tp]</code> 这些组合得到的效果不错，<code>[h]</code>也是常用的选择。</li></ul></blockquote><ul><li>并排插入多张图片</li></ul><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;</span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line">&#123;<span class="keyword">\includegraphics</span>[width=2.5cm]&#123;1.jpg&#125;&#125;</span><br><span class="line"><span class="keyword">\hspace</span>&#123;10pt&#125;    <span class="comment">%每张图片水平距离</span></span><br><span class="line">&#123;<span class="keyword">\includegraphics</span>[width=2.5cm]&#123;1.jpg&#125;&#125;</span><br><span class="line"><span class="keyword">\hspace</span>&#123;10pt&#125;</span><br><span class="line">&#123;<span class="keyword">\includegraphics</span>[width=2.5cm]&#123;1.jpg&#125;&#125;</span><br><span class="line"><span class="keyword">\hspace</span>&#123;10pt&#125;</span><br><span class="line">&#123;<span class="keyword">\includegraphics</span>[width=2.5cm]&#123;1.jpg&#125;&#125;</span><br><span class="line"><span class="keyword">\hspace</span>&#123;10pt&#125;</span><br><span class="line"><span class="keyword">\caption</span>&#123;并排插入4张图片&#125; <span class="comment">%图片标题</span></span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><ul><li>竖排插入多张图片</li></ul><h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9 表格"></a>9 表格</h2><p>在线生成Latex表格：<a href="https://www.tablesgenerator.com/">https://www.tablesgenerator.com/</a></p><h2 id="10-数学公式"><a href="#10-数学公式" class="headerlink" title="10 数学公式"></a>10 数学公式</h2><p>公式编写类似Katex，不再详细讲述，文档请参考： <a href="https://katex.org/docs/supported.html">https://katex.org/docs/supported.html</a></p><ul><li>公式自动编号</li></ul><p>使用<code>\begin&#123;equation&#125;</code>和<code>\end&#123;equation&#125;</code>进行公式输入，要同时使用，且编号不能够修改。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">a<span class="built_in">^</span>2+b<span class="built_in">^</span>2=c<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><ul><li>公式手动编号</li></ul><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">a<span class="built_in">^</span>2 + b<span class="built_in">^</span>2 = c<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\tag</span>&#123;2&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><h2 id="11-代码"><a href="#11-代码" class="headerlink" title="11 代码"></a>11 代码</h2><ul><li>算法伪代码</li></ul><p>需要使用<code>\usepackage&#123;algorithm&#125;</code>和<code>\usepackage&#123;algorithmic&#125;</code>宏包，<code>if</code>、<code>for</code>等关键字要按照规范书写，如<code>\IF \ENDIF</code>。</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>[UTF8]&#123;ctex&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;algorithm&#125; <span class="comment">% 排版算法</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;algorithmic&#125; <span class="comment">% 排版算法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\title</span>&#123;Algorithm&#125;</span><br><span class="line"><span class="keyword">\author</span>&#123;NSJim Green&#125;</span><br><span class="line"><span class="keyword">\date</span>&#123;October 2020&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\maketitle</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;Algorithm 1&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\caption</span>&#123;CheckSum(A,x)&#125; <span class="comment">%算法标题</span></span><br><span class="line"><span class="keyword">\label</span>&#123;alg2&#125; <span class="comment">%标签</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithmic&#125; <span class="comment">%算法开始</span></span><br><span class="line"><span class="keyword">\STATE</span> &#123;<span class="keyword">\bf</span> Input:&#125; An array A and a value x  <span class="comment">%也可以用\textbf&#123;Input:&#125;</span></span><br><span class="line"><span class="keyword">\STATE</span> &#123;<span class="keyword">\bf</span> Output:&#125; A bool value show if there is two elements in A whose sum is x</span><br><span class="line"><span class="keyword">\STATE</span> A <span class="built_in">$</span><span class="keyword">\gets</span><span class="built_in">$</span> SORT(A)</span><br><span class="line"><span class="keyword">\STATE</span> n <span class="built_in">$</span><span class="keyword">\gets</span><span class="built_in">$</span> length(n)</span><br><span class="line"><span class="keyword">\FOR</span>&#123;i <span class="built_in">$</span><span class="keyword">\gets</span><span class="built_in">$</span> 0 to n&#125;</span><br><span class="line">    <span class="keyword">\IF</span>&#123;Binary-search(A,x-A[i],1,n)&#125;</span><br><span class="line">    <span class="keyword">\STATE</span> return true</span><br><span class="line">    <span class="keyword">\ENDIF</span></span><br><span class="line"><span class="keyword">\ENDFOR</span></span><br><span class="line"><span class="keyword">\STATE</span> return false</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><ul><li>代码块</li></ul><p>使用<code>\usepackage&#123;listings&#125;</code>宏包，并使用<code>\lstset&#123;&#125;</code>进行基础设置，然后使用<code>\begin&#123;lstlisting&#125;[language=xxx]</code>和<code>\end&#123;lstlisting&#125;</code>插入代码块。</p><p>基础设置包括行号，不显示字符串空格，代码块边框，不包含颜色等设置，要设置颜色和字体请见下文的高级用法。</p><p>进行代码基础设置：（写在导言区）</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 代码块基础设置</span></span><br><span class="line"><span class="keyword">\lstset</span>&#123;</span><br><span class="line">breaklines, <span class="comment">% 代码自动换行</span></span><br><span class="line">numbers=left,  <span class="comment">% 在左侧显示行号</span></span><br><span class="line">showstringspaces=false,  <span class="comment">% 不显示字符串中的空格</span></span><br><span class="line">frame=single,  <span class="comment">% 设置代码块边框</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他代码设置：</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 代码块高级设置</span></span><br><span class="line"><span class="keyword">\lstset</span>&#123;</span><br><span class="line"><span class="comment">% basicstyle=\footnotesize,                 % 设置整体的字体大小</span></span><br><span class="line">showstringspaces=false,                     <span class="comment">% 不显示字符串中的空格</span></span><br><span class="line">frame=single,                               <span class="comment">% 设置代码块边框</span></span><br><span class="line">numbers=left,                               <span class="comment">% 在左侧显示行号</span></span><br><span class="line"><span class="comment">% numberstyle=\footnotesize\color&#123;gray&#125;,    % 设置行号格式</span></span><br><span class="line">numberstyle=<span class="keyword">\color</span>&#123;darkgray&#125;,               <span class="comment">% 设置行号格式</span></span><br><span class="line">backgroundcolor=<span class="keyword">\color</span>&#123;white&#125;,              <span class="comment">% 设置背景颜色</span></span><br><span class="line">keywordstyle=<span class="keyword">\color</span>&#123;blue&#125;,                  <span class="comment">% 设置关键字颜色</span></span><br><span class="line">commentstyle=<span class="keyword">\it</span><span class="keyword">\color</span>[RGB]&#123;0,100,0&#125;,       <span class="comment">% 设置代码注释的格式</span></span><br><span class="line">stringstyle=<span class="keyword">\sl</span><span class="keyword">\color</span>&#123;red&#125;,                 <span class="comment">% 设置字符串格式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书写代码：（写在正文区）</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;lstlisting&#125;[language=c]</span><br><span class="line"><span class="params">#</span>include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// main function</span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Hello World!&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;lstlisting&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文档编写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习总结 </tag>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合数学常用公式</title>
      <link href="/p/3821341893.html"/>
      <url>/p/3821341893.html</url>
      
        <content type="html"><![CDATA[<h1 id="组合数学常用公式"><a href="#组合数学常用公式" class="headerlink" title="组合数学常用公式"></a>组合数学常用公式</h1><h2 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h2><p>二项式系数相关性质：</p><ul><li><p>对称性：$C_n^m &#x3D; C_n^{n-m}$</p></li><li><p>增减性与最大值：二项式系数前半部分逐渐增大，后半部分逐渐减小，中间取最大值。<br>$$<br>\text{最大值} max&#x3D;\begin{cases} C_n^{\frac{n}{2}} \ C_n^{\frac{n-1}{2}}&#x3D;C_n^{\frac{n+1}{2}}\end{cases}<br>$$</p></li><li><p>二项式系数之和<br>$$<br>C_n^0+C_n^1+C_n^2+C_n^3+…+C_n^{n-1}+C_n^n&#x3D;2^n<br>$$</p></li><li><p>二项式奇数项系数之和等于偶数项系数之和，即<br>$$<br>C_n^1+C_n^3+C_n^5+…&#x3D;C_n^0+C_n^2+C_n^4+C_n^6+…&#x3D;2^{n-1}<br>$$</p></li></ul><h3 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h3><p><img src="https://porschan.github.io/2019/06/06/algorithm-yanghui/1.png" alt="杨辉三角"></p><h2 id="组合数公式"><a href="#组合数公式" class="headerlink" title="组合数公式"></a>组合数公式</h2><p>$C_n^m$计算</p><ul><li>方式一：公式计算<br>计算都是在逆元或者阶乘基础上计算的</li></ul><p>$$<br>C_n^m &#x3D; \frac{n!}{m!*(n-m)!}<br>$$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n] * invfac[m] % mod * invfac[n - m] % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二：递推方式<br>需要建表，所以如果计算范围比较大时需要的空间也大<br>递推公式 ：</li></ul><p>$$<br>C_n^m &#x3D; C_{n-1}^{m} + C_{n-1}^{m-1}<br>$$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == j || j == <span class="number">0</span>) c[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + c[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排列组合方法"><a href="#排列组合方法" class="headerlink" title="排列组合方法"></a>排列组合方法</h2><h3 id="1-隔板法"><a href="#1-隔板法" class="headerlink" title="1. 隔板法"></a>1. 隔板法</h3><blockquote><p>引入： 10 个<strong>相同</strong>小球放进 3 个<strong>不同</strong>盒子，每个盒子至少放进一个， 求种类数。</p><p>在10 个小球中间插入隔板， 共有 $10-1&#x3D;9$ 个位置， 需要插入 $3-1&#x3D;2$ 个隔板将其分成 3 部分。 共 $C_9^2 &#x3D; 36$ 种。</p></blockquote><ul><li>一般隔板法：</li></ul><p>将 $n$ 个相同的元素分成 $k$ 部分，每部分至少分得一个元素， 即在 $n-1$ 个空隙中插入 $k-1$ 个隔板，情况数为<br>$$<br>C_{n-1}^{k-1}<br>$$<br>等价于 $x_1+ x_2+x_3+…+x_k&#x3D;n, x_i \geq 1$ 的可行解个数。</p><ul><li>添元素隔板法：</li></ul><p>将 $n$ 个相同的元素分成 $k$ 部分，每部分可以为空， 等价于我们先让元素个数添加上 $k$ 个，然后在 $n+k$ 个元素中分成 $k$ 部分， 最后再在 $k$ 部分的每一个部分都拿走一个元素，共拿走 $k$ 个元素。 即在 $n+k-1$ 个空隙中插入 $k-1$ 个隔板，情况数为<br>$$<br>C_{n+k-1}^{k-1}<br>$$<br>等价于 $x_1+ x_2+x_3+…+x_k&#x3D;n, x_i \geq 0$ 的可行解个数。</p><blockquote><p>此时该式可以转化为一般隔板法， 我们让 $x_i \geq 1$ 即可，操作是将每一个 $x_i$ 元素加上 $1$ ，相当于等式两边同时加了 $k$ ，即 $x_1+x_2+…+x_k&#x3D;n+k,x_i \geq 1$ ，即可转化为一般隔板法。</p></blockquote><ul><li>隔板法应用</li></ul><p>把10个相同的小球放到3个不同的箱子，第一个箱子至少1个，第二个箱子至少3个，第3个箱子可以为</p><p>空，有几种情况？</p><blockquote><p>我们可以在第二个箱子先放入10个小球中的2个，小球剩8个放3个箱子，然后在第三个箱子放入8</p><p>个小球之外的1个小球（即补充了一个球），则问题转化为把9个相同小球放3不同箱子，每箱至</p><p>少1个，几种方法？ </p><p>$C^2_8&#x3D;28$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《动手学深度学习》笔记</title>
      <link href="/p/1060509989.html"/>
      <url>/p/1060509989.html</url>
      
        <content type="html"><![CDATA[<blockquote><p> 本笔记主要参考<a href="https://zh-v2.d2l.ai/index.html">《动手学深度学习》</a> 进行学习记录，不做无意义的书本内容摘抄。</p><p>课程网址：<a href="https://courses.d2l.ai/zh-v2/">https://courses.d2l.ai/zh-v2/</a></p><p>使用深度学习框架为：Pytorch</p></blockquote><p>内容不断更新中$\cdots \cdots$</p><h1 id="2-预备知识"><a href="#2-预备知识" class="headerlink" title="2 预备知识"></a>2 预备知识</h1><h2 id="2-1-数据处理"><a href="#2-1-数据处理" class="headerlink" title="2.1 数据处理"></a>2.1 数据处理</h2><h2 id="2-2-线性代数"><a href="#2-2-线性代数" class="headerlink" title="2.2 线性代数"></a>2.2 线性代数</h2><p>矩阵运算：矩阵点积、向量积、矩阵乘法</p><blockquote><p>向量积非叉积，是矩阵与向量的积。下例可以看做$A$的行向量和向量的点积。<br>$$<br>A &#x3D;<br>\begin{pmatrix}<br>a_{11} &amp; \cdots &amp; a_{1m} \<br>a_{21} &amp; \cdots &amp; a_{2m} \<br>\vdots &amp; \ddots &amp; \vdots \<br>a_{n1} &amp; \cdots &amp; a_{nm}<br>\end{pmatrix} ,<br>\overrightarrow x &#x3D;<br>\begin{pmatrix}<br>x_1 \<br>\vdots \<br>x_m<br>\end{pmatrix}<br>\<br>A\overrightarrow x &#x3D;<br>\begin{pmatrix}<br>a_{11}x_1 + \cdots + a_{1m}x_m \<br>\vdots \<br>a_{n1}x_1 + \cdots + a_{nm}x_m<br>\end{pmatrix}<br>$$</p></blockquote><p>范数：</p><p>$L_1$范数是向量绝对值之和。<br>$$<br>|\mathbf{x}|<em>1 &#x3D; \sum</em>{i&#x3D;1}^n \left|x_i \right|.<br>$$<br>$L_2$范数是向量元素根的平方和。<br>$$<br>|\mathbf{x}|<em>2 &#x3D; \sqrt{\sum</em>{i&#x3D;1}^n x_i^2},<br>$$<br>$L_p$范数是更一般的范数，公式如下：<br>$$<br>|\mathbf{x}|<em>p &#x3D; \left(\sum</em>{i&#x3D;1}^n \left|x_i \right|^p \right)^{1&#x2F;p}.<br>$$</p><h2 id="2-3-微积分"><a href="#2-3-微积分" class="headerlink" title="2.3 微积分"></a>2.3 微积分</h2><h1 id="3-线性神经网络"><a href="#3-线性神经网络" class="headerlink" title="3 线性神经网络"></a>3 线性神经网络</h1><h2 id="3-1-线性回归"><a href="#3-1-线性回归" class="headerlink" title="3.1 线性回归"></a>3.1 线性回归</h2><h2 id="3-2-Softmax回归"><a href="#3-2-Softmax回归" class="headerlink" title="3.2 Softmax回归"></a>3.2 Softmax回归</h2><p>输出的匹配概率（非负，和为1）<br>$$<br>\hat{\mathbf{y}} &#x3D; \mathrm{softmax}(\mathbf{o})\quad \text{其中}\quad \hat{y}_j &#x3D; \frac{\exp(o_j)}{\sum_k \exp(o_k)}<br>$$<br>我们选择最优可能的类别<br>$$<br>\mathop {argmax}_j \hat y_j &#x3D; \mathop {argmax}<em>j o_j.<br>$$<br>损失函数，下式通常称为<strong>交叉熵损失</strong>。（真实概率中只有一个$y_i$为1，其余全部为0）<br>$$<br>l(\mathbf{y}, \hat{\mathbf{y}}) &#x3D; - \sum</em>{j&#x3D;1}^q y_j \log \hat{y}_j.<br>$$</p><blockquote><p>交叉熵通常来衡量两个概率的区别：<br>$$<br>H(p, q) &#x3D; \sum \limits_i - p_i log(q_i)<br>$$</p></blockquote><p>损失函数的导数<br>$$<br>\partial_{o_j} l(\mathbf{y}, \hat{\mathbf{y}}) &#x3D; \frac{\exp(o_j)}{\sum_{k&#x3D;1}^q \exp(o_k)} - y_j &#x3D; \mathrm{softmax}(\mathbf{o})_j - y_j.<br>$$</p><h2 id="3-3-损失函数"><a href="#3-3-损失函数" class="headerlink" title="3.3 损失函数"></a>3.3 损失函数</h2><ul><li>均方损失（L2 Loss）</li></ul><p>$$<br>l(y, y{‘}) &#x3D;\frac{1}{2}(y - y{‘})^2<br>$$</p><ul><li>绝对值损失（L1 Loss）</li></ul><p>$$<br>l(y,y{‘}) &#x3D; |y - y{‘}|<br>$$</p><ul><li>Huber’s Robust Loss 鲁棒损失</li></ul><p>$$<br>l(y, y{‘}) &#x3D;<br>\begin{cases}<br>|y - y{‘}| &amp; if |y - y{‘}| \gt 1 \<br>\frac{1}{2}(y - y{‘})^2 &amp; otherwise<br>\end{cases}<br>$$</p><h1 id="4-多层感知机"><a href="#4-多层感知机" class="headerlink" title="4 多层感知机"></a>4 多层感知机</h1><h2 id="4-1-多层感知机"><a href="#4-1-多层感知机" class="headerlink" title="4.1 多层感知机"></a>4.1 多层感知机</h2><p>单层感知机：</p><ul><li>回归输出实数</li><li>解决二分类问题</li></ul><p>单层感知机函数，$\sigma$是激活函数<br>$$<br>o &#x3D; \sigma (\langle \mathbf{w} , \mathbf{x} \rangle + b )<br>$$<br>多层感知机：</p><ul><li><p>激活函数需要是非线性：如果为线性的话，输出就仍然是线性的，等价于单层感知机</p></li><li><p>使用隐藏层和激活函数来得到非线性模型</p></li><li><p>使用Softmax来处理多分类</p></li><li><p>超参数为隐藏层数和各个隐藏层大小</p></li></ul><p>单隐藏层：<br>$$<br>\mathbf{h} &#x3D; \mathbf{W_1X+b_1} \<br>o &#x3D; \mathbf{w_2^T h } + b_2<br>$$</p><p>激活函数：</p><ul><li>sigmoid函数，将输出投影到$(0, 1)$</li></ul><p>$$<br>sigmoid(x) &#x3D; \frac{1}{1 + e ^{-x}}<br>$$</p><ul><li>Tanh函数，将输出投影到$(-1, 1)$</li></ul><p>$$<br>tanh(x) &#x3D; \frac{1 - e^{-2x}}{1 + e ^ {-2x}}<br>$$</p><ul><li>ReLU激活函数</li></ul><p>$$<br>ReLU(x) &#x3D; max(x, 0)<br>$$</p><h2 id="4-2-模型选择"><a href="#4-2-模型选择" class="headerlink" title="4.2 模型选择"></a>4.2 模型选择</h2><p>训练误差：模型在训练数据集上得到的误差</p><p>泛化误差：模型在新数据集上得到的误差</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习总结 </tag>
            
            <tag> DeepLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年度总结</title>
      <link href="/p/1646942053.html"/>
      <url>/p/1646942053.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>希望2023健康，发论文，比赛拿牌，成功上岸。</p></blockquote><p>今天是2023年1月1日，2022有许多不顺心的事，也有一些值得记忆的事，希望通过下面的片段来回顾这年不易的时光。</p><blockquote><p>能说的尽量说，不能说的你我心领神会。我发现时间让我越来越不想说什么东西了，想说的基本都不能说，现实陈述基本是完全禁止的，当下的环境就让人容易窒息。</p></blockquote><p>我想还是多记录一下2022年的生活状态吧。</p><p>转眼一看，过的好快啊，转眼间就大三了，大学不知不觉在校内和家里过了三年之久。</p><h1 id="学期片刻"><a href="#学期片刻" class="headerlink" title="学期片刻"></a>学期片刻</h1><h2 id="大二下"><a href="#大二下" class="headerlink" title="大二下"></a>大二下</h2><p>大二上的考试依然是提前的，没有复习周，三年了，考试要么是提前考试，要么是在家线上考试。</p><p>大二下是我计协会长的最后半年，开学是第一次正常开学，前面疫情形势大好，活动遥遥在望。可是近邻活动举办之时（也才过了一两周），疫情形势急转直下，整个学校又是一片封控之态。</p><p>哎，整个会长的任期间完全废掉了：</p><ul><li>院赛没法办，学校不让办（疫情影响）</li><li>活动全线上</li><li>活动少之又少，线上根本难以办起有效活动</li></ul><p>这学期应该就参加了个蓝桥杯，实验室里参加的，题呢难死了，可最终省一还是没想到的，但是国赛在考试期间比就很拉跨了，那时候代码没敲基本一个月了，加之自身实力太菜，根本难以应对，故以国优落幕。</p><p>XCPC省赛也没了，CCPC在学期后半段时间一改再改，因为教育厅通知6月初之前全部离校，传的很广了。校内甚至还出现了几次集体性聚集事件（我没有参加，只是听说），回家的这件事那么就理所当然的确定了。</p><p>关于期末考试呢，学生闹之又闹，考试口头通知改之又改，最后定于回家之后延期数十天线上进行，所幸本次考试我没有过于拉跨。</p><h2 id="大三上"><a href="#大三上" class="headerlink" title="大三上"></a>大三上</h2><p>又一次推迟开学，21和22届军训都没有进行，真有你的！</p><p>辛亏CCPC省赛在前期抓紧办了，所幸拿金。</p><p>好啦，这回前面基本上了5周以内的线下课呀，后面就完全封控了，封在寝室里面的。</p><p>线上，封寝，做核酸等等，那么上课呢肯定不会好好上的，基本是无听状态，因为大二下假期后期入了原神，封寝室是有事可做的，要么玩，要么刷b站，前期刷题还坚持了一段，后面就很难进行下去了。期间时不时搞一些零碎的技术活（维护QQ机器人、维护博客网站、维护vj等）。</p><p>那么XCPC区域赛都是没法打的，只能单挑了，基本整个学校的比赛都是拉跨的。</p><p>毫无疑问，这次又是提前放假回家了，学校遣返，疫情形势很难控制住了（还未放开，各地瞒况皆有），考试呢从线上提前考试又改为了下学期线下考试（这时候基本就是大放开阶段了）。</p><p>这个时期的社会事件真的是多之又多，fsk，zz，xj，bz运动等等，惊叹之后便保持沉默。</p><h1 id="专项行动"><a href="#专项行动" class="headerlink" title="专项行动"></a>专项行动</h1><h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><p>今年的比赛完全是拉跨的，大三上多好的比赛机会，都被疫情带走了。</p><p>所幸还留有一丝希望：</p><p>CCPC省赛拿金，CCPC广州站拿银（zsy tql）</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>今年QQ机器人继续完善，现在基本不怎么关注了，后续应该还会再次启动，准备软著。</p><p>新建vj平台，虽然是copy的，因为自身水平受限，还是废了一番功夫。</p><p>拿下新域名，新建博客网站，目前已经运行半年之久。</p><p>django和app开发都有所了解，github初步使用</p><p>买了代理，不再受限于那堵墙。</p><p>给出3张图纪念一下：</p><p><img src="/1646942053/image-20230101121342445.png" alt="CF"></p><p><img src="/1646942053/image-20230101121415331.png" alt="Github"></p><p><img src="/1646942053/image-20230101121441216.png" alt="本站博客"></p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>我发现，我心态不再是像之前那样乐观了，现在似乎是<code>面对可能发生之事保持谨慎，面对未知之事保持关注</code>这样的态度了，我对许多东西已不报希望，这样的环境只能说尽量存活下去吧。</p><p>越来越寡言少语，越来越艰难。2023希望好过些吧，毕竟放开了，比赛能线下了，大学生活或许会改变，但是之前的时间浪费是弄不回来了。</p>]]></content>
      
      
      <categories>
          
          <category> 哲思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阶段性总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习常见算法总结</title>
      <link href="/p/808139430.html"/>
      <url>/p/808139430.html</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习环境搭建"><a href="#机器学习环境搭建" class="headerlink" title="机器学习环境搭建"></a>机器学习环境搭建</h1><ul><li><p>一般使用anaconda搭建python虚拟环境（miniconda占的空间应该小一点，这个也可以）</p></li><li><p>使用工具库一般有科学计算库numpy，数据处理库pandas，绘图matplotlib等，需要了解相关用法</p></li><li><p>……</p></li></ul><h1 id="线性回归-Linear-Regression"><a href="#线性回归-Linear-Regression" class="headerlink" title="线性回归 Linear Regression"></a>线性回归 Linear Regression</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>线性回归类似高中的<strong>线性规划</strong>题目。线性回归要做的是就是找到一个数学公式能相对较完美地把所有自变量组合（加减乘除）起来，得到的结果和目标接近。</p><p>线性回归分为一元线性回归和多元线性回归。</p><h2 id="2-一元线性回归"><a href="#2-一元线性回归" class="headerlink" title="2 一元线性回归"></a>2 一元线性回归</h2><h3 id="2-1-构造回归方程"><a href="#2-1-构造回归方程" class="headerlink" title="2.1 构造回归方程"></a>2.1 构造回归方程</h3><p>有n组数据，自变量（特征值） $x(x_1,x_2,…,x_n)$ 与因变量（目标值） $y(y_1,y_2,…,y_n)$ ，我们需要找到一个线性关系，使他们之间尽可能满足： $f(x) &#x3D;ax+b$ ，这个就是构建的一元线性方程。</p><p><img src="/808139430/1.jpg" alt="一元线性回归"></p><p>线性回归的目标就是让 $f(X)$ 与 $y$ 之间的差距最小，也就是权重$a$和偏置$b$取什么值的时候$f(X)$和$y$最接近。</p><h3 id="2-2-构造损失函数"><a href="#2-2-构造损失函数" class="headerlink" title="2.2 构造损失函数"></a>2.2 构造损失函数</h3><p>损失函数是来度量模型预测值与真实值不一样的程度的，或者说度量预测错误的程度，损失函数值越小，模型就越好。</p><p>在回归问题中，误差平方和是回归任务中最常用的性能度量。这里就可以令损失函数$L(a,b)$等于误差平方和（均方误差）。</p><p>则损失函数为: $L(a, b) &#x3D; \sum \limits_{i &#x3D; 1}^{n}(f(x_i) - y_i)^2$</p><h3 id="2-3-确定参数"><a href="#2-3-确定参数" class="headerlink" title="2.3 确定参数"></a>2.3 确定参数</h3><p>我们需要通过最小的损失函数得到最佳的参数 $a$ 和 $b$ 。一般使用<strong>最小二乘法</strong>。<br>$$<br>a &#x3D; \frac{\sum \limits_{i&#x3D;1}^{n}x_iy_i - n \overline x \overline y}{\sum \limits_{i&#x3D;1}^{n}x_i^2 - n \overline x ^ 2}<br>\<br>b &#x3D; \overline y - a \overline x<br>$$</p><h2 id="3-多元线性回归"><a href="#3-多元线性回归" class="headerlink" title="3 多元线性回归"></a>3 多元线性回归</h2><p>多元线性回归类似一元</p><p>回归方程： $y &#x3D; a_1 x_1 + a_2 x_2 + a_3 x_3 + … + a_n x_n + b$</p><p>对所有的数据统一用矩阵形式表示：<br>$$<br>y^{(i)} &#x3D; \theta ^ T x ^ {(i)} + \varepsilon^{(i)} \ (1)<br>$$</p><blockquote><p>$y^{(i)}$表示第<code>i</code>个样本的真实值</p><p>$\varepsilon$ 误差代表真实值和预测值之间的差异</p><p>误差 $\varepsilon ^{(i)}$ 是独立并具有相同的分布，服从均值为 0 方差为 $\theta ^ 2$ 的高斯分布</p></blockquote><p>损失函数<br>$$<br>L(a_1, a_2, …, a_n, b) &#x3D; \sum_{i &#x3D; 1}^{n}(f(x_i) - y_i)^2<br>$$</p><p>高斯分布的概率函数：<br>$$<br>p(x) &#x3D; \frac{1}{\sqrt {2 \pi} \sigma} \exp{(-\frac{x^2}{2 \sigma ^ 2})} \  (2)<br>$$<br>将<code>(1)</code>带入<code>(2)</code>得到<strong>预测值成为真实值的概率</strong>函数：<br>$$<br>p(y ^ {(i)} | x ^ {(i)}; \theta) &#x3D; \frac{1}{\sqrt {2 \pi} \sigma} \exp{(-\frac{(y^{(i)} - \theta ^ T x ^ {(i)})^2}{2 \sigma ^ 2})}<br>$$<br>似然函数：（什么样的参数计算出来的误差最小，即与实际值最接近）<br>$$<br>L(\theta) &#x3D; \prod \limits_{i &#x3D; 1}^{m} p(y ^ {(i)} | x ^ {(i)}; \theta) &#x3D; \prod \limits_{i&#x3D;1}^{m}\frac{1}{\sqrt {2 \pi} \sigma} \exp{(-\frac{(y^{(i)} - \theta ^ T x ^ {(i)})^2}{2 \sigma ^ 2})}<br>$$<br>对数似然法：（将乘法转化为加法），之后需要用极大似然估计方法求解<br>$$<br>ln L(\theta) &#x3D; ln \prod \limits_{i&#x3D;1}^{m}\frac{1}{\sqrt {2 \pi} \sigma} \exp{(-\frac{(y^{(i)} - \theta ^ T x ^ {(i)})^2}{2 \sigma ^ 2})}<br>$$<br>展开化简：<br>$$<br>ln L(\theta) &#x3D; \sum \limits_{i &#x3D; 1}^{m}ln \frac{1}{\sqrt {2 \pi} \sigma} \exp{(-\frac{(y^{(i)} - \theta ^ T x ^ {(i)})^2}{2 \sigma ^ 2})}<br>\<br>&#x3D; mln \frac{1}{\sqrt {2 \pi} \sigma} - \frac{1}{\sigma^2} \frac{1}{2} \sum \limits _{i &#x3D; 1}^{m} (y^{(i)} - \theta ^ T x ^ {(i)})^2<br>$$</p><p>目标：让似然函数越大越好（极大似然估计），即让$J(\theta)$越小越好（可以使用<strong>最小二乘法</strong>求解）<br>$$<br>J(\theta) &#x3D; \frac{1}{2} \sum \limits _{i &#x3D; 1}^{m} (y^{(i)} - \theta ^ T x ^ {(i)})^2<br>$$</p><blockquote><p>其实由损失函数也可以得到同样的式子：</p><h1 id="对于-y-theta-x-b-，-theta-将-b-也吸入进入得到-hat-theta-theta-b-，-X-代表所有的样本数据，最后一个元素置1，最后要和-hat-theta-相乘，最后求偏导也是一样的结果。-L-sum-limits-i-1-n-y-i-f-x-i-2-y-X-hat-theta-T-y-X-hat-theta-X-begin-pmatrix-x-11-x-12-cdots-x-1d-1-x-11-x-12-cdots-x-1d-1-vdots-vdots-ddots-vdots-vdots-x-m1-x-m2-cdots-x-md-1-end-pmatrix"><a href="#对于-y-theta-x-b-，-theta-将-b-也吸入进入得到-hat-theta-theta-b-，-X-代表所有的样本数据，最后一个元素置1，最后要和-hat-theta-相乘，最后求偏导也是一样的结果。-L-sum-limits-i-1-n-y-i-f-x-i-2-y-X-hat-theta-T-y-X-hat-theta-X-begin-pmatrix-x-11-x-12-cdots-x-1d-1-x-11-x-12-cdots-x-1d-1-vdots-vdots-ddots-vdots-vdots-x-m1-x-m2-cdots-x-md-1-end-pmatrix" class="headerlink" title="对于$y &#x3D; \theta x + b$，$\theta$ 将 $b$ 也吸入进入得到 $\hat \theta &#x3D; (\theta, b)$ ，$X$代表所有的样本数据，最后一个元素置1，最后要和 $\hat\theta$ 相乘，最后求偏导也是一样的结果。$$L &#x3D; \sum \limits_{i &#x3D; 1}^n ( y_i - f(x_i)) ^ 2 &#x3D; (y - X \hat\theta)^T(y - X \hat\theta) \X &#x3D;\begin{pmatrix}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d} &amp; 1 \x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d} &amp; 1 \\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{md} &amp; 1\end{pmatrix}"></a>对于$y &#x3D; \theta x + b$，$\theta$ 将 $b$ 也吸入进入得到 $\hat \theta &#x3D; (\theta, b)$ ，$X$代表所有的样本数据，最后一个元素置1，最后要和 $\hat\theta$ 相乘，最后求偏导也是一样的结果。<br>$$<br>L &#x3D; \sum \limits_{i &#x3D; 1}^n ( y_i - f(x_i)) ^ 2 &#x3D; (y - X \hat\theta)^T(y - X \hat\theta) \<br>X &#x3D;<br>\begin{pmatrix}<br>x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d} &amp; 1 \<br>x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d} &amp; 1 \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \<br>x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{md} &amp; 1<br>\end{pmatrix}</h1><p>\begin{pmatrix}<br>x_1^T &amp; 1 \<br>x_2^T &amp; 1 \<br>\vdots &amp; \vdots \<br>x_m^T &amp; 1<br>\end{pmatrix}<br>$$</p></blockquote><p><img src="/808139430/image-20221227173603912.png" alt="最小二乘法分析"></p><blockquote><p>矩阵求导参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/263777564">https://zhuanlan.zhihu.com/p/263777564</a> （先导篇）</li><li><a href="https://zhuanlan.zhihu.com/p/273729929">https://zhuanlan.zhihu.com/p/273729929</a> （公式篇）</li></ul></blockquote><p><img src="/808139430/image-20221227173755095.png" alt="评估方法"></p><h2 id="4-梯度下降"><a href="#4-梯度下降" class="headerlink" title="4 梯度下降"></a>4 梯度下降</h2><p>梯度下降法（gradient descent）是一种常用的一阶（first-order）优化方法。主要解决求最小值问题，其基本思想在于不断地逼近最优点，每一步的优化方向就是梯度的方向。</p><h3 id="4-1-梯度下降方法"><a href="#4-1-梯度下降方法" class="headerlink" title="4.1 梯度下降方法"></a>4.1 梯度下降方法</h3><ul><li>批量梯度下降</li></ul><p>容易得到最优解，但是由于每次考虑<strong>所有样本</strong>，速度很慢。</p><ul><li>随机梯度下降</li></ul><p>每次找一个样本，迭代速度很快，但不一定每次都朝着收敛的方向。</p><ul><li>小批量梯度下降</li></ul><p>每次更新一小部分数据来算，因为在整个训练集上算梯度资源消耗太大，我们可以随机采取$b$个样本$i_1, i_2, \cdots, i_b$来近似损失，$e$是损失函数，$b$是批量大小。<br>$$<br>\frac{1}{b} \sum \limits_{i \in I_b} \mathcal{e}(\mathbf{x_i}, y_i, \mathbf{w})<br>$$</p><h3 id="4-2-其他参数"><a href="#4-2-其他参数" class="headerlink" title="4.2 其他参数"></a>4.2 其他参数</h3><ul><li>学习率：更新的步长</li></ul><p><img src="/808139430/image-20221228161134519.png" alt="学习率的影响"></p><ul><li>批处理数量</li></ul><p>一般<code>batch_size</code>选择32，64，128等，有时候会考虑内存和效率。</p><h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><p>逻辑回归是一个经典的二分类算法。</p><h2 id="1-sigmoid函数"><a href="#1-sigmoid函数" class="headerlink" title="1 sigmoid函数"></a>1 sigmoid函数</h2><p>$$<br>g(z) &#x3D; \frac{1}{1 + e ^ {-z}}, z \in R<br>$$</p><p><img src="/808139430/image-20221228161724190.png" alt="sigmoid函数图像"></p><blockquote><p>将任意的输入映射到了$[0, 1]$区间中，在线性回归中可以得到一个预测值，再将该值映射到sigmoid函数中，这样就可以完成由值到概率的转换，这就是分类任务。</p></blockquote><h2 id="2-逻辑回归求解"><a href="#2-逻辑回归求解" class="headerlink" title="2 逻辑回归求解"></a>2 逻辑回归求解</h2><p>预测函数：<br>$$<br>h_{\theta}(x) &#x3D; g(\theta ^ T x) &#x3D; \frac{1}{1 + e ^ {-\theta^T x}} \<br>其中 \theta_0 + \theta_1 x_1 + … + \theta_n x_n &#x3D; \sum \limits_{i &#x3D; 1}^n \theta_i x_i &#x3D; \theta ^ T x<br>$$<br>分类任务：<br>$$<br>\begin{cases}<br>P(y &#x3D; 1|x; \theta) &#x3D; h_\theta(x) \<br>P(y &#x3D; 0|x; \theta) &#x3D; 1 - h_\theta(x)<br>\end{cases}<br>\Rightarrow<br>P(y | x; \theta) &#x3D; (h_\theta(x)) ^ y (1 - h_\theta(x)) ^ {1 - y}<br>$$<br>对于二分类任务（0， 1），整合后，<code>y</code>取0只保留$(1 - h_\theta(x)) ^ {1 - y}$ ，<code>y</code>取1只保留 $(h_\theta(x)) ^ y$ 。</p><p>似然函数：<br>$$<br>L(\theta) &#x3D; \prod \limits_{i &#x3D; 1}^m P(y_i | x_i; \theta) &#x3D; \prod \limits_{i &#x3D; 1}^m (h_\theta(x_i)) ^ y_i (1 - h_\theta(x_i)) ^ {1 - y_i}<br>$$<br>对数似然法，即求$l(\theta)$ 的最大值：<br>$$<br>l(\theta) &#x3D; logL(\theta) &#x3D; \sum \limits_{i &#x3D; 1} ^m (y_i log h_\theta(x_i) + (1 - y_i) log (1 - h_\theta(x_i)))<br>$$<br>将上述函数转化为求最小值，同时系数乘上一个常数，即求$J(\theta) &#x3D; -\frac{1}{m}l(\theta)$ 的最小值，转化为梯度下降问题：<br>$$<br>J(\theta) &#x3D; -\frac{1}{m}l(\theta)<br>$$<br><img src="/808139430/image-20221228164952743.png" alt="求导过程"></p><p>上述过程即求出了偏导的方向，有了更新方向就可以进行参数更新： $\alpha$代表学习率<br>$$<br>\theta_j &#x3D; \theta_j - \alpha \frac{1}{m} \sum \limits_{i &#x3D; 1} ^ m (h_\theta(x_i) - y_i)x_i^j<br>$$</p><blockquote><p>减法是代表用的梯度下降，整体除以<code>m</code>是考虑了所有的m个样本。</p></blockquote><p>多分类问题：</p><p><img src="/808139430/image-20221228171310763.png" alt="多分类"></p><blockquote><p>Softmax回归是逻辑回归的一般化，相关对比参考 <a href="https://zhuanlan.zhihu.com/p/98061179">https://zhuanlan.zhihu.com/p/98061179</a></p></blockquote><h1 id="模型评估标准"><a href="#模型评估标准" class="headerlink" title="模型评估标准"></a>模型评估标准</h1><h2 id="1-回归模型评估"><a href="#1-回归模型评估" class="headerlink" title="1 回归模型评估"></a>1 回归模型评估</h2><h3 id="1-1-平均绝对误差（Mean-Absolute-Error，MAE）"><a href="#1-1-平均绝对误差（Mean-Absolute-Error，MAE）" class="headerlink" title="1.1 平均绝对误差（Mean Absolute Error，MAE）"></a>1.1 平均绝对误差（Mean Absolute Error，MAE）</h3><p>平均绝对误差就是指预测值与真实值之间平均相差多大<br>$$<br>MAE &#x3D; \frac{1}{m}\sum \limits _{i &#x3D; 1}^m \lvert f_i - y_i \rvert<br>$$</p><h3 id="1-2-均方误差（Mean-Squared-Error，MSE）"><a href="#1-2-均方误差（Mean-Squared-Error，MSE）" class="headerlink" title="1.2 均方误差（Mean Squared Error，MSE）"></a>1.2 均方误差（Mean Squared Error，MSE）</h3><p>观测值与真值偏差的平方和与观测次数的比值<br>$$<br>MSE &#x3D; \frac{1}{m} \sum \limits_{i &#x3D; 1}^m(f_i - y_i)^2<br>$$<br>这也是线性回归中最常用的损失函数，线性回归过程中尽量让该损失函数最小。那么模型之间的对比也可以用它来比较。</p><p>MSE可以评价数据的变化程度，MSE的值越小，说明预测模型描述实验数据具有更好的精确度。</p><h3 id="1-3-R-square（决定系数）"><a href="#1-3-R-square（决定系数）" class="headerlink" title="1.3 R-square（决定系数）"></a>1.3 R-square（决定系数）</h3><p>$$<br>R^2 &#x3D; 1 - \frac{\sum(Y_{actual} - Y_{predict})^2}{\sum(Y_{actual} - Y_{mean})^2}<br>$$</p><h3 id="1-4-Adjusted-R-Square（校正决定系数）"><a href="#1-4-Adjusted-R-Square（校正决定系数）" class="headerlink" title="1.4 Adjusted R-Square（校正决定系数）"></a>1.4 Adjusted R-Square（校正决定系数）</h3><p>$$<br>R^2_{adjusted} &#x3D; 1 - \frac{(1 - R^2)(n - 1)}{n - p - 1}<br>$$</p><p>n为样本数量，p为特征数量</p><p>消除了样本数量和特征数量的影响</p><h3 id="1-5-交叉验证"><a href="#1-5-交叉验证" class="headerlink" title="1.5 交叉验证"></a>1.5 交叉验证</h3><p>我们有一个总的数据集，将总数据集切分，例如，将数据分为训练集（80%）和测试集（20%），训练集用来训练model，测试集用来最终的测试。</p><p>训练集还再平均进行切分为3份（标号为1、2、3）。</p><blockquote><p>测试集和训练集的比例自己定。</p></blockquote><p>交叉验证就是在训练集中，采用2份数据来训练，用另一份数据来验证训练出的模型的参数，进行3次。</p><p>即：1 + 2来训练，3验证；2 + 3来训练，1来验证；1 + 3来训练，2来验证。</p><p>为了让模型的评估效果比较好，最后将3次的参数取平均值。</p><blockquote><p>无论分类还是回归模型，都可以利用交叉验证，进行模型评估</p><p>sklearn模块中有交叉验证函数，例如<code>sklearn.cross_validation</code> 中的 <code>train_testsplit</code> 函数</p></blockquote><p>交叉验证主要是为了防止某一部分数据比较简单，导致模型的效果比较高。</p><h2 id="2-分类模型评估"><a href="#2-分类模型评估" class="headerlink" title="2 分类模型评估"></a>2 分类模型评估</h2><h3 id="2-1-准确率、精确率、召回率、f1-score"><a href="#2-1-准确率、精确率、召回率、f1-score" class="headerlink" title="2.1 准确率、精确率、召回率、f1_score"></a>2.1 准确率、精确率、召回率、f1_score</h3><ul><li><p>准确率（Accuracy）的定义是：对于给定的测试集，分类模型正确分类的样本数与总样本数之比；</p></li><li><p>精确率（Precision）的定义是：对于给定测试集的某一个类别，分类模型预测正确的比例，或者说：分类模型预测的正样本中有多少是真正的正样本；</p></li><li><p>召回率（Recall）的定义为：对于给定测试集的某一个类别，样本中的正类有多少被分类模型预测正确；</p><blockquote><p>假设有1000个人，其中990个人正常，有10个人患有癌症，模型旨在预测哪些人是患有癌症的。</p><p>如果模型预测1000个人中都是正常的，没有癌症患者，那么可以说模型的精度是$\frac{990}{1000}&#x3D;0.99$。虽然精度很高，但是都是正样本，没有负样本，模型是无用的，因为一个患者都没有找到。因此无法用精度来评估模型，而是使用recall召回率来评估。</p></blockquote></li><li><p>F1_score，在理想情况下，我们希望模型的精确率越高越好，同时召回率也越高越高，但是，现实情况往往事与愿违，在现实情况下，精确率和召回率像是坐在跷跷板上一样，往往出现一个值升高，另一个值降低，那么，有没有一个指标来综合考虑精确率和召回率了，这个指标就是F值。F值的计算公式为：<br>$$<br>F &#x3D; \frac{(a ^ 2 + 1) \times P \times R}{a ^ 2 \times (P + R)}<br>$$</p><blockquote><p>P: Precision， R: Recall, a：权重因子</p><p>当a&#x3D;1时，F值便是F1值，代表精确率和召回率的权重是一样的，是最常用的一种评价指标。</p><p>F1的计算公式为：$F1 &#x3D; \frac{2 \times P \times R}{P + R}$</p></blockquote></li></ul><h3 id="2-2-混淆矩阵"><a href="#2-2-混淆矩阵" class="headerlink" title="2.2 混淆矩阵"></a>2.2 混淆矩阵</h3><p>混淆矩阵也称误差矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。</p><p>具体评价指标有总体精度、制图精度、用户精度等，这些精度指标从不同的侧面反映了图像分类的精度。</p><p>下面是一个混淆矩阵，<code>Actual</code>代表真实值，<code>Predicted</code>代表预测值，预测的是标签号（因为是分类任务，主要对标签进行分类）。</p><blockquote><p>下面是我对TP、TN、FP、FN四个值的理解（助记）</p><p>TP：预测正确，预测成1</p><p>TN：预测正确，预测成0</p><p>FP：预测错误，预测成1</p><p>FN：预测错误，预测成0</p></blockquote><p><img src="/808139430/image-20221230142020907.png" alt="混淆矩阵"></p><p>可以通过上面四个值计算相应的评估值，见下图。</p><p><img src="/808139430/image-20221230143921870.png" alt="混淆矩阵计算评估指标"></p><blockquote><ul><li>准确率：预测正确的比例</li><li>精确率：在预测之后，在预测结果的某一结果上，正确的比例</li><li>召回率：在预测之前，真实值为某一结果上，正确的比例</li></ul></blockquote><h1 id="回归模型相关技巧"><a href="#回归模型相关技巧" class="headerlink" title="回归模型相关技巧"></a>回归模型相关技巧</h1><h2 id="1-下采样和上采样"><a href="#1-下采样和上采样" class="headerlink" title="1 下采样和上采样"></a>1 下采样和上采样</h2><p>在分类问题的数据中，很容易出现正反数据集数量存在极大的差距，这类数据直接用于训练不利于模型的构架，所以我们需要对数据进行些许处理。</p><p>很容易想到，合理的数据集应该是正反数据集数量应接近，那就存在两种策略：</p><p>下采样策略：把数量多的减少到与数量少的相近</p><p>上（过）采样策略：把数量少的增加到与数量多的相近</p><ul><li>下采样：</li></ul><p><img src="/808139430/2.png" alt="img"></p><ul><li>上采样：SMOTE算法</li></ul><p><strong>步骤：</strong></p><p>（1）对于少数类中每一个样本x，以<strong>欧氏距离（两点之间距离）</strong>为标准计算它到少数类样本集中所有样本的距离，得到其<code>k</code>近邻（所有距离排序后前<code>k</code>小的距离）</p><p>（2）根据样本不平衡比例设置一个采样比例以确定采样倍率N，对于每一个少数类样本x，从其k近邻中随机选择若干个样本，假设选择的近邻为xn</p><p>（3）对于每一个随机选出的近邻xn，分别与原样本按照如下的公式构建新的样本。<br>$$<br>x_{new} &#x3D; x + rand(0, 1) \times (\widetilde x - x)<br>$$</p><blockquote><p>$(\widetilde x - x)$ 相当于距离 $d_i$ （欧几里得距离），那么每个 $d_i$ 都可以生成一个新的数据。</p></blockquote><p><img src="/808139430/image-20221230161807567.png" alt="SMOTE算法原理图"></p><h2 id="2-正则化惩罚"><a href="#2-正则化惩罚" class="headerlink" title="2 正则化惩罚"></a>2 正则化惩罚</h2><p>加上了正则化项能在一定程度上避免过拟合</p><h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>决策树是一种解决分类问题的算法，决策树算法采用树形结构，使用层层推理来实现最终的分类。</p><p>决策树即可以做分类，也可以做回归。它主要分为两种：<strong>分类树</strong> 和 <strong>回归树</strong>。</p><h3 id="1-2-决策树算法"><a href="#1-2-决策树算法" class="headerlink" title="1.2 决策树算法"></a>1.2 决策树算法</h3><ul><li>第一个决策树算法: CLS （Concept Learning System）</li><li>使决策树受到关注、成为机器学习主流技术的算法: ID3</li><li>最常用的决策树算法: C4.5</li><li>可以用于回归任务的决策树算法: CART （Classification and Regression Tree）</li><li>基于决策树的最强大算法: RF （Random Forest）</li></ul><h3 id="1-3-结构"><a href="#1-3-结构" class="headerlink" title="1.3 结构"></a>1.3 结构</h3><p>决策树由下面几种元素构成：</p><ul><li>根节点：包含样本的全集（全部训练数据）</li><li>内部节点：对应特征属性测试</li><li>叶节点：代表决策的结果</li></ul><p><img src="/808139430/image-20221230164038527.png" alt="决策树结构"></p><p>决策树学习的<strong>目的</strong>是为了产生一棵泛化能力强的决策树</p><h2 id="2-决策树构建"><a href="#2-决策树构建" class="headerlink" title="2 决策树构建"></a>2 决策树构建</h2><h3 id="2-1-构建过程"><a href="#2-1-构建过程" class="headerlink" title="2.1 构建过程"></a>2.1 构建过程</h3><p>整体策略：自上而下分而治之</p><p>决策树的构建过程就是一个<strong>自根至叶的递归过程</strong>， 在每个中间结点寻找一个<strong>划分</strong>属性。</p><p>大致过程：</p><ul><li>开始：构建根节点，所有训练数据都放在根节点，选择x个最优特征，按着这一特征将训练数据集分割成子集，进入子节点。</li><li>所有子集按内部节点的属性递归地进行分割。</li><li>如果这些子集已经能够被基本正确分类，那么构建叶节点，并将这些子集分到所对应的叶节点去。</li><li>每个子集都被分到叶节点上，即都有了明确的类，这样就生成了一颗决策树。</li></ul><p>递归的三种停止条件：</p><ul><li>当前结点包含的样本全属于同一类别，无需划分；</li><li>当前属性集为空，或是所有样本在所有属性上取值相同，无法划分;</li><li>当前结点包含的样本集合为空，不能划分。</li></ul><h3 id="2-2-特征选择"><a href="#2-2-特征选择" class="headerlink" title="2.2 特征选择"></a>2.2 特征选择</h3><p><strong>信息熵</strong>：随机变量的不确定性。<br>$$<br>H(X) &#x3D; - \sum p_i log_2 p_i \hspace{2em} \text{i &#x3D; 1, 2, …, n}<br>$$</p><blockquote><p>例：</p><p>A集合 $[1, 1, 1, 1, 1, 1, 1, 1, 2, 2]$</p><p>B集合$[1, 2, 3, 4, 5, 6, 7, 8, 9, 1]$</p><p>A集合熵值低于B集合熵值，因为A集合中只有两种类别，B集合中类别比较多（结构比较乱），熵值就会比较大</p></blockquote><p><strong>信息增益：</strong> 表示特征X使得类Y的不确定性减少的程度（熵值减少），即当前划分对信息熵所造成的变化。</p><p>信息增益越大，表示特征a来划分所减少的熵最大，即提升最大，应当作为根节点。</p><h2 id="3-决策树算法"><a href="#3-决策树算法" class="headerlink" title="3 决策树算法"></a>3 决策树算法</h2><h3 id="3-1-ID3（信息增益）"><a href="#3-1-ID3（信息增益）" class="headerlink" title="3.1 ID3（信息增益）"></a>3.1 ID3（信息增益）</h3><p>下面是基于信息增益的ID3算法的实例：</p><p>我们有14天的数据，4个特征条件：<strong>天气，温度，湿度，是否有风</strong>。最终结果是去玩不玩。</p><p><img src="/808139430/image-20221231110826312.png" alt="数据"></p><p><img src="/808139430/image-20221231110929844.png" alt="划分方式"></p><p>上面有四种划分方式，我们需要判断谁来当根节点，根据的主要就是信息增益这个指标。下面计算信息增益来判断根节点。</p><p>本例暂且以<code>ent(a, b)</code>代表以下含义：（只有两种结果的时候的熵值计算）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log2</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ent</span>(<span class="params">a, b</span>):</span><br><span class="line">    tot = a + b</span><br><span class="line">    x, y = a / tot, b / tot</span><br><span class="line">    <span class="keyword">return</span> -(x * log2(x) + y * log2(y))</span><br></pre></td></tr></table></figure><p>总的数据中，9天玩，5天不玩，熵值为：<br>$$<br>-\frac{9}{14}log_2 \frac{9}{14} - \frac{5}{14}log_2 \frac{5}{14} &#x3D; 0.940<br>$$<br>然后对4个特征逐个分析：</p><ul><li><p>outlook</p><ul><li><code>outlook = sunny</code>时，熵值为0.971，取值为sunny的概率为 $\frac{5}{14}$</li><li><code>outlook = overcast</code>时，熵值为0，取值为overcast的概率为 $\frac{4}{14}$</li><li><code>outlook = rainy</code>时，熵值为0.971，取值为rainy的概率为 $\frac{5}{14}$</li></ul><p>熵值为：<br>$$<br>\frac{5}{14} \times 0.971 + \frac{4}{14} \times 0 + \frac{5}{14} \times 0.971 &#x3D; 0.693<br>$$<br>信息增益：系统熵值从0.940下降到0.693，增益为0.247。</p></li><li><p>temperture</p><ul><li><code>temperture = hot</code>时，熵值为1.0（<code>ent(2, 2)</code>），取值为hot的概率为$\frac{4}{14}$</li><li><code>temperture = mild</code>时，熵值为0.918（<code>ent(4, 2)</code>），取值为mild的概率为$\frac{6}{14}$</li><li><code>temperture = cool</code>时，熵值为0.81（<code>ent(3,1)</code>），取值为cool的概率为$\frac{4}{14}$</li></ul><p>熵值为：<br>$$<br>\frac{4}{14} \times 1.0 + \frac{6}{14} \times 0.918 + \frac{4}{14} \times 0.81 &#x3D; 0.911<br>$$<br>信息增益：$Gain(S, temperture) &#x3D; 0.940 - 0.911 &#x3D; 0.029$</p></li><li><p>其他特征按照相同方法来做得到：</p></li></ul><p>$$<br>Gain(S，Outlook)&#x3D;0.247  \<br>Gain(S, Humidity)&#x3D;0.151  \<br>Gain(S, Wind)&#x3D;0 .048 \<br>Gain(S,Temperature)&#x3D;0 .029<br>$$</p><p>计算出所有的信息增益之后，选择<strong>有最大的信息增益的特征</strong>作为根节点。</p><p>下面找Sunny分支的决策树划分：</p><p>总的熵值<br>$$<br>-\frac{2}{5} \times log_2(\frac{2}{5}) - \frac{3}{5}log_2(\frac{3}{5}) &#x3D; 0.97<br>$$<br>以剩下的三个特征进行分析：</p><ul><li><p>temperture</p><ul><li>temperture&#x3D;hot，熵值为0，概率为$\frac{2}{5}$</li><li>temperture&#x3D;mild，熵值为1.0，概率为$\frac{2}{5}$</li><li>temperture&#x3D;cool，熵值为0，概率为$\frac{1}{5}$</li></ul><p>熵值为$\frac{2}{5}$</p><p>信息增益：$0.97-0.4 &#x3D; 0.57$</p></li><li><p>humidy</p><ul><li>high，熵值为0，概率为$\frac{3}{5}$</li><li>normal，熵值为1，概率为$\frac{2}{5}$</li></ul><p>熵值为$\frac{2}{5}$</p><p>信息增益：$0.97 - 0.4 &#x3D; 0.57$</p></li><li><p>windy</p><ul><li>false，熵值为0.918，概率为$\frac{3}{5}$</li><li>true，熵值为1，概率为$\frac{2}{5}$</li></ul><p>熵值为$0.951$</p><p>信息增益：$0.97 - 0.95 &#x3D; 0.02$</p></li></ul><p>故选择humidy或wind划分</p><p>剩下的划分同理，最终决策树为</p><p><img src="/808139430/image-20230208111655893.png" alt="最终决策树"></p><h3 id="3-2-C4-5（信息增益率）"><a href="#3-2-C4-5（信息增益率）" class="headerlink" title="3.2 C4.5（信息增益率）"></a>3.2 C4.5（信息增益率）</h3><blockquote><p>基于信息增益的决策树算法会有哪些问题：</p><p>如果有一个特征：id，代表样本的编号，以上述数据为例，id为从1到14，如果计算id特征的根节点，发现信息增益是最大的，因为每一个子节点的信息熵值都为0。</p></blockquote><p>信息增益率：（解决了ID3的问题，考虑自身熵，信息增益除以自身熵）<br>$$<br>\frac{G}{H(x)} \hspace{2em} \text{G:信息增益, H(x):熵值}<br>$$</p><h3 id="3-3-CART（GINI系数）"><a href="#3-3-CART（GINI系数）" class="headerlink" title="3.3 CART（GINI系数）"></a>3.3 CART（GINI系数）</h3><p>使用基尼系数作为衡量标准。<br>$$<br>Gini(p) &#x3D; \sum \limits _{k &#x3D; 1}^K p_k (1 - p_k) &#x3D; 1 - \sum \limits _{k &#x3D; 1}^K p_k^2<br>$$</p><h2 id="3-决策树剪枝"><a href="#3-决策树剪枝" class="headerlink" title="3 决策树剪枝"></a>3 决策树剪枝</h2><h3 id="3-1-预剪枝"><a href="#3-1-预剪枝" class="headerlink" title="3.1 预剪枝"></a>3.1 预剪枝</h3><p>在建立决策树边的时候进行剪枝的操作，比较使用实用。</p><p>剪枝策略：</p><ul><li>限制深度</li><li>限制叶子结点个数</li><li>限制叶子结点样本数</li><li>限制信息增益量等。</li></ul><h3 id="3-2-后剪枝"><a href="#3-2-后剪枝" class="headerlink" title="3.2 后剪枝"></a>3.2 后剪枝</h3><p>建立完决策树后进行剪枝操作。</p><h2 id="4-连续值和缺失值处理"><a href="#4-连续值和缺失值处理" class="headerlink" title="4 连续值和缺失值处理"></a>4 连续值和缺失值处理</h2><ul><li><p>连续值属性可取数值不是有限的，不能根据连续树形的可取值对节点进行划分。常见做法是：<strong>二分法</strong>对其进行离散化。</p></li><li><p>现实应用中，经常会遇到属性值<code>缺失</code>现象仅使用无缺失的样例，这是对数据的极大浪费使用带缺失值的样例，需解决：</p><ul><li>如何进行划分属性选择?</li><li>给定划分属性，若样本在该属性上的值缺失，如何进行划分?</li></ul><p>基本思路：<strong>样本赋权，权重划分</strong></p></li></ul><h1 id="集成算法"><a href="#集成算法" class="headerlink" title="集成算法"></a>集成算法</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1 概述"></a>1 概述</h2><p>集成算法：Ensemble Learning</p><p>Bagging：训练多个分类器取平均<br>$$<br>f(x) &#x3D; \frac{1}{M} \sum \limits_{m &#x3D; 1}^M f_m(x)<br>$$<br>Boosting：从弱学习器开始加强，通过加权来训练。<br>$$<br>F_m(x) &#x3D; F_{m - 1}(x) + argmin_h \sum \limits_{i &#x3D; 1}^n L(y_i, F_{m - 1}(x_i) + h(x_i))<br>$$<br>Stacking：聚合多个分类或回归模型。</p><h2 id="2-Bagging模型-随机森林"><a href="#2-Bagging模型-随机森林" class="headerlink" title="2 Bagging模型-随机森林"></a>2 Bagging模型-随机森林</h2><p>其实就是并行训练一堆分类器（每个分类器互相独立）。典型代表为随机森林（多个决策树并行放在一起）。</p><blockquote><p>随机指的是：数据随机采样，特征随机选择</p><p>每个分类器喂的数据随机，数据的特征数随机。二重随机性，会让每个树基本都不一样，最终的结果也不一样。</p></blockquote><p>随机森林优势：</p><ul><li>可以处理高维度（feature多）数据，不用做特征选择</li><li>训练完之后，可以给出那些feature比较重要</li><li>容易做成并行化方法，速度快</li><li>可以进行可视化展示，便于分析</li></ul><h2 id="3-Boosting模型"><a href="#3-Boosting模型" class="headerlink" title="3 Boosting模型"></a>3 Boosting模型</h2><p>提升模型典型代表：AdaBoost，XgBoost</p><p>AdaBoost：会根据前一次的分类效果调整数据权重</p><h2 id="4-Stacking模型"><a href="#4-Stacking模型" class="headerlink" title="4 Stacking模型"></a>4 Stacking模型</h2><p>堆叠模型：可以堆叠各种各样的分类器（KNN，SVM，RF等）</p><p>分阶段进行：第一阶段得出各自的结果，第二阶段再利用前一阶段结果进行训练。</p><h1 id="贝叶斯算法"><a href="#贝叶斯算法" class="headerlink" title="贝叶斯算法"></a>贝叶斯算法</h1><p>贝叶斯公式：<br>$$<br>P(A | B) &#x3D; \frac{P(B|A)P(A)}{P(B)}<br>$$</p><h2 id="1-1-实例：拼写纠正"><a href="#1-1-实例：拼写纠正" class="headerlink" title="1.1 实例：拼写纠正"></a>1.1 实例：拼写纠正</h2><p>用户输入一个不在词典中的单词，需要猜测用户真正想输入的单词。</p><p>我们要求的是<code>P(我们猜测用户想输入的单词|用户实际输入的单词)</code></p><p>假设用户实际输入的单词为<code>D</code>（Data）</p><p>我们有多个猜测：<code>P(h1 | D), P(h2 | D)</code>， 方便后续计算，统一为<code>P(h | D)</code><br>$$<br>P(h | D) &#x3D; \frac{P(h) P(D | h)}{P(D)}<br>$$</p><blockquote><p>$P(h)$为单词在语料库中出现的概率（出现次数 &#x2F; 总次数），我们叫做<strong>先验概率</strong>，这个概率可以算出来。</p><p>$P(D|h)$ 为我们将一个正确的词输入错误的概率。</p></blockquote><p>对于所有的猜测，$P(D)$ 都是一样的，所以可以忽略这个常数。</p><p>则<br>$$<br>P(h|D) \varpropto P(h)P(D|h)<br>$$</p><blockquote><p>$P(D|h)$可以根据某种指标来判定，可以看键盘上字母的编辑距离来算概率等等。</p></blockquote><p>如果计算出来多个结果预测概率是一样的，那么就可以使用<strong>先验概率</strong>来进行判断谁最优先。</p><h2 id="1-2-拼写检查器实现"><a href="#1-2-拼写检查器实现" class="headerlink" title="1.2 拼写检查器实现"></a>1.2 拼写检查器实现</h2><p>原理：<br>$$<br>argmaxc \ P(A|B) &#x3D; argmaxc \  \frac{P(B|A) P(A)}{P(B)}<br>$$</p><p>$P(A|B)$：待求值，用户本想输入B的前提下，错输成A的概率</p><p>$P(A)$：文章中出现正确单词A的概率</p><p>$P(B|A)$：用户本想输入A的前提下，错输成B的概率</p><p>$P(B)$：文章中出现正确单词B的概率</p><p>$argmaxc$：用来枚举所有可能的A，并选取概率最大的那个</p><p>拼写检查器就是，输入一个单词，先判断这个单词是否存在于语料库中（是否正确），如果不在（可能语料库中没有，或者拼写错误），则需要根据编辑距离进行检查修正。</p><p><code>big.txt</code>文件：<a href="https://wwwi.lanzouo.com/i9s8t0ju5qzg">https://wwwi.lanzouo.com/i9s8t0ju5qzg</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re, collections</span><br><span class="line"></span><br><span class="line"><span class="comment">#  将所有大写字母转化为小写，并且去掉特殊字符</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">words</span>(<span class="params">text</span>): <span class="keyword">return</span> re.findall(<span class="string">&#x27;[a-z]+&#x27;</span>, text.lower())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">features</span>):</span><br><span class="line">    <span class="comment"># 遇到从来没有见过的新词但语料库中未包含，概率模型中希望返回一个很小的概率，故出现次数设置为1</span></span><br><span class="line">    model = collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> features:</span><br><span class="line">        model[f] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NWORDS = train(words(<span class="built_in">open</span>(<span class="string">&#x27;big.txt&#x27;</span>).read()))  <span class="comment"># 词频</span></span><br><span class="line">alphabet = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑距离为1的单词</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edits1</span>(<span class="params">word</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(word)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>([word[<span class="number">0</span>: i] + word[i + <span class="number">1</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] +   <span class="comment"># deletion</span></span><br><span class="line">               [word[<span class="number">0</span>: i] + word[i + <span class="number">1</span>] + word[i] + word[i + <span class="number">2</span>:] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>)] +  <span class="comment"># transportation</span></span><br><span class="line">               [word[<span class="number">0</span>: i] + c + word[i + <span class="number">1</span>: ] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">for</span> c <span class="keyword">in</span> alphabet] +  <span class="comment"># alteration</span></span><br><span class="line">               [word[<span class="number">0</span>: i] + c + word[i: ] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>) <span class="keyword">for</span> c <span class="keyword">in</span> alphabet])  <span class="comment"># insertion</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑距离为2 的单词</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edits2</span>(<span class="params">word</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(e2 <span class="keyword">for</span> e1 <span class="keyword">in</span> edits1(word) <span class="keyword">for</span> e2 <span class="keyword">in</span> edits1(e1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将那些正确的词作为候选词</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">known</span>(<span class="params">words</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(w <span class="keyword">for</span> w <span class="keyword">in</span> words <span class="keyword">if</span> w <span class="keyword">in</span> NWORDS)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查器函数，先判断是不是正确的拼写形式，如果不是则选出编辑距离为1的单词……</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">correct</span>(<span class="params">word</span>):</span><br><span class="line">    candidates = known([word]) <span class="keyword">or</span> known(edits1(word)) <span class="keyword">or</span> known(edits2(word)) <span class="keyword">or</span> [word]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(candidates, key=<span class="keyword">lambda</span> w: NWORDS[w])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(correct(<span class="string">&#x27;mach&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="1-3-新闻分类"><a href="#1-3-新闻分类" class="headerlink" title="1.3 新闻分类"></a>1.3 新闻分类</h2><p>之后用到了再补，短时间不会写。</p><h1 id="SVM支持向量机"><a href="#SVM支持向量机" class="headerlink" title="SVM支持向量机"></a>SVM支持向量机</h1><h2 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1 概述"></a>1 概述</h2><p>Support Vector Machine是一种二分类模型，它的基本模型是定义在特征空间上的<strong>间隔最大的线性分类器</strong></p><p>SVM学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。如下图所示， $wx+b&#x3D;0$ 即为分离超平面，对于线性可分的数据集来说，这样的超平面有无穷多个（即感知机），但是几何间隔最大的分离超平面却是唯一的。</p><p><img src="/808139430/image-20230102144808362.png" alt="支持向量机"></p><h2 id="2-推导"><a href="#2-推导" class="headerlink" title="2 推导"></a>2 推导</h2><h3 id="2-1-距离"><a href="#2-1-距离" class="headerlink" title="2.1 距离"></a>2.1 距离</h3><p>正常三维条件下点$(x_0, y_0, z_0)$到平面$Ax + By + Cz + D &#x3D; 0$的距离公式（高中知识）：<br>$$<br>\frac{\vert Ax_0 + By_0 + Cz_0 + D \vert}{\sqrt{A^2 + B^2 + C^2}}<br>$$<br>推导分析过程：</p><p>平面方程： $ax + by + cz &#x3D; d$ ，平面外一点$P(x_0, y_0, z_0)$</p><p><img src="/808139430/image-20230102153203878.png" alt="示意图"></p><p>PQ垂直平面，即为求PQ的长度，但不知Q点的具体数据。</p><p>故构造一个平面上的点$P^{‘}(x_1, y_1, z_1)$，问题即转化为求$\overrightarrow {P^{‘}P}$ 在法向量N上面的分量，即$\overrightarrow {P^{‘}P}$ 与N相同方向的单位向量的点积。</p><p><img src="/808139430/image-20230102153230935.png" alt="示意图"></p><p>设距离为D。</p><p><img src="/808139430/1203675-20180109152428254-718844217.png" alt="距离公式推导"></p><p>现在考虑一般情况：</p><p>求平面外一点 $x$ 到平面$w^T x + b &#x3D; 0$ 的距离：</p><blockquote><p>结论：平面$Ax + By + Cz + D &#x3D; 0$的法向量为$(A, B, C)$</p></blockquote><p><img src="/808139430/image-20230102154354917.png" alt="示意图"></p><p>同上述原理：</p><p>距离就为<br>$$<br>distance(x, b, w) &#x3D; \vert \frac{w^T}{\vert \vert w \vert \vert}(x - x^{‘}) \vert &#x3D; \frac{1}{\vert \vert w \vert \vert} \vert w^Tx + b \vert<br>$$</p><blockquote><p>上述公式进行了代入，将$x^{‘}$代入平面方程得$w^Tx^{‘} &#x3D; -b$</p></blockquote><h3 id="2-2-数据"><a href="#2-2-数据" class="headerlink" title="2.2 数据"></a>2.2 数据</h3><p>数据集：$(x_1, y_1)(x_2, y_2)…(x_n, y_n)$</p><p>$Y$ 为样本的类别：当$X$ 为正例时，$Y &#x3D; +1$，当$X$为负例时，$Y &#x3D; -1$</p><p>决策方程：$y(x) &#x3D; w^T \Phi(x) + b$ （其中$\Phi(x)$是对数据做了核变换，可以暂时理解为$x$）<br>$$<br>\begin{cases}<br>y(x_i) &gt; 0 \Leftrightarrow y_i &#x3D; +1 \<br>y(x_i) &lt; 0 \Leftrightarrow y_i &#x3D; -1<br>\end{cases}<br>\Longrightarrow<br>y_i y(x_i) &gt; 0<br>$$</p><h3 id="2-3-目标函数求解"><a href="#2-3-目标函数求解" class="headerlink" title="2.3 目标函数求解"></a>2.3 目标函数求解</h3><blockquote><p>我们要求的就是找到一个线性划分（比如说直线），使得离该线最近的点最远。</p></blockquote><p>将点到直线距离进行转化（化简）：<br>$$<br>\frac{y_i \cdot (w^T \cdot \Phi(x) + b)}{\vert \vert w \vert \vert}<br>$$</p><blockquote><p>$y_i y(x_i) &gt; 0$ 直接乘上$y_i$ 将绝对值去掉，$|y_i| &#x3D; 1$，并不影响值大小</p></blockquote><p>放缩变换：对于决策方程（w, b）可以通过放缩变换使其结果值$|Y| \geq 1$ ，则<br>$$<br>y_i \cdot (w^T \cdot \Phi(x_i) + b) \geq 1<br>$$</p><blockquote><p>缩放之前w和b有无数组解，缩放之后w和b只有一组解。</p></blockquote><p>优化目标：<br>$$<br>\mathop{arg\  max} \limits_{w, b} \bigg{ \frac{1}{||w||} \mathop{min} \limits_i \Big { y_i \cdot (w^T \cdot \Phi(x_i) + b)\Big } \bigg}<br>$$</p><blockquote><p>$\mathop{min} \limits_i \Big { y_i \cdot (w^T \cdot \Phi(x_i) + b) \Big }$ 是求所有样本点到平面的最小距离的那个点</p><p>$\mathop{argmax} \limits_{w,b}$ 是<strong>最大化到平面最小距离的点的距离，此时的w,b的值</strong></p><p>由于$y_i \cdot (w^T \cdot \Phi(x_i) + b) \geq 1$， 故最小值为1，只需要考虑 $\mathop{arg\  max} \limits_{w, b} \frac{1}{||w||}$</p></blockquote><p>当前目标变为：$\mathop{max} \limits_{w, b} \frac{1}{||w||}$，即求$||w||$的最小值，但有约束条件 $y_i \cdot (w^T \cdot \Phi(x_i) + b) \geq 1$</p><p>将求极大值转化为求极小值的问题，求$\frac{1}{2}||w||^2$ 的最小值。</p><p>需要使用<strong>拉格朗日乘子法</strong>：（此处不做证明，直接给出结论）<br>$$<br>L(w, b, \alpha) &#x3D; \frac{1}{2}||w||^2 - \sum \limits_{i &#x3D; 1}^n \alpha_i (y_i \cdot (w^T \cdot \Phi(x_i) + b) - 1)<br>$$</p><blockquote><p>上式需要满足约束条件：$y_i \cdot (w^T \cdot \Phi(x_i) + b) \geq 1$</p><p>满足KKT条件的点未必是局部（全局）最优点（还可能是局部极大和鞍点），但局部（全局）最优点必然满足KKT条件。对于凸优化问题，满足KKT条件的解直接就是全局最优解<br>$$<br>最优解的必要条件:<br>\begin{cases}<br>\nabla L(\mathbf{x}, \lambda) &#x3D; \nabla f(\mathbf{x}) + \lambda \nabla g(\mathbf{x}) &#x3D; 0 \<br>\lambda \ge 0 \<br>\lambda g(\mathbf{x}) &#x3D; 0 (互补松弛)\<br>g(\mathbf{x}) \le 0 (原约束)<br>\end{cases}<br>$$</p><p>推导可参考：<a href="https://blog.csdn.net/v_july_v/article/details/7624837">https://blog.csdn.net/v_july_v/article/details/7624837</a> </p><p>原理可参考：<a href="https://zhuanlan.zhihu.com/p/31886934">https://zhuanlan.zhihu.com/p/31886934</a> </p></blockquote><p><img src="/808139430/image-20230102224841617.png" alt="求解过程"></p><p><img src="/808139430/image-20230102225344026.png" alt="求解过程"></p><p><img src="/808139430/image-20230102225422893.png" alt="求解过程"></p><h2 id="3-SVM实例"><a href="#3-SVM实例" class="headerlink" title="3 SVM实例"></a>3 SVM实例</h2><p>有三个数据：3个点，正例$x_1(3, 3), x_2(4, 3)$， 负例$x_3(1, 1)$，（数据是二维数据）对其进行二分类。</p><p>首先需要求解下式的最小值：<br>$$<br>\frac{1}{2}\sum \limits_{i &#x3D; 1}^n \sum \limits <em>{j &#x3D; 1}^n \alpha_i \alpha_j y_i y_j (x_i \cdot x_j) - \sum \limits</em>{i &#x3D; 1}^n\alpha_i \hspace{3em} (1)<br>$$</p><blockquote><p>注意：$x_i \cdot x_j$ 的运算是点积运算。</p><p>约束条件：<br>$$<br>\alpha_1 + \alpha_2 - \alpha_3 &#x3D; 0 \<br>\alpha_i \geq 0, \hspace{2em} i &#x3D; 1, 2, 3<br>$$</p></blockquote><p><img src="/808139430/image-20230103144319179.png" alt="图像示意"></p><p>将对应的数据带入（1）式，得：<br>$$<br>\frac{1}{2} \Big( 18 \alpha_1^2 + 25\alpha_2^2 + 2 \alpha_3^2 + 42\alpha_1\alpha_2 - 12\alpha_1\alpha_3 - 14\alpha_2\alpha_3 \Big) - \alpha_1 - \alpha_2 - \alpha_3<br>$$<br>由于$\alpha_1 + \alpha_2 &#x3D; \alpha_3$，化简得：<br>$$<br>4 \alpha_1 ^ 2 + \frac{13}{2} \alpha_2^2 + 10\alpha_1\alpha_2 - 2\alpha_1 - 2\alpha_2<br>$$<br>分别对$\alpha_1,\alpha_2$求偏导，偏导等于0得<br>$$<br>\begin{cases}<br>\alpha_1 &#x3D; 1.5 \<br>\alpha_2 &#x3D; -1<br>\end{cases}<br>$$<br>发现不满足约束条件$\alpha_i \geq 0$，故解应在边界上。分别让两个值等于0求解<br>$$<br>\begin{cases}<br>\alpha_1 &#x3D; 0 \<br>\alpha_2 &#x3D; -\frac{2}{13}<br>\end{cases}<br>(\times)<br>\hspace{4em}<br>\begin{cases}<br>\alpha_1 &#x3D; 0.25 \<br>\alpha_2 &#x3D; 0<br>\end{cases}<br>(\checkmark)<br>$$<br>第一组解不满足，故最小值在$(0.25, 0, 0.25)$处取得。</p><p>将$\alpha$结果带求解$w &#x3D; \sum \limits_{i &#x3D; 1}^n \alpha_i y_i \Phi(x_i)$，$\Phi(x_i)$以$x_i$来代替<br>$$<br>w &#x3D; \frac{1}{4} \times 1 \times (3,3) + \frac{1}{4} \times (-1) \times(1,1) &#x3D; (\frac{1}{2}, \frac{1}{2})<br>\<br>b &#x3D; y_i - \sum \limits_{i &#x3D; 1}^n a_i y_i (x_i x_j) &#x3D; 1 - (\frac{1}{4} \times 1 \times 18  + \frac{1}{4} \times (-1) \times 6) &#x3D; -2<br>$$<br>故平面方程为：<br>$$<br>0.5 x_1 + 0.5 x_2 - 2 &#x3D; 0<br>$$</p><blockquote><p>因为$w &#x3D; \sum \limits_{i &#x3D; 1}^n \alpha_i y_i \Phi(x_i)$</p><p>支持向量的$\alpha$值不等于0，$\alpha &#x3D; 0$的向量不是支持向量，对最终结果没有影响。</p><p>支持向量就是那些对最终结果起作用的向量，也可以当做是边界上的向量。</p></blockquote><h2 id="4-软间隔"><a href="#4-软间隔" class="headerlink" title="4 软间隔"></a>4 软间隔</h2><p>数据中有时候会有一些噪音点，如果考虑它们结果可能不会很好。</p><p>之前讨论的是要求所有样本点全部满足约束（这是硬间隔），而实际情况中这显然是不太可能的，软间隔则是允许某些样本点不满足约束。</p><p>为解决该问题，引入松弛因子：$y_i(w \cdot x_i + b) \geq 1 - \xi_i$</p><p>新的目标函数：<br>$$<br>\mathop{min}\limits_{w, b, \xi_i} \frac{1}{2} ||w||^2 + C \sum \limits _{i &#x3D; 1}^n \xi_i<br>$$</p><blockquote><p>C是我们需要指定的一个参数</p><p>当C趋近于很大时：意味着分类严格不能有错误</p><p>当C趋近于很小时：意味着可以由更大的错误容忍</p></blockquote><p>解法基本一样：</p><p><img src="/808139430/image-20230103153918323.png" alt="解法"></p><h2 id="5-SVM核变换"><a href="#5-SVM核变换" class="headerlink" title="5 SVM核变换"></a>5 SVM核变换</h2><p>将低维不可分映射到高维，找到一种变换方法，即为$\phi(x)$</p><p>高斯核函数：<br>$$<br>K(X, Y) &#x3D;  exp \bigg{ -\frac{||X-Y||^2}{2\sigma^2} \bigg}<br>$$</p><h2 id="6-基于sklearn求解SVM"><a href="#6-基于sklearn求解SVM" class="headerlink" title="6 基于sklearn求解SVM"></a>6 基于sklearn求解SVM</h2><p>参考 <a href="https://blog.csdn.net/weixin_42600072/article/details/88644229">https://blog.csdn.net/weixin_42600072/article/details/88644229</a></p><h1 id="聚类算法"><a href="#聚类算法" class="headerlink" title="聚类算法"></a>聚类算法</h1><p>性能度量：</p><ul><li>外部指标<ul><li><code>jaccard</code>系数（简称<code>JC</code>）</li><li><code>FM</code>指数（简称<code>FMI</code>）</li><li><code>Rand</code>指数（简称<code>RI</code>）</li></ul></li><li>内部指标<ul><li><code>DB</code>指数（简称<code>DBI</code>）</li><li><code>Dunn</code>指数（简称<code>DI</code>）</li></ul></li></ul><p>距离计算：</p><ul><li>$L_p$ 范数</li><li>欧氏距离</li><li>曼哈顿距离</li></ul><p>分类：</p><ul><li>原型聚类：<code>k-means</code>算法，学习向量量化（有监督学习），高斯混合聚类 都是此类型算法</li></ul><blockquote><p>假设聚类结构能够通过一组原型刻画，然后对原型进行迭代更新求解。</p></blockquote><ul><li><p>密度聚类：DBSCAN</p></li><li><p>层次聚类：AGNES</p><p>试图在不同层次上对数据集进行划分，分为自底向上的聚合策略和自顶向下的分拆策略</p></li></ul><p>聚簇之间的距离的计算：最小距离，最大距离和平均距离（两个簇中样本点对距离之和取平均）</p><p>AGNES算法被相应称为：单链接算法（以最小距离为准），全链接算法（以最大距离为准）和均链接算法</p><blockquote><p>以单链接算法为例：</p><ul><li>初始时每个样本点看做一个簇，找到所有簇对中最小的距离，将他们合并为一个簇，此时合并的簇与其他簇的距离更新为两个点到其他簇距离的最小值。</li><li>上面的步骤为循环里面的步骤，接着进行下一次循环，找到所有簇中最短的距离，然后将他们合并，合并后更新簇之间的距离为【合并簇中的所有点到其他簇距离的最小值】，一直进行上述循环操作，直到达到指定簇的数量再停止循环。</li></ul></blockquote><h2 id="K-MEANS算法"><a href="#K-MEANS算法" class="headerlink" title="K-MEANS算法"></a>K-MEANS算法</h2><h3 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1 概述"></a>1 概述</h3><p>聚类概念：这是个无监督问题（没有标签数据），目的是将相似的东西分到一组。</p><p>通常使用的算法是K-MEANS算法</p><blockquote><p>K-MEANS算法：</p><ul><li>需要指定簇的个数，即K值</li><li>质心：数据的均值，即向量各维取平均即可</li><li>距离的度量：常用欧几里得距离和余弦相似度（先标准化，让数据基本都是在一个比较小的范围内浮动）</li><li>优化目标：$min\sum \limits_{i &#x3D; 1}^K \sum \limits_{x \in C_i} dist(c_i, x)^2$ （对于每一个簇让每一个样本到中心点的距离越小越好，$c_i$代表中心点）</li></ul></blockquote><h3 id="2-K-MEANS流程"><a href="#2-K-MEANS流程" class="headerlink" title="2 K-MEANS流程"></a>2 K-MEANS流程</h3><p>假设平面上有一系列样本点，现在需要将其进行分组。</p><p>选定<code>K=2</code>，即将这些数据点分成两个组别。</p><ul><li>随机选择两个质心（分别代表两个簇），计算所有样本点到两个质心的距离。每个样本点会计算出到两个质心的距离，那么选择最小的距离，这个样本点就归属于哪个簇。</li><li>然后对于两个簇的所有样本点分别算出对应的质心（这两个质心便充当新的质心），再对所有样本点计算到两个新的质心的距离，还是选择最小的距离，那么这个样本点就归属于哪个簇。</li><li>最终直到两个簇所属的样本点不在发生变化。</li></ul><blockquote><p><a href="https://www.bilibili.com/video/BV1bt411i77G?p=101&vd_source=bb4ca29d8dfb2e3c28c10bb09f4b962e">K-MEANS工作流程视频参考</a></p></blockquote><h3 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3 优缺点"></a>3 优缺点</h3><p>优点：</p><ul><li>简单快速，适合常规数据集</li></ul><p>缺点：</p><ul><li>K值难以确定</li><li>复杂度与样本呈线性关系</li><li>很难发现任意形状的簇</li><li>初始的点影响很大</li></ul><blockquote><p> <a href="https://www.naftaliharris.com/blog/visualizing-k-means-clustering/">K-MEANS可视化演示</a></p></blockquote><h3 id="4-K-MEANS进行图像压缩"><a href="#4-K-MEANS进行图像压缩" class="headerlink" title="4 K-MEANS进行图像压缩"></a>4 K-MEANS进行图像压缩</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">image = io.imread(<span class="string">&quot;1.jpg&quot;</span>)</span><br><span class="line">io.imshow(image)</span><br><span class="line"><span class="comment"># io.show()  # 显示图片</span></span><br><span class="line"></span><br><span class="line">rows = image.shape[<span class="number">0</span>]</span><br><span class="line">cols = image.shape[<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(image.shape)</span><br><span class="line"></span><br><span class="line">image = image.reshape(rows * cols, <span class="number">3</span>)</span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">128</span>, n_init=<span class="number">10</span>, max_iter=<span class="number">100</span>)  <span class="comment"># 簇128, 最大迭代次数100</span></span><br><span class="line">kmeans.fit(image)</span><br><span class="line"></span><br><span class="line">clusters = np.asarray(kmeans.cluster_centers_, dtype=np.uint8)</span><br><span class="line">labels = np.asarray(kmeans.labels_, dtype=np.uint8)</span><br><span class="line">labels = labels.reshape(rows, cols)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(clusters.shape)</span><br><span class="line">np.save(<span class="string">&#x27;test.npy&#x27;</span>, clusters)</span><br><span class="line">io.imsave(<span class="string">&#x27;compressed.jpg&#x27;</span>, labels)</span><br></pre></td></tr></table></figure><h2 id="DBSCAN算法"><a href="#DBSCAN算法" class="headerlink" title="DBSCAN算法"></a>DBSCAN算法</h2><h3 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1 概述"></a>1 概述</h3><p>DBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）是一种<strong>基于密度的空间聚类算法</strong>。该算法将具有足够密度的区域划分为簇，并在具有噪声的空间数据库中发现任意形状的簇，DBSCAN算法将<code>簇</code>定义为密度相连的点的最大集合。</p><p>核心对象：若某个点的密度达到算法设定的阈值则称其为核心点。（即<code>r</code>邻域内的点的数量不小于<code>minPts</code>）</p><p>基于以上密度的定义，我们可以将样本集中的点划分为以下三类：</p><ul><li><strong>核心点</strong>：在半径r区域内，含有超过MinPts数目（最小数目）的点，称为核心点；</li><li><strong>边界点</strong>：在半径r区域内，点的数量小于MinPts数目，但是是核心点的直接邻居；</li><li><strong>噪声点</strong>：既不是核心点也不是边界点的点</li></ul><blockquote><p>噪声点是不会被聚类纳入的点，边界点与核心点组成聚类的“簇”。</p></blockquote><p>一些概念：</p><ul><li><strong>直接密度可达（密度直达）</strong>：如果p在q的r领域内，且<strong>q是一个核心点对象</strong>，则称对象p从对象q出发时直接密度可达，反之不一定成立，即密度直达不满足对称性。</li><li><strong>密度可达</strong>：如果存在一个对象链q–&gt;e–&gt;a–&gt;k–&gt;l–&gt;p，任意相邻两个对象间都是密度直达的，则称对象p由对象q出发密度可达。密度可达满足传递性。</li><li><strong>密度相连</strong>：对于 $x_i$ 和 $x_j$ ,如果存在核心对象样本 $x_k$ ，使 $x_i$ 和 $x_j$ 均由 $x_k$ 密度可达，则称 $x_i$ 和 $x_j$ 密度相连。<strong>密度相连关系满足对称性</strong>。</li></ul><blockquote><p>核心点能够连通（密度可达），它们构成的以r为半径的圆形邻域相互连接或重叠，这些连通的核心点及其所处的邻域内的全部点构成一个簇。</p></blockquote><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理</h3><ol><li>DBSCAN通过检查数据集中每个点的r邻域来搜索簇，如果点p的r邻域包含多于MinPts个点，则创建一个以p为核心对象的簇；</li><li>然后， DBSCAN迭代的聚集从这些核心对象直接密度可达的对象，这个过程可能涉及一些密度可达簇的合并；</li><li>当没有新的带你添加到任何簇时，迭代过程结束。</li></ol><p>优缺点：</p><ul><li><p>优点：基于密度定义，可以对抗噪声，能处理任意形状和大小的簇</p></li><li><p>缺点：当簇的密度变化太大时候，聚类得到的结果会不理想；对于高维问题，密度定义也是一个比较麻烦的问题。</p></li></ul><h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3 实现"></a>3 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> matplotlib.colors</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Figure</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">u&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># 用来正常显示负号</span></span><br><span class="line">matplotlib.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">X1, y1 = datasets.make_circles(n_samples=<span class="number">5000</span>, factor=<span class="number">.6</span>,</span><br><span class="line">                                      noise=<span class="number">.05</span>)</span><br><span class="line">X2, y2 = datasets.make_blobs(n_samples=<span class="number">1000</span>, n_features=<span class="number">2</span>,</span><br><span class="line">                             centers=[[<span class="number">1.2</span>,<span class="number">1.2</span>]], cluster_std=[[<span class="number">.1</span>]],random_state=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始点的分布</span></span><br><span class="line">ax1 = fig.add_subplot(<span class="number">311</span>)</span><br><span class="line">X = np.concatenate((X1, X2))</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">u&#x27;原始数据分布&#x27;</span>)</span><br><span class="line">plt.sca(ax1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># K-means聚类</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">312</span>)</span><br><span class="line">y_pred = KMeans(n_clusters=<span class="number">3</span>, random_state=<span class="number">9</span>).fit_predict(X)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_pred)</span><br><span class="line">plt.title(<span class="string">u&#x27;K-means聚类&#x27;</span>)</span><br><span class="line">plt.sca(ax2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DBSCAN聚类</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">313</span>)</span><br><span class="line">y_pred = DBSCAN(eps = <span class="number">0.1</span>, min_samples = <span class="number">10</span>).fit_predict(X)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_pred)</span><br><span class="line">plt.title(<span class="string">u&#x27;DBSCAN聚类&#x27;</span>)</span><br><span class="line">plt.sca(ax3)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="PCA主成分分析"><a href="#PCA主成分分析" class="headerlink" title="PCA主成分分析"></a>PCA主成分分析</h1><p>Principal Component Analysis：降维中最常用的一种手段，PCA的主要思想是将<code>n</code>维特征映射到<code>k</code>维上，这<code>k</code>维是全新的正交特征也被称为主成分，是在原有<code>n</code>维特征的基础上重新构造出来的<code>k</code>维特征。</p><p>PCA的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的，第三个轴是与第1,2个轴正交的平面中方差最大的。依次类推，可以得到n个这样的坐标轴。通过这种方式获得的新的坐标轴，我们发现，大部分方差都包含在前面k个坐标轴中，后面的坐标轴所含的方差几乎为0。于是，我们可以忽略余下的坐标轴，只保留前面k个含有绝大部分方差的坐标轴。</p><p>通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值特征向量，选择特征值最大(即方差最大)的k个特征所对应的特征向量组成的矩阵。这样就可以将数据矩阵转换到新的空间当中，实现数据特征的降维。</p><p>由于得到协方差矩阵的特征值特征向量有两种方法：特征值分解协方差矩阵、奇异值分解协方差矩阵，所以PCA算法有两种实现方法：</p><ul><li><p>基于特征值分解协方差矩阵实现PCA算法</p></li><li><p>基于SVD分解协方差矩阵实现PCA算法</p></li></ul><h2 id="1-基变换"><a href="#1-基变换" class="headerlink" title="1 基变换"></a>1 基变换</h2><p>目标：提取最有价值的信息（基于方差）</p><ul><li><p>基概念：例如在二维坐标系中，向量（3，4）也可表示为线性组合$x(1, 0) + y(0, 1)$，而$(0,1)(1,0)$叫做二维空间的一组基。</p></li><li><p>基变换</p><ul><li><p>要求：基是正交的（内积&#x2F;点积为0，或者说互相垂直，线性无关）</p></li><li><p>变换：数据与第一个基做内积运算，结果作为第一个新的坐标分量；数据与第二个基做内积运算，结果作为第二个新的坐标分量。</p></li></ul></li></ul><h1 id="比如-3-2-映射到基的坐标：-begin-pmatrix-frac-1-sqrt-2-frac-1-sqrt-2-frac-1-sqrt-2-frac-1-sqrt-2-end-pmatrix-begin-pmatrix-3-2-end-pmatrix"><a href="#比如-3-2-映射到基的坐标：-begin-pmatrix-frac-1-sqrt-2-frac-1-sqrt-2-frac-1-sqrt-2-frac-1-sqrt-2-end-pmatrix-begin-pmatrix-3-2-end-pmatrix" class="headerlink" title="比如$(3,2)$映射到基的坐标：$$\begin{pmatrix}\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \-\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}}\end{pmatrix}\begin{pmatrix}3 \2\end{pmatrix}"></a>比如$(3,2)$映射到基的坐标：<br>$$<br>\begin{pmatrix}<br>\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \<br>-\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}}<br>\end{pmatrix}<br>\begin{pmatrix}<br>3 \<br>2<br>\end{pmatrix}</h1><p>\begin{pmatrix}<br>\frac{5}{\sqrt 2} \<br>-\frac{1}{\sqrt 2}<br>\end{pmatrix}<br>$$</p><ul><li>基变换一般公式：</li></ul><h1 id="begin-pmatrix-p-1-p-2-vdots-p-n-end-pmatrix-begin-pmatrix-a-1-a-2-cdots-a-m-end-pmatrix"><a href="#begin-pmatrix-p-1-p-2-vdots-p-n-end-pmatrix-begin-pmatrix-a-1-a-2-cdots-a-m-end-pmatrix" class="headerlink" title="$$\begin{pmatrix}p_1 \p_2 \\vdots \p_n\end{pmatrix}\begin{pmatrix}a_1 &amp; a_2 &amp; \cdots &amp;a_m\end{pmatrix}"></a>$$<br>\begin{pmatrix}<br>p_1 \<br>p_2 \<br>\vdots \<br>p_n<br>\end{pmatrix}<br>\begin{pmatrix}<br>a_1 &amp; a_2 &amp; \cdots &amp;a_m<br>\end{pmatrix}</h1><p>\begin{pmatrix}<br>p_1a_1 &amp; p_1a_2 &amp; \cdots &amp; p_1a_m \<br>p_2a_1 &amp; p_2a_2 &amp; \cdots &amp; p_2a_m \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>p_na_1 &amp; p_na_2 &amp; \cdots &amp; p_na_m \<br>\end{pmatrix}<br>$$</p><blockquote><p>等式左边的两个矩阵中，左边是基，右边是数据。</p><p>两个矩阵相乘的意义是将右边的矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。</p></blockquote><h2 id="2-协方差矩阵"><a href="#2-协方差矩阵" class="headerlink" title="2 协方差矩阵"></a>2 协方差矩阵</h2><p>我们希望选择一个方向（基）：数据能够保留更多的原始信息，也可以说希望经过某个基投影后的投影值尽可能分散。（雾</p><p>方差：<br>$$<br>Var(a) &#x3D; \frac{1}{m} \sum \limits_{i &#x3D; 1}^m (a_i - \mu)^2<br>$$<br>寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，<strong>方差值最大</strong>（分散）。</p><p>协方差：（假设均值为0时）（对于标签$a_i, b_i$，如果两个相似度越大，协方差越大）<br>$$<br>Cov(a, b) &#x3D; \frac{1}{m} \sum \limits_{i &#x3D; 1}^m a_ib_i<br>$$</p><blockquote><p>如果单纯选择方差最大的方向，后续方向应该会和方差最大的方向接近重合。</p><p>解决方案：为了让两个子段尽可能表示更多的原始信息，我们是不希望他们之间存在（线性）相关性的。</p><p>可以用两个字段的协方差表示相关性，当协方差为0时，代表两个字段是相互独立的。</p></blockquote><p>题意：将一组N维向量降为K维，目标是选择K个单位的正交基，使原始数据变换到这组基上面后，各字段两两之间协方差为0，字段方差尽可能大。</p><p>$$<br>\text{特征数据}X &#x3D;<br>\begin{pmatrix}<br>a_1 &amp; a_2 &amp; \cdots &amp; a_m \<br>b_1 &amp; b_2 &amp; \cdots &amp; b_m<br>\end{pmatrix}<br>$$<br>协方差矩阵：<br>$$<br>\frac{1}{m}XX^T &#x3D;<br>\begin{pmatrix}<br>\frac{1}{m}\sum \limits_{i &#x3D; 1}^m a_i^2  &amp; \frac{1}{m}\sum \limits_{i &#x3D; 1}^ma_ib_i \<br>\frac{1}{m}\sum \limits_{i &#x3D; 1}^m a_ib_i &amp; \frac{1}{m}\sum \limits_{i &#x3D; 1}^mb_i^2<br>\end{pmatrix}<br>$$</p><blockquote><p>矩阵对角线上的两个元素分别为两个字段的方差（假设均值为0），而其他元素是a和b的协方差。</p></blockquote><h2 id="3-优化"><a href="#3-优化" class="headerlink" title="3 优化"></a>3 优化</h2><p>接下来就是希望让协方差矩阵的除对角线位置的元素为0（协方差为0），就是进行对角化操作。</p><p>协方差矩阵对角化：<br>$$<br>PCP^T &#x3D; \Lambda &#x3D;<br>\begin{pmatrix}<br>\lambda_1 \<br>&amp; \lambda_2 \<br>&amp; &amp; \ddots \<br>&amp; &amp; &amp; \lambda_n<br>\end{pmatrix}<br>$$</p><blockquote><p>结论：一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量<br>$$<br>E &#x3D; \begin{pmatrix} e_1 &amp; e_2 &amp; \cdots &amp; e_n\end{pmatrix}<br>$$<br>实对称矩阵可以进行对角化：<br>$$<br>ECE^T &#x3D; \Lambda &#x3D;<br>\begin{pmatrix}<br>\lambda_1 \<br>&amp; \lambda_2 \<br>&amp; &amp; \ddots \<br>&amp; &amp; &amp; \lambda_n<br>\end{pmatrix}<br>$$</p></blockquote><p>将特征值从大到小排列，用前K行组成的矩阵乘原始数据矩阵X，就得到降维后的数据矩阵Y。</p><h2 id="4-示例"><a href="#4-示例" class="headerlink" title="4 示例"></a>4 示例</h2><h1 id="数据（共5个数据，每个数据2个特征点）-begin-pmatrix-1-1-0-2-0-2-0-0-1-1-end-pmatrix-协方差矩阵-C-frac-1-5-begin-pmatrix-1-1-0-2-0-2-0-0-1-1-end-pmatrix-begin-pmatrix-1-2-1-0-0-0-2-1-0-1-end-pmatrix"><a href="#数据（共5个数据，每个数据2个特征点）-begin-pmatrix-1-1-0-2-0-2-0-0-1-1-end-pmatrix-协方差矩阵-C-frac-1-5-begin-pmatrix-1-1-0-2-0-2-0-0-1-1-end-pmatrix-begin-pmatrix-1-2-1-0-0-0-2-1-0-1-end-pmatrix" class="headerlink" title="数据（共5个数据，每个数据2个特征点）$$\begin{pmatrix}-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{pmatrix}$$协方差矩阵$$C &#x3D; \frac{1}{5}\begin{pmatrix}-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{pmatrix}\begin{pmatrix}-1 &amp; -2 \-1 &amp; 0 \0 &amp; 0 \2 &amp; 1 \0 &amp; 1\end{pmatrix}"></a>数据（共5个数据，每个数据2个特征点）<br>$$<br>\begin{pmatrix}<br>-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\end{pmatrix}<br>$$<br>协方差矩阵<br>$$<br>C &#x3D; \frac{1}{5}<br>\begin{pmatrix}<br>-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\end{pmatrix}<br>\begin{pmatrix}<br>-1 &amp; -2 \<br>-1 &amp; 0 \<br>0 &amp; 0 \<br>2 &amp; 1 \<br>0 &amp; 1<br>\end{pmatrix}</h1><p>\begin{pmatrix}<br>\frac{6}{5} &amp; \frac{4}{5} \<br>\frac{4}{5} &amp; \frac{6}{5}<br>\end{pmatrix}<br>$$<br>特征值<br>$$<br>\lambda_1 &#x3D; 2, \lambda_2 &#x3D; \frac{2}{5}<br>$$<br>特征向量<br>$$<br>c_1<br>\begin{pmatrix}<br>1 \<br>1<br>\end{pmatrix} ,<br>c_2<br>\begin{pmatrix}<br>-1 \<br>1<br>\end{pmatrix}<br>$$</p><blockquote><p>我们求特征值与特征向量的时候，就是为了求矩阵A能使哪些向量（特征向量）只发生伸缩变换，而变换的程度可以用特征值λ表示。</p></blockquote><h1 id="对角化，我们要降成1维，选择（选择前1大）最大特征值对应的特征向量-c-1-这个-PCP-T-begin-pmatrix-frac-1-sqrt-2-frac-1-sqrt-2-frac-1-sqrt-2-frac-1-sqrt-2-end-pmatrix-begin-pmatrix-frac-6-5-frac-4-5-frac-4-5-frac-6-5-end-pmatrix-begin-pmatrix-frac-1-sqrt-2-frac-1-sqrt-2-frac-1-sqrt-2-frac-1-sqrt-2-end-pmatrix"><a href="#对角化，我们要降成1维，选择（选择前1大）最大特征值对应的特征向量-c-1-这个-PCP-T-begin-pmatrix-frac-1-sqrt-2-frac-1-sqrt-2-frac-1-sqrt-2-frac-1-sqrt-2-end-pmatrix-begin-pmatrix-frac-6-5-frac-4-5-frac-4-5-frac-6-5-end-pmatrix-begin-pmatrix-frac-1-sqrt-2-frac-1-sqrt-2-frac-1-sqrt-2-frac-1-sqrt-2-end-pmatrix" class="headerlink" title="对角化，我们要降成1维，选择（选择前1大）最大特征值对应的特征向量$c_1$这个$$PCP^T &#x3D;\begin{pmatrix}\frac{1}{\sqrt 2} &amp; \frac{1}{\sqrt 2} \-\frac{1}{\sqrt 2} &amp; \frac{1}{\sqrt 2}\end{pmatrix}\begin{pmatrix}\frac{6}{5} &amp; \frac{4}{5} \\frac{4}{5} &amp; \frac{6}{5}\end{pmatrix}\begin{pmatrix}\frac{1}{\sqrt 2} &amp; -\frac{1}{\sqrt 2} \\frac{1}{\sqrt 2} &amp; \frac{1}{\sqrt 2}\end{pmatrix}"></a>对角化，我们要降成1维，选择（选择前1大）最大特征值对应的特征向量$c_1$这个<br>$$<br>PCP^T &#x3D;<br>\begin{pmatrix}<br>\frac{1}{\sqrt 2} &amp; \frac{1}{\sqrt 2} \<br>-\frac{1}{\sqrt 2} &amp; \frac{1}{\sqrt 2}<br>\end{pmatrix}<br>\begin{pmatrix}<br>\frac{6}{5} &amp; \frac{4}{5} \<br>\frac{4}{5} &amp; \frac{6}{5}<br>\end{pmatrix}<br>\begin{pmatrix}<br>\frac{1}{\sqrt 2} &amp; -\frac{1}{\sqrt 2} \<br>\frac{1}{\sqrt 2} &amp; \frac{1}{\sqrt 2}<br>\end{pmatrix}</h1><h1 id="begin-pmatrix-2-0-0-frac-2-5-end-pmatrix-降维-Y-begin-pmatrix-frac-1-sqrt-2-frac-1-sqrt-2-end-pmatrix-begin-pmatrix-1-1-0-2-0-2-0-0-1-1-end-pmatrix"><a href="#begin-pmatrix-2-0-0-frac-2-5-end-pmatrix-降维-Y-begin-pmatrix-frac-1-sqrt-2-frac-1-sqrt-2-end-pmatrix-begin-pmatrix-1-1-0-2-0-2-0-0-1-1-end-pmatrix" class="headerlink" title="\begin{pmatrix}2 &amp; 0 \0 &amp; \frac{2}{5}\end{pmatrix}$$降维$$Y &#x3D;\begin{pmatrix}\frac{1}{\sqrt 2} &amp; \frac{1}{\sqrt 2}\end{pmatrix}\begin{pmatrix}-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{pmatrix}"></a>\begin{pmatrix}<br>2 &amp; 0 \<br>0 &amp; \frac{2}{5}<br>\end{pmatrix}<br>$$<br>降维<br>$$<br>Y &#x3D;<br>\begin{pmatrix}<br>\frac{1}{\sqrt 2} &amp; \frac{1}{\sqrt 2}<br>\end{pmatrix}<br>\begin{pmatrix}<br>-1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \<br>-2 &amp; 0 &amp; 0 &amp; 1 &amp; 1<br>\end{pmatrix}</h1><p>\begin{pmatrix}<br>-\frac{3}{\sqrt 2} &amp; -\frac{1}{\sqrt 2} &amp; 0 &amp; \frac{3}{\sqrt 2} &amp; -\frac{1}{\sqrt 2}<br>\end{pmatrix}<br>$$</p><blockquote><p>PCA降维可参考：<a href="https://zhuanlan.zhihu.com/p/37777074">https://zhuanlan.zhihu.com/p/37777074</a></p><p>机器学习实战参考：<a href="https://blog.csdn.net/weixin_42600072/category_8751294.html">https://blog.csdn.net/weixin_42600072/category_8751294.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习总结 </tag>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch入门知识总结</title>
      <link href="/p/1888017128.html"/>
      <url>/p/1888017128.html</url>
      
        <content type="html"><![CDATA[<h1 id="Pytorch深度学习入门知识总结"><a href="#Pytorch深度学习入门知识总结" class="headerlink" title="Pytorch深度学习入门知识总结"></a>Pytorch深度学习入门知识总结</h1><h1 id="GPU相关"><a href="#GPU相关" class="headerlink" title="GPU相关"></a>GPU相关</h1><p>检查GPU是否工作</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure><h1 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h1><p>可以继承Dataset来制作自己的数据类</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    For example:</span></span><br><span class="line"><span class="string">    root_dir: D:/code/data</span></span><br><span class="line"><span class="string">    label_dir: ants</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        <span class="comment"># 图片根路径</span></span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        <span class="comment"># 图片标签名称</span></span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        <span class="comment"># 数据根路径 + 标签名（标签下存有对应的图片）</span></span><br><span class="line">        self.path = os.path.join(root_dir,label_dir)</span><br><span class="line">        <span class="comment"># 获取文件夹下的所有文件名，生成列表</span></span><br><span class="line">        self.img_path = os.listdir(self.path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        img_name = self.img_path[idx]</span><br><span class="line">        img_item_path = os.path.join(self.path,img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)</span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path)</span><br></pre></td></tr></table></figure><p>可以使用使用数组中的索引操作等</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flower_photos下有多个目录，每个目录的名称都是数据的标签,然后每个目录下都有该标签的对应数据</span></span><br><span class="line">root_dir = <span class="string">&quot;D:\\code\\data\\flower_photos&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># daisy数据集</span></span><br><span class="line">daisy_label_dir = <span class="string">&quot;daisy&quot;</span></span><br><span class="line">daisy_dataset = MyData(root_dir, daisy_label_dir)</span><br><span class="line"><span class="comment"># roses数据集</span></span><br><span class="line">roses_label_dir = <span class="string">&quot;roses&quot;</span></span><br><span class="line">roses_dataset = MyData(root_dir, roses_label_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以进行数据集合并操作</span></span><br><span class="line">dataset = daisy_dataset + roses_dataset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以进行索引索引操作，取最后一个数据</span></span><br><span class="line">roses_img , label = dataset[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回的数据roses_img是PIL类型</span></span><br></pre></td></tr></table></figure><h1 id="Tensorboard"><a href="#Tensorboard" class="headerlink" title="Tensorboard"></a>Tensorboard</h1><p>初始化</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)  <span class="comment"># 在当前目录logs目录下生成文件</span></span><br></pre></td></tr></table></figure><p>最后需要对writter进行关闭</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer.close()</span><br></pre></td></tr></table></figure><p>可视化查看文件，在当前CMD工作目录下（必须具有对应的python环境）输入以下命令打开</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir=logs</span><br></pre></td></tr></table></figure><p>或者添加参数指定打开端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir=logs --port=6006</span><br></pre></td></tr></table></figure><h2 id="1-添加单张图片"><a href="#1-添加单张图片" class="headerlink" title="1 添加单张图片"></a>1 添加单张图片</h2><p>添加<code>ndarray</code>型图片</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image_path = <span class="string">&quot;./flower_photos/daisy/5673728_71b8cb57eb.jpg&quot;</span> <span class="comment">#  用户需要自己设置成电脑上图片的路径</span></span><br><span class="line"><span class="comment"># 打开图片，转化为PIL类型</span></span><br><span class="line">img_PIL = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line"><span class="comment"># 将PIL类型图片转化为numpy型图片</span></span><br><span class="line">img_array = np.array(img_PIL)</span><br><span class="line"><span class="comment"># shape为HWC(高 宽 颜色)</span></span><br><span class="line"><span class="built_in">print</span>(img_array.shape)  <span class="comment"># (332, 500, 3)</span></span><br><span class="line"><span class="comment"># title 传入图片  步长  shape形式</span></span><br><span class="line">writer.add_image(<span class="string">&quot;ndarray&quot;</span>, img_array, global_step=<span class="number">1</span>, dataformats=<span class="string">&quot;HWC&quot;</span>)</span><br></pre></td></tr></table></figure><p>添加<code>tensor</code>类型图片</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image_path = <span class="string">&quot;./flower_photos/daisy/5673728_71b8cb57eb.jpg&quot;</span> <span class="comment">#  用户需要自己设置成电脑上图片的路径</span></span><br><span class="line">img_PIL = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line">trans_totensor = transforms.ToTensor()</span><br><span class="line">tensor_img = trans_totensor(img_PIL)</span><br><span class="line">writer.add_image(<span class="string">&quot;tensor&quot;</span>, tensor_img)</span><br></pre></td></tr></table></figure><h2 id="2-添加公式图像"><a href="#2-添加公式图像" class="headerlink" title="2 添加公式图像"></a>2 添加公式图像</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加函数图像,显示函数图像</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># 标题 y轴 x轴</span></span><br><span class="line">writer.add_scalar(<span class="string">&quot;y = x&quot;</span>, i, i)  <span class="comment"># value, step</span></span><br></pre></td></tr></table></figure><h2 id="3-添加多个图片"><a href="#3-添加多个图片" class="headerlink" title="3 添加多个图片"></a>3 添加多个图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图片已经通过transform转变为tensor类型，transform可见下文</span></span><br><span class="line">test_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor())</span><br><span class="line">test_loader = DataLoader(dataset=test_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>, drop_last=<span class="literal">False</span>)</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    writer.add_images(<span class="string">&quot;epoch&quot;</span>, imgs, step)  <span class="comment"># 将64张图片添加进去</span></span><br><span class="line">    step = step + <span class="number">1</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h1 id="Transforms"><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;./flower_photos/daisy/5673728_71b8cb57eb.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="1-ToTensor"><a href="#1-ToTensor" class="headerlink" title="1 ToTensor"></a>1 ToTensor</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trans_totensor = transforms.ToTensor()</span><br><span class="line">tensor_img = trans_totensor(img)</span><br><span class="line">writer.add_image(<span class="string">&quot;tensor&quot;</span>, tensor_img)</span><br></pre></td></tr></table></figure><h2 id="2-Normalize归一化"><a href="#2-Normalize归一化" class="headerlink" title="2 Normalize归一化"></a>2 Normalize归一化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># output[channel] = (input[channel] - mean[channel]) / std[channel] （输入 - 平均值） / 标准差</span></span><br><span class="line"><span class="comment"># 下例：(input - 0.5) / 0.5 = 2 * input - 1</span></span><br><span class="line">trans_norm = transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">img_norm = trans_norm(tensor_img)</span><br><span class="line"><span class="built_in">print</span>(img_norm[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">writer.add_image(<span class="string">&quot;Normalize&quot;</span>, img_norm, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="3-Resize"><a href="#3-Resize" class="headerlink" title="3 Resize"></a>3 Resize</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># print(img.size)  PIL图片类型具有size属性</span></span><br><span class="line"><span class="comment"># 改变图片的大小</span></span><br><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>, <span class="number">512</span>))</span><br><span class="line">img_resize = trans_resize(img)</span><br><span class="line">img_resize = trans_totensor(img_resize)</span><br><span class="line">writer.add_image(<span class="string">&quot;resize&quot;</span>, img_resize, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="4-Compose"><a href="#4-Compose" class="headerlink" title="4 Compose"></a>4 Compose</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将transform操作组合起来</span></span><br><span class="line">trans_resize_2 = transforms.Resize(<span class="number">512</span>)</span><br><span class="line"><span class="comment"># PIL -&gt; PIL -&gt; Tensor</span></span><br><span class="line">trans_compose = transforms.Compose([trans_resize_2, trans_totensor])</span><br><span class="line">img_resize_2 = trans_compose(img)</span><br><span class="line">writer.add_image(<span class="string">&quot;resize&quot;</span>, img_resize_2, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="5-RandomCrop"><a href="#5-RandomCrop" class="headerlink" title="5 RandomCrop"></a>5 RandomCrop</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机裁剪</span></span><br><span class="line">trans_random = transforms.RandomCrop((<span class="number">100</span>, <span class="number">100</span>))  <span class="comment"># 随机裁剪成100×100大小的图片</span></span><br><span class="line">trans_compose_2 = transforms.Compose([trans_random, trans_totensor])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    img_crop = trans_compose_2(img)</span><br><span class="line">    writer.add_image(<span class="string">&quot;RandomCrop&quot;</span>, img_crop, i)</span><br></pre></td></tr></table></figure><h1 id="Torchvision"><a href="#Torchvision" class="headerlink" title="Torchvision"></a>Torchvision</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在datasets中获取官方数据集</span></span><br><span class="line">train_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">True</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                          download=<span class="literal">True</span>)</span><br><span class="line">test_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                         download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h1 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h1><p>加载对应的数据集，可以对数据集进行打包，<code>batch_size</code> 指一次打包多少张图片。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载数据集 打包数据,压缩数据 为网络提供不同的数据形式</span></span><br><span class="line">train_dataloader = DataLoader(train_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br></pre></td></tr></table></figure><p>可以对加载后的数据集进行<code>len</code>操作，数据集可迭代，迭代时的单个元素返回的是<strong>数据</strong>和<strong>label</strong>（都是以CIFAR10数据集为例）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> imgs, targets <span class="keyword">in</span> train_dataloader:</span><br><span class="line">    <span class="comment"># imgs 为64张tensor类型的图片（进行上述操作之后）</span></span><br><span class="line">    <span class="comment"># targets 为64张图片对应的标签label值</span></span><br></pre></td></tr></table></figure><h1 id="损失函数和反向传播"><a href="#损失函数和反向传播" class="headerlink" title="损失函数和反向传播"></a>损失函数和反向传播</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss_fn = torch.nn.CrossEntropyLoss()</span><br><span class="line">outputs = model(imgs)</span><br><span class="line"><span class="comment"># 计算loss误差</span></span><br><span class="line">loss = loss_fn(outputs, targets)</span><br><span class="line"><span class="comment"># 反向传播</span></span><br><span class="line">loss.backward()</span><br></pre></td></tr></table></figure><h1 id="GPU训练"><a href="#GPU训练" class="headerlink" title="GPU训练"></a>GPU训练</h1><p>网络模型，损失函数，输入数据都要<code>to(device)</code>，见下面<code>CIFAR10</code>图片分类代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取训练设备</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"><span class="comment"># 例</span></span><br><span class="line">model = MyModel()</span><br><span class="line">model.to(device)</span><br></pre></td></tr></table></figure><h1 id="CIFAR10图片分类练习"><a href="#CIFAR10图片分类练习" class="headerlink" title="CIFAR10图片分类练习"></a>CIFAR10图片分类练习</h1><p>model.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyModel, self).__init__()</span><br><span class="line">        self.model = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Flatten(),</span><br><span class="line">            nn.Linear(<span class="number">64</span> * <span class="number">4</span> * <span class="number">4</span>, <span class="number">64</span>),</span><br><span class="line">            nn.Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>train.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> MyModel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用对应设备进行训练</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每一个 img数据 和 label</span></span><br><span class="line"><span class="comment"># 训练数据集</span></span><br><span class="line">train_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset/CIFAR&quot;</span>, train=<span class="literal">True</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                          download=<span class="literal">True</span>)</span><br><span class="line">test_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset/CIFAR&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                         download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练数据集长度为:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(train_data)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试数据集长度为:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(test_data)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集 打包数据,压缩数据 为网络提供不同的数据形式</span></span><br><span class="line">train_dataloader = DataLoader(train_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">model = MyModel()</span><br><span class="line">model.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss_fn = torch.nn.CrossEntropyLoss()</span><br><span class="line">loss_fn.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置优化器</span></span><br><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置网络训练参数</span></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line">epoch = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;./logs/scalar&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----开始第&#123;&#125;轮训练----&quot;</span>.<span class="built_in">format</span>(i + <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 训练开始 对指定的层才有作用</span></span><br><span class="line">    model.train()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        <span class="comment"># 获取数据</span></span><br><span class="line">        imgs, targets = data</span><br><span class="line">        <span class="comment"># 转换训练设备</span></span><br><span class="line">        imgs, targets = imgs.to(device), targets.to(device)</span><br><span class="line"></span><br><span class="line">        outputs = model(imgs)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算loss误差</span></span><br><span class="line">        loss = loss_fn(outputs, targets)</span><br><span class="line">        <span class="comment"># 清空梯度</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment"># 反向传播</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> total_train_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;训练次数：&#123;&#125;,loss值：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_train_step, loss.item()))  <span class="comment"># 添加item是直接输出tensor对应的数字，不加输出tenso类型的数字</span></span><br><span class="line">            writer.add_scalar(<span class="string">&quot;train_loss&quot;</span>, loss.item(), total_train_step)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每次训练一轮后跑一边测试</span></span><br><span class="line">    <span class="comment"># 验证测试</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">    total_test_loss = <span class="number">0</span></span><br><span class="line">    total_accuracy = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 网络模型中的梯度都没有， 不发生变化</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> img, target <span class="keyword">in</span> test_data:</span><br><span class="line">            img = torch.reshape(img, (<span class="number">1</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>))</span><br><span class="line">            target = torch.tensor([target])</span><br><span class="line"></span><br><span class="line">            img, target = img.to(device), target.to(device)</span><br><span class="line">            <span class="comment"># 计算输出</span></span><br><span class="line">            output = model(img)</span><br><span class="line">            loss = loss_fn(output, target)</span><br><span class="line">            total_test_loss = total_test_loss + loss.item()</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            outputs:[0.1, 0.2] 两个类别的概率</span></span><br><span class="line"><span class="string">                    [0.3, 0.4]</span></span><br><span class="line"><span class="string">            targets:[0, 1] 目标类别</span></span><br><span class="line"><span class="string">            predict:[1, 1] 预测类别</span></span><br><span class="line"><span class="string">            result :[False, True]</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># argmax求横向最大值所在的位置</span></span><br><span class="line">            accuracy = (output.argmax(<span class="number">1</span>) == target).<span class="built_in">sum</span>()</span><br><span class="line">            total_accuracy = total_accuracy + accuracy</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集的loss：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_test_loss))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体正确率：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_accuracy / <span class="built_in">len</span>(test_data)))</span><br><span class="line"></span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_loss&quot;</span>, total_test_loss, total_test_step)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_accuracy&quot;</span>, total_accuracy / <span class="built_in">len</span>(test_data), total_test_step)</span><br><span class="line"></span><br><span class="line">    total_test_step = total_test_step + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存每一轮的模型</span></span><br><span class="line">    torch.save(model, <span class="string">&quot;./weights/model&#123;&#125;.pth&quot;</span>.<span class="built_in">format</span>(i + <span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 也可以方式二</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模型已保存&quot;</span>)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><p>read_data.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label</span>):</span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label = label</span><br><span class="line">        self.path = os.path.join(root_dir, label)</span><br><span class="line">        self.img_names = os.listdir(self.path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        img_name = self.img_names[index]</span><br><span class="line">        img_path = os.path.join(self.path, img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">        label = self.label</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_names)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>test.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> model <span class="keyword">import</span> MyModel</span><br><span class="line"><span class="keyword">from</span> read_data <span class="keyword">import</span> MyData</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">ans = [<span class="string">&quot;airplane&quot;</span>, <span class="string">&quot;automobile&quot;</span>, <span class="string">&quot;bird&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;deer&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;frog&quot;</span>, <span class="string">&quot;horse&quot;</span>, <span class="string">&quot;ship&quot;</span>, <span class="string">&quot;truck&quot;</span>]</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&quot;D:\\code\\pytorch_learning\\CIFAR10\\dataset\\val&quot;</span></span><br><span class="line">labels_dir = os.listdir(root_dir)</span><br><span class="line"></span><br><span class="line">trans = torchvision.transforms.Compose([torchvision.transforms.Resize((<span class="number">32</span>, <span class="number">32</span>)),</span><br><span class="line">                                        torchvision.transforms.ToTensor()])</span><br><span class="line"></span><br><span class="line">model = torch.load(<span class="string">&quot;./weights/model67.8.pth&quot;</span>)</span><br><span class="line"></span><br><span class="line">tot_num = <span class="number">0</span></span><br><span class="line">tot_accuracy = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> labels_dir:</span><br><span class="line">    cur_accuracy = <span class="number">0</span></span><br><span class="line">    myData = MyData(root_dir, label)</span><br><span class="line">    tot_num += <span class="built_in">len</span>(myData)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----------当前的图片类型为: &#123;&#125; ----------&quot;</span>.<span class="built_in">format</span>(label))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> img, t_label <span class="keyword">in</span> myData:</span><br><span class="line">        <span class="comment"># 将图片转换为为torch.Size([3, 32, 32])</span></span><br><span class="line">        img = trans(img)</span><br><span class="line">        <span class="comment"># img = img.convert(&quot;RGB&quot;)</span></span><br><span class="line">        img = torch.reshape(img, (<span class="number">1</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>))</span><br><span class="line">        img = img.to(device)</span><br><span class="line"></span><br><span class="line">        model.<span class="built_in">eval</span>()</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            output = model(img)</span><br><span class="line"></span><br><span class="line">        predict_result = ans[output.argmax(<span class="number">1</span>).item()]</span><br><span class="line">        cur_accuracy += (predict_result == label)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;预测结果: &#123;&#125;  &quot;</span>.<span class="built_in">format</span>(predict_result), <span class="string">&quot;正确&quot;</span> <span class="keyword">if</span> predict_result == label <span class="keyword">else</span> <span class="string">&quot;错误&quot;</span>)</span><br><span class="line"></span><br><span class="line">    tot_accuracy += cur_accuracy</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前种类预测准确率为: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(cur_accuracy / <span class="built_in">len</span>(myData)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;总预测准确率为: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(tot_accuracy / tot_num))</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>所有代码： <a href="https://github.com/anda522/CIFAR10">https://github.com/anda522/CIFAR10</a></p><p>参考视频：<a href="https://www.bilibili.com/video/BV1hE411t7RN/">https://www.bilibili.com/video/BV1hE411t7RN/</a></p><p>参考Pytorch文档：<a href="https://pytorch.org/docs/stable/nn.html">https://pytorch.org/docs/stable/nn.html</a></p></blockquote><p><img src="https://wyqz.top/medias/gzh.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022牛客多校补题3</title>
      <link href="/p/3182360886.html"/>
      <url>/p/3182360886.html</url>
      
        <content type="html"><![CDATA[<h1 id="2022牛客多校3补题"><a href="#2022牛客多校3补题" class="headerlink" title="2022牛客多校3补题"></a><a href="https://ac.nowcoder.com/acm/contest/33188">2022牛客多校3补题</a></h1><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><blockquote><p>给出两棵编号 $1-n$ 的树A和B，A和B树上每个节点均有一个权值，给出 $k$ 个关键点</p><p>的编号 $x_1…x_n$ ，问有多少种方案使得去掉恰好一个关键点使得剩余关键点在树A上</p><p>LCA的权值大于树B上LCA的权值</p></blockquote><p>观察和不断模拟可以发现一系列的点的LCA可以通过前缀LCA实现。</p><p>故预处理出关键点序列的在树A B上的前缀LCA和后缀LCA，枚举去掉的关键节点并使用前后缀LCA算出剩余节点的LCA比较权值即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &lt; b) a = b; &#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; sz, top, dep, parent, in;</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; e;</span><br><span class="line">    <span class="built_in">Tree</span>(<span class="type">int</span> n) : <span class="built_in">sz</span>(n), <span class="built_in">top</span>(n), <span class="built_in">dep</span>(n), <span class="built_in">parent</span>(n, <span class="number">-1</span>), <span class="built_in">e</span>(n), <span class="built_in">in</span>(n), <span class="built_in">cur</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfsSz</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfsHLD</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfsSz</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[u] != <span class="number">-1</span>)</span><br><span class="line">            e[u].<span class="built_in">erase</span>(std::<span class="built_in">find</span>(e[u].<span class="built_in">begin</span>(), e[u].<span class="built_in">end</span>(), parent[u]));</span><br><span class="line">        sz[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;v : e[u]) &#123;</span><br><span class="line">            parent[v] = u;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfsSz</span>(v);</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">            <span class="keyword">if</span> (sz[v] &gt; sz[e[u][<span class="number">0</span>]])</span><br><span class="line">                std::<span class="built_in">swap</span>(v, e[u][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfsHLD</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        in[u] = cur++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == e[u][<span class="number">0</span>]) &#123;</span><br><span class="line">                top[v] = top[u];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                top[v] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfsHLD</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">                u = parent[top[u]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = parent[top[v]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dep[u] &lt; dep[v]) &#123;</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="function">vi <span class="title">x</span><span class="params">(k)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x[i];</span><br><span class="line">x[i]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">A</span><span class="params">(n)</span>, <span class="title">B</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vi <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line">cin &gt;&gt; p;</span><br><span class="line">p--;</span><br><span class="line">A.<span class="built_in">addEdge</span>(i, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vi <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">cin &gt;&gt; b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line">cin &gt;&gt; p;</span><br><span class="line">p--;</span><br><span class="line">B.<span class="built_in">addEdge</span>(i, p);</span><br><span class="line">&#125;</span><br><span class="line">A.<span class="built_in">init</span>();</span><br><span class="line">B.<span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">prea</span><span class="params">(k)</span>, <span class="title">sufa</span><span class="params">(k)</span>, <span class="title">preb</span><span class="params">(k)</span>, <span class="title">sufb</span><span class="params">(k)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">prea[i] = preb[i] = x[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">prea[i] = A.<span class="built_in">lca</span>(prea[i - <span class="number">1</span>], x[i]);</span><br><span class="line">preb[i] = B.<span class="built_in">lca</span>(preb[i - <span class="number">1</span>], x[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == k - <span class="number">1</span>)</span><br><span class="line">sufa[i] = sufb[i] = x[i];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sufa[i] = A.<span class="built_in">lca</span>(sufa[i + <span class="number">1</span>], x[i]);</span><br><span class="line">sufb[i] = B.<span class="built_in">lca</span>(sufb[i + <span class="number">1</span>], x[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[sufa[i + <span class="number">1</span>]] &gt; b[sufb[i + <span class="number">1</span>]])</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == k - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[prea[i - <span class="number">1</span>]] &gt; b[preb[i -  <span class="number">1</span>]])</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> va = A.<span class="built_in">lca</span>(prea[i - <span class="number">1</span>], sufa[i + <span class="number">1</span>]);</span><br><span class="line"><span class="type">int</span> vb = B.<span class="built_in">lca</span>(preb[i - <span class="number">1</span>], sufb[i + <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(a[va] &gt; b[vb])</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote><p>题意： 给定n个字符串，求一个将他们拼接起来的方案，使得结果的字典序最小。</p></blockquote><p>对$n$个字符串排序， $a$ 在 $b$ 前面的条件是 $a + b &lt; b + a$ </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>() + <span class="number">1</span>, s.<span class="built_in">end</span>(), [](string a, string b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cout &lt;&lt; s[i];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><blockquote><p>给定一个n个点m条边的无向图，每次询问两点x, y，求是否存在一个n的排列，使得第一个元素为x，最后一个元素为y，且排列的任意一个前缀、任意一个后</p><p>缀都连通</p></blockquote><p>考虑一条链，那么两端的顶点是满足情况的，如果是其他的两个点那么不满足情况。</p><p>考虑一个环，发现环中的任意两个点都满足情况。</p><p>考虑一个图，图中可能存在环。</p><p>那么对所有的点双缩点之后，必须是一条链，如果不是一条链就不能满足。首先通过tarjan求出割点以及点双。</p><p>如果图本身就不连通（即有多个连通块），不满足。</p><p>如果点双等于1，即是一个环，满足。</p><p>接下来是对于一般的连通图，我们对于边界处的点双进行赋值，第一个边界处点双非割点全部赋为1，第二个边界处点双中非割点全部赋为2，那么询问时，如果两个点的值加和是3，即可以满足要求。</p><p>主要是如何判断是否是处于边界的点双，边界处的点双，那么此点双中的割点所在点双只有2个，不能有多个，如果有多个，必然不是在边界（因为存在一个割点至少则会存在两个点双）。</p><p>代码中为什么没有 $d &#x3D; 2$</p><p>因为存在以下情况：</p><p><img src="/3182360886/image-20220907221918311.png" alt="满足的情况"></p><p>上图是满足情况的，中间的点双连通分量的 $d &#x3D; 2$ ，但是边界1和6点都已经确定了，可以通过边界确定是否满足情况。</p><p><img src="/3182360886/image-20220907222225218.png" alt="不满足的情况"></p><p>上图是不满足情况的，中间的点双中 $d &#x3D; 2$，但是边界也可以确定，同样可以通过边界来判断是否满足情况。</p><p>那么其他情况也是如此，都是可以通过边界点双连通分量来判断， $d &#x3D; 2$ 因为牵扯到有满足情况和不满足情况的，暂不考虑（但是他们可以通过边界点双来判断）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &lt; b) a = b; &#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum[i] 是点i所在点双连通分量的个数</span></span><br><span class="line"><span class="comment">// ans[i] 是点i所在第几个边界的点双连通分量中</span></span><br><span class="line"><span class="type">int</span> low[N], dfn[N], stk[N], top, ts, dcc_cnt, root = <span class="number">1</span>, sum[N], ans[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dcc[N], e[N];</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++ts;</span><br><span class="line">stk[++top] = u;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : e[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line"><span class="keyword">if</span>(dfn[u] &lt;= low[v])</span><br><span class="line">&#123;</span><br><span class="line">flag++;</span><br><span class="line">dcc_cnt++;</span><br><span class="line"><span class="keyword">if</span>(u != root || flag &gt; <span class="number">1</span>) cut[u] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">x = stk[top--];</span><br><span class="line">sum[x]++;</span><br><span class="line">dcc[dcc_cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;<span class="keyword">while</span>(x != v);</span><br><span class="line">dcc[dcc_cnt].<span class="built_in">push_back</span>(u);</span><br><span class="line">sum[u]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> is = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; is; i++)</span><br><span class="line"><span class="keyword">if</span>(!dfn[i])</span><br><span class="line">is = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(is &amp;&amp; dcc_cnt != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= dcc_cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> d = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : dcc[i])</span><br><span class="line"><span class="keyword">if</span>(cut[x]) d += sum[x] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(d &gt; <span class="number">2</span>) is = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(d == <span class="number">1</span>) <span class="comment">// 端点处的点双</span></span><br><span class="line">&#123;</span><br><span class="line">id++; <span class="comment">// 端点处点双个数加1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : dcc[i])</span><br><span class="line"><span class="keyword">if</span>(!cut[x])</span><br><span class="line">ans[x] = id; <span class="comment">// 此点双中非割点赋值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">while</span>(q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="keyword">if</span>(!is) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dcc_cnt == <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ans[x] + ans[y] == <span class="number">3</span>) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><blockquote><p>给出长度为 $n$ 的小写字符串A和 $k$ 个长度为 $m$ 的小写字符串 $B_1…B_k$ ，B的每个位置拥有统一的权值 $v_1…v_m$ ，对于每个 $B_i$ 求最大和区间满足该区间构成的字符串是A的子串（空区间合法）。</p></blockquote><p>可以将问题进行转化，相当于对 $B_i$ 的每个位置求出它作为结束位置在 A 中的最长子串长度，然后在该区间求最大子段和，所有位置的最大值即为答案。</p><p>对于每个位置的最长子串，可以对 A 建后缀自动机，然后 $B_i$ 从左往右在A的后缀自动机上转移，如果当前节点无法转移则跳至父亲节点（表示去掉一个前缀字符再次进行匹配），最后无法转移则长度为 0 ，转移成功则为转移前节点的最大长度<strong>加一</strong>。</p><p>最大子段和可以通过前缀和与ST表求，B中满足是A的子串的区间为 $[l, r]$ 时， 则最大子段和可以通过 $s[r] - min(s[j]), l \leq j \lt r$ 不断进行更新。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &lt; b) a = b; &#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixAutomaton</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> ALPHABET_SIZE = <span class="number">26</span>, N = <span class="number">1e5</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> link;</span><br><span class="line">        <span class="type">int</span> next[ALPHABET_SIZE];</span><br><span class="line">        <span class="built_in">Node</span>() : <span class="built_in">len</span>(<span class="number">0</span>), <span class="built_in">link</span>(<span class="number">0</span>), next&#123;&#125; &#123;&#125;</span><br><span class="line">    &#125; t[<span class="number">2</span> * N];</span><br><span class="line">    <span class="type">int</span> cntNodes;</span><br><span class="line">    <span class="built_in">SuffixAutomaton</span>() &#123;</span><br><span class="line">        cntNodes = <span class="number">1</span>;</span><br><span class="line">        std::<span class="built_in">fill</span>(t[<span class="number">0</span>].next, t[<span class="number">0</span>].next + ALPHABET_SIZE, <span class="number">1</span>);</span><br><span class="line">        t[<span class="number">0</span>].len = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : s)</span><br><span class="line">            p = <span class="built_in">extend</span>(p, x - <span class="string">&#x27;a&#x27;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[p].next[c]) &#123;</span><br><span class="line">            <span class="type">int</span> q = t[p].next[c];</span><br><span class="line">            <span class="keyword">if</span> (t[q].len == t[p].len + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            <span class="type">int</span> r = ++cntNodes;</span><br><span class="line">            t[r].len = t[p].len + <span class="number">1</span>;</span><br><span class="line">            t[r].link = t[q].link;</span><br><span class="line">            std::<span class="built_in">copy</span>(t[q].next, t[q].next + ALPHABET_SIZE, t[r].next);</span><br><span class="line">            t[q].link = r;</span><br><span class="line">            <span class="keyword">while</span> (t[p].next[c] == q) &#123;</span><br><span class="line">                t[p].next[c] = r;</span><br><span class="line">                p = t[p].link;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cur = ++cntNodes;</span><br><span class="line">        t[cur].len = t[p].len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!t[p].next[c]) &#123;</span><br><span class="line">            t[p].next[c] = cur;</span><br><span class="line">            p = t[p].link;</span><br><span class="line">        &#125;</span><br><span class="line">        t[cur].link = <span class="built_in">extend</span>(p, c);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sam;</span><br><span class="line"></span><br><span class="line">ll f[N][<span class="number">30</span>], a[N];</span><br><span class="line"><span class="type">int</span> lg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lg[i] = lg[i - <span class="number">1</span>] + (i &amp; (i - <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        f[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lg[n]; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    </span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    sam.<span class="built_in">init</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>(m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        string t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        t = <span class="string">&quot; &quot;</span> + t;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c = t[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(p &amp;&amp; !sam.t[p].next[c])</span><br><span class="line">                p = sam.t[p].link, l = sam.t[p].len;</span><br><span class="line">            <span class="keyword">if</span>(p)</span><br><span class="line">            &#123;</span><br><span class="line">                p = sam.t[p].next[c], l++;</span><br><span class="line">                <span class="built_in">Max</span>(ans, a[i] - <span class="built_in">query</span>(i - l, i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> p = <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><blockquote><p>给定一个城市有若干十字路口，右转不需要等红灯，直行、左转和掉头都需要，求起</p><p>点到终点最少等几次红灯</p></blockquote><p>把每条路看做点，十字路口处连边，形成一个边权为0&#x2F;1的有向图。</p><p>可以使用<code>dijkstra</code>求最短路。</p><p>同时也可以用<code>01BFS</code>解决，此时使用deque维护队列，边权为0时入队头，边权为1时入队尾。</p><p>无论一个路口四个方向怎么给，因为都是按照逆时针方向给出的，所以所有路的相对关系都可以得到，每走到一个路口，都会知道当前路口的四个方向的情况。</p><p>$dis[i][j]$ 代表从起点的路到达终点路的最小等待数，因为点数过多，将第二维压缩，压缩成四个方向，即到达（ $i$，$i$ 路口的第 $j$ 个方向指向的路口）这条路上。</p><p>队列中存的是路的起始和结束位置，以及到达该路上的最小等待红灯数。</p><blockquote><p>对于01BFS的理解，我们首先扩展的是距离等于0的位置（这样肯定是最优的，没有距离嘛），所以就是先走当前的最短路，然后再扩展有距离的路，也是一层一层的扩展。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &lt; b) a = b; &#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[N][<span class="number">4</span>], to[N][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">cin &gt;&gt; to[i][j];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sx, sy, fx, fy;</span><br><span class="line">cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"></span><br><span class="line">deque&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; dq;</span><br><span class="line">dq.<span class="built_in">push_front</span>(&#123;sx, sy, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="keyword">while</span>(!dq.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t = dq.<span class="built_in">front</span>();</span><br><span class="line">dq.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = t[<span class="number">0</span>], y = t[<span class="number">1</span>], w = t[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!y) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> id = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(to[x][i] == y)</span><br><span class="line">id = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dis[x][id] &gt; w)</span><br><span class="line">dis[x][id] = w;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="keyword">if</span>(to[y][i] == x)</span><br><span class="line">id = (i + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == id)</span><br><span class="line">dq.<span class="built_in">push_front</span>(&#123;y, to[y][i], w&#125;);</span><br><span class="line"><span class="keyword">else</span> dq.<span class="built_in">push_back</span>(&#123;y, to[y][i], w + <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"><span class="keyword">if</span>(to[fx][i] == fy)</span><br><span class="line">id = i;</span><br><span class="line"><span class="keyword">if</span>(dis[fx][id] == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; dis[fx][id] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtCoder Beginner Contest 266 A-G</title>
      <link href="/p/2022907814.html"/>
      <url>/p/2022907814.html</url>
      
        <content type="html"><![CDATA[<h1 id="AtCoder-Beginner-Contest-266-A-G"><a href="#AtCoder-Beginner-Contest-266-A-G" class="headerlink" title="AtCoder Beginner Contest 266 A-G"></a>AtCoder Beginner Contest 266 A-G</h1><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>直接输出字符串中间字符即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &lt; b) a = b; &#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">cout &lt;&lt; s[s.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>令 $m &#x3D; 998244353$ 。<br>$$<br>N - x &#x3D; k \times m, k \in Z<br>$$</p><p>$$<br>x &#x3D; N - k \times m, 0 \leq x \leq m - 1<br>$$</p><p>$$<br>x &#x3D; (N \bmod m + m) \bmod m<br>$$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &lt; b) a = b; &#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="comment">// x = n - k mod</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; (n % mod + mod) % mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>直接暴力判断叉积是否小于等于0即可。</p><blockquote><p>叉积计算的是三角形面积，当在右手系的情况下， 叉积计算出来的值就是三角形的正面积，如果计算出的值为负值，即三角形不存在。</p><p>$A,B,C$ 三个点，$\frac {\overrightarrow {AB} \times \overrightarrow {AC}}{2}$ 即为对应的三角形面积， 只需判断上面分母的叉积是否小于等于 0 即可。两个向量分别为 $(x1, y1),(x2, y2)$ ，则 $S_{\triangle ABC} &#x3D; x1 \cdot y2  - x2 \cdot y1$</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &lt; b) a = b; &#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">vector&lt;pii&gt; <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">cin &gt;&gt; p[i].first &gt;&gt; p[i].second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pii a = &#123;p[(i + <span class="number">1</span>) % <span class="number">4</span>].first - p[i].first, p[(i + <span class="number">1</span>) % <span class="number">4</span>].second - p[i].second&#125;;</span><br><span class="line">pii b = &#123;p[(i - <span class="number">1</span> + <span class="number">4</span>) % <span class="number">4</span>].first - p[i].first, p[(i - <span class="number">1</span> + <span class="number">4</span>) % <span class="number">4</span>].second - p[i].second&#125;;</span><br><span class="line"><span class="keyword">if</span>(a.first * b.second - b.first * a.second &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>$f[i]$ 代表前 $i$ 个蛇， 抓了第 $i$ 个，得到的最大价值。</p><p>可以发现，当抓了第 $i$ 个蛇后， 那么位置必须处于 $p[i]$ 处，那么首先可以暴力的想怎么转移， 就是我们可以两层循环， 对于每一个 $f[i]$ ，我们找前面的可以进行转移（即在时间限制内可以到达 $f[j]$ ）的位置 $j,j \lt i$ ，每一个位置进行判断。 复杂度 $O(n^2)$</p><p>但是本题有一个特点，位置数极少，只有5个，那么 $i$ 位置往前5个之后一定是可以转移的位置（在时间限制内一定可以到达 $i$）。 所以我们暴力判断 $i$ 位置的前几个，然后对此进行转移即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &lt; b) a = b; &#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vi <span class="title">t</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">p</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">w</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cin &gt;&gt; t[i] &gt;&gt; p[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line"><span class="function">vl <span class="title">f</span><span class="params">(n + <span class="number">1</span>, <span class="number">-2e18</span>)</span></span>;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="built_in">max</span>(<span class="number">0</span>, i - <span class="number">10</span>); j &lt; i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(t[i] - t[j] &gt;= <span class="built_in">abs</span>(p[i] - p[j]))</span><br><span class="line"><span class="built_in">Max</span>(f[i], f[j] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll ans = *<span class="built_in">max_element</span>(f.<span class="built_in">begin</span>() + <span class="number">1</span>, f.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(ans &lt;= <span class="number">0</span>) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>$$<br>f[x] &#x3D; \frac{1}{6}max(1, f[x - 1]) + \frac{1}{6}max(2, f[x - 1]) \ + \frac{1}{6}max(3, f[x - 1]) + \frac{1}{6}max(4, f[x - 1]) \ + \frac{1}{6}max(5, f[x - 1]) + \frac{1}{6}max(6, f[x - 1])<br>$$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &lt; b) a = b; &#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">db ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">db t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++)</span><br><span class="line">t += <span class="built_in">max</span>(ans, (db)j) / <span class="number">6</span>;</span><br><span class="line">ans = t;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><blockquote><p>一颗基环树， q个询问， 问两点之间是否存在单一路径。</p></blockquote><p>我们首先需要找到这个环，标记一下环上的点，那么以环为树根，单颗子树上的节点（除环上的点）都有单一路径，我们使用并查集将他们连成一个集合即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &lt; b) a = b; &#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span></span><br><span class="line">&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; f, sz;</span><br><span class="line"><span class="built_in">DSU</span>(<span class="type">int</span> n): <span class="built_in">f</span>(n), <span class="built_in">sz</span>(n, <span class="number">1</span>) &#123; <span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(sz[x] &lt; sz[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">f[y] = x;</span><br><span class="line">sz[x] += sz[y];</span><br><span class="line">sz[y] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;vi&gt; <span class="title">g</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">u--, v--;</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">cyc</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="function">vi <span class="title">fa</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">vis</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u)</span><br><span class="line">&#123;</span><br><span class="line">vis[u] = cur++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(vis[v] == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">fa[v] = u;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v] &lt; vis[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = u; i != v; i = fa[i])</span><br><span class="line">cyc[i] = <span class="number">1</span>;</span><br><span class="line">cyc[v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> j : g[i])</span><br><span class="line"><span class="keyword">if</span>(!cyc[i] || !cyc[j])</span><br><span class="line">dsu.<span class="built_in">merge</span>(i, j);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">while</span>(q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">u--, v--;</span><br><span class="line">cout &lt;&lt; (dsu.<span class="built_in">same</span>(u, v) ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><blockquote><p>问有<code>R</code> 个字符 <code>R</code>，<code>G</code> 个字符 <code>G</code>，<code>B</code> 个字符 <code>B</code>，<code>K</code> 个字符 <code>RG</code>的字符串的个数。</p></blockquote><p>排列组合知识。</p><p>首先安排G和B，共$C_{G+B}^{B}$ 种。</p><p>然后安排K个R，只能在G的前面填，共<code>G</code>个位置，凑成<code>RG</code>，共 $C_G^K$ 种。</p><p>剩下了 $R-K$ 个<code>R</code> ，需要填进去同时保证<code>RG</code>的数量不会增加，那么只能在<code>B</code> 和 <code>RG</code> 的前面以及最后一个位置填，共 $B+K+1$ 个位置。</p><p>即 $B+K+1$ 个位置填 $R-K$ 个<code>R</code> 。我们使用隔板法， 即等价于将 $B+K+1 + R-K$ 个<code>R</code>分成 $B+K+1$ 份， 答案为 $C_{B+R}^{B+K}$ 种。</p><blockquote><p>以下为隔板法描述：</p></blockquote><p><strong>一般隔板法：</strong></p><p>将 $n$ 个相同的元素分成 $k$ 部分，每部分至少分得一个元素， 即在 $n-1$ 个空隙中插入 $k-1$ 个隔板，情况数为<br>$$<br>C_{n-1}^{k-1}<br>$$<br>等价于 $x_1+ x_2+x_3+…+x_k&#x3D;n, x_i \geq 1$ 的可行解个数。</p><p><strong>添元素隔板法</strong>：</p><p>将 $n$ 个相同的元素分成 $k$ 部分，每部分可以为空， 等价于我们先让元素个数添加上 $k$ 个，然后在 $n+k$ 个元素中分成 $k$ 部分， 最后再在 $k$ 部分的每一个部分都拿走一个元素，共拿走 $k$ 个元素。 即在 $n+k-1$ 个空隙中插入 $k-1$ 个隔板，情况数为<br>$$<br>C_{n+k-1}^{k-1}<br>$$<br>等价于 $x_1+ x_2+x_3+…+x_k&#x3D;n, x_i \geq 0$ 的可行解个数。</p><blockquote><p>此时该式可以转化为一般隔板法， 我们让 $x_i \geq 1$ 即可，操作是将每一个 $x_i$ 元素加上 $1$ ，相当于等式两边同时加了 $k$ ，即 $x_1+x_2+…+x_k&#x3D;n+k,x_i \geq 1$ ，即可转化为一般隔板法。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &gt; b) a = b; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a, <span class="type">const</span> T b)</span> </span>&#123; <span class="keyword">if</span> (a &lt; b) a = b; &#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e6</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assume -P &lt;= x &lt; 2P</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">norm</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x += mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mod) &#123;</span><br><span class="line">        x -= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">power</span><span class="params">(T a, ll b)</span> </span>&#123;</span><br><span class="line">    T res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Z</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">Z</span>(<span class="type">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x)) &#123;&#125;</span><br><span class="line">    <span class="built_in">Z</span>(ll x) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x % mod)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    Z <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="built_in">norm</span>(mod - x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, mod - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">ll</span>(x) * rhs.x % mod;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>/=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>*(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>+(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>-(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>/(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, Z &amp;a) &#123;</span><br><span class="line">        ll v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">Z</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> Z &amp;a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> R, G, B, K;</span><br><span class="line">cin &gt;&gt; R &gt;&gt; G &gt;&gt; B &gt;&gt; K;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Z&gt; <span class="title">fac</span><span class="params">(N)</span>, <span class="title">invfac</span><span class="params">(N)</span></span>;</span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">fac[i] = fac[i - <span class="number">1</span>] * i;</span><br><span class="line"></span><br><span class="line">invfac[N - <span class="number">1</span>] = fac[N - <span class="number">1</span>].<span class="built_in">inv</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">1</span>; i; i--)</span><br><span class="line">invfac[i - <span class="number">1</span>] = invfac[i] * i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> C = [&amp;](<span class="type">int</span> n, <span class="type">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> fac[n] * invfac[m] * invfac[n - m];</span><br><span class="line">&#125;;</span><br><span class="line">Z ans = <span class="built_in">C</span>(G + B, G) * <span class="built_in">C</span>(G, K) * <span class="built_in">C</span>(B + R, B + K);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Atcoder </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022牛客多校2补题</title>
      <link href="/p/2791995876.html"/>
      <url>/p/2791995876.html</url>
      
        <content type="html"><![CDATA[<h1 id="2022牛客多校2补题"><a href="#2022牛客多校2补题" class="headerlink" title="2022牛客多校2补题"></a><a href="https://ac.nowcoder.com/acm/contest/33187">2022牛客多校2补题</a></h1><h1 id="G-Link-with-Monotonic-Subsequence"><a href="#G-Link-with-Monotonic-Subsequence" class="headerlink" title="G Link with Monotonic Subsequence"></a>G Link with Monotonic Subsequence</h1><p>$max(lis(p), lds(p))$ 的下界为 $\lceil \sqrt n \rceil$ </p><p>如果 $n &#x3D; k^2$ 构造出 $(n-k+1,n-k+2,…,n)(k+1,…,2 \times k)(1,2,3,…,k)$</p><p>规律也可以通过打表得到</p><p>打表程序主体</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">6</span>; i &lt;= <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">vi <span class="title">a</span><span class="params">(i)</span></span>;</span><br><span class="line">    <span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">    vi t;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">vi <span class="title">dpd</span><span class="params">(i, <span class="number">1</span>)</span>, <span class="title">dpi</span><span class="params">(i, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k++)</span><br><span class="line">                <span class="keyword">if</span>(a[j] &lt; a[k])</span><br><span class="line">                    dpd[j] = <span class="built_in">max</span>(dpd[j], dpd[k] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k++)</span><br><span class="line">                <span class="keyword">if</span>(a[j] &gt; a[k])</span><br><span class="line">                    dpi[j] = <span class="built_in">max</span>(dpi[j], dpi[k] + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> in = <span class="number">0</span>, de = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            in = <span class="built_in">max</span>(in, dpi[j]);</span><br><span class="line">            de = <span class="built_in">max</span>(de, dpd[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span>(in, de) &lt; ans)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(in, de);</span><br><span class="line">            t = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : t)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">if</span>(len * len != n) len ++;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n % len)</span><br><span class="line">&#123;</span><br><span class="line">val += n % len;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n % len; i++)</span><br><span class="line">cout &lt;&lt; val-- &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">val += n % len + len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> val += len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len; j++)</span><br><span class="line">cout &lt;&lt; val-- &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">val += len * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Link-with-Game-Glitch"><a href="#D-Link-with-Game-Glitch" class="headerlink" title="D Link with Game Glitch"></a>D Link with Game Glitch</h1><blockquote><p>n种物品，m种交换，每 $a_i$ 个 $b_i$ 类物品可以换 $w \cdot c_i$ 个 $d_i$ 类物品。求最大的 w 使不存在一种无限交换的方式。</p></blockquote><p>从 $b_i$ 向 $d_i$ 连一条 $w \cdot c_i &#x2F; a_i$ 的边。</p><p>二分 $w$ ，如果图中出现边乘积大于 1 的环，即存在无限转换的方式，否则不存在。</p><blockquote><p>因为边乘积较大，需要转换为 $log$ 进行处理。<br>$$<br>log(w_1 \cdot w_2 \cdot … \cdot w_n) &#x3D; logw_1 + logw_2 + … + logw_n<br>$$<br>边权乘积转化为边权log和。</p><p>即为存在边权和大于等于0的环即是无限转换，我们把边权取符号，即存在小于等于0的环即为无线转换。所以转换为判断是否存在负环。</p></blockquote><p>判断负环使用SPFA，建立一个超级源点，使其可以到达所有点。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> tu = tuple&lt;<span class="type">int</span>, <span class="type">int</span>, db&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>, M = <span class="number">3</span> * N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> e[M], h[N], ne[M], idx;</span><br><span class="line">db w[M], dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, db c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line"><span class="built_in">add</span>(b, d, <span class="built_in">log</span>(a) - <span class="built_in">log</span>(c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> check = [&amp;](db x) -&gt; <span class="type">bool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">dis[i] = <span class="number">1e9</span>;</span><br><span class="line"><span class="function">vector&lt;db&gt; <span class="title">W</span><span class="params">(idx)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i &lt; n) W[i] = w[i];</span><br><span class="line"><span class="keyword">else</span> W[i] = w[i] - <span class="built_in">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vi <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">vis[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = e[i];</span><br><span class="line">db ww = W[i];</span><br><span class="line"><span class="keyword">if</span>(dis[u] + ww &lt; dis[v])</span><br><span class="line">&#123;</span><br><span class="line">dis[v] = dis[u] + ww;</span><br><span class="line">cnt[v]++;</span><br><span class="line"><span class="keyword">if</span>(cnt[v] &gt;= n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])</span><br><span class="line">&#123;</span><br><span class="line">vis[v] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">db l = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(r - l &gt; eps)</span><br><span class="line">&#123;</span><br><span class="line">db mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; l &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J-Link-with-Arithmetic-Progression"><a href="#J-Link-with-Arithmetic-Progression" class="headerlink" title="J  Link with Arithmetic Progression"></a>J  Link with Arithmetic Progression</h1><blockquote><p>给定数列 $a_1,a_2, …, a_n$ ，求一个等差数列 $b_1, b_2, …,b_n$ 使 $\sum \limits_{i&#x3D;1}^n(b_i-a_i)^2$ 最小，输出最小值。</p></blockquote><p>线性回归，求出一条拟合直线 $y &#x3D; kx + b$ 可以保证题目中最小值。<br>$$<br>k &#x3D; \frac{\sum \limits_{i&#x3D;1}^n x_iy_i - n \overline x \overline y}{\sum \limits_{i&#x3D;1}^nx_i^2 - n \overline x^2}\<br>b &#x3D; \overline y - k \overline x<br>$$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vl <span class="title">y</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">ll sy = <span class="number">0</span>, sx = <span class="number">0</span>, a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; y[i];</span><br><span class="line">sx += i, sy += y[i];</span><br><span class="line">a += <span class="number">1ll</span> * i * y[i];</span><br><span class="line">b += <span class="number">1ll</span> * i * i;</span><br><span class="line">&#125;</span><br><span class="line">ld ax = (ld)sx / n, ay = (ld)sy / n;</span><br><span class="line">ld k = (a - n * ax * ay) / (b - n * ax * ax);</span><br><span class="line">ld c = ay - k * ax;</span><br><span class="line"></span><br><span class="line">ld ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">ld x = (k * i + c - y[i]) * (k * i + c - y[i]);</span><br><span class="line">ans += x;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">12</span>) &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="K-Link-with-Bracket-Sequence-I"><a href="#K-Link-with-Bracket-Sequence-I" class="headerlink" title="K Link with Bracket Sequence I"></a>K Link with Bracket Sequence I</h1><blockquote><p>长度为n的括号序列a是长度为m的合法括号序列的子序列，给定a，求b的数量。</p></blockquote><p>$f[i][j][k]$ : b串有 $i$ 个字符，a串中前 $j$ 个字符是b串的子序列，还有k个左括号未匹配的数量。</p><p>转移：</p><p>$i+1$ 位置放 <code>(</code>，且有 $j&#x3D;n$ 或 $s_{j+1}\neq$ <code>(</code> ，那么有转移 $f_{i,j,k}\rightarrow f_{i+1,j,k+1}$。</p><p>$i+1$ 位置放 <code>)</code>，且有 $j&#x3D;n$ 或 $s_{j+1}\neq$ <code>)</code> ，且 $k&gt;0$，那么有转移 $f_{i,j,k}\rightarrow f_{i+1,j,k-1}$。</p><p>$i+1$ 位置放 <code>(</code>，且有 $j&lt;n,s_{j+1}&#x3D;$<code>(</code> ，那么有转移 $f_{i,j,k}\rightarrow f_{i+1,j+1,k+1}$。</p><p>$i+1$ 位置放 <code>)</code>，且有 $j&lt;n,s_{j+1}&#x3D;$ <code>)</code> ，且$k&gt;0$，那么有转移 $f_{i,j,k}\rightarrow f_{i+1,j+1,k-1}$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">205</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((x += y) &gt;= mod)</span><br><span class="line">x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(i, n); j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= i; k++)</span><br><span class="line"><span class="keyword">if</span>(f[i][j][k])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(k &lt; m &amp;&amp; (j == n || s[j + <span class="number">1</span>] != <span class="string">&#x27;(&#x27;</span>))</span><br><span class="line"><span class="built_in">add</span>(f[i + <span class="number">1</span>][j][k + <span class="number">1</span>], f[i][j][k]);</span><br><span class="line"><span class="keyword">if</span>(k &amp;&amp; (j == n || s[j + <span class="number">1</span>] != <span class="string">&#x27;)&#x27;</span>))</span><br><span class="line"><span class="built_in">add</span>(f[i + <span class="number">1</span>][j][k - <span class="number">1</span>], f[i][j][k]);</span><br><span class="line"><span class="keyword">if</span>(j &lt; n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(k &lt; m &amp;&amp; s[j + <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line"><span class="built_in">add</span>(f[i + <span class="number">1</span>][j + <span class="number">1</span>][k + <span class="number">1</span>], f[i][j][k]);</span><br><span class="line"><span class="keyword">if</span>(k &amp;&amp; s[j + <span class="number">1</span>] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="built_in">add</span>(f[i + <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>], f[i][j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[m][n][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="L-Link-with-Level-Editor-I"><a href="#L-Link-with-Level-Editor-I" class="headerlink" title="L Link with Level Editor I"></a>L Link with Level Editor I</h1><blockquote><p>$n$ 个世界， 每个世界有一个 $m$ 个点的无向图，从第一个世界的编号为 $1$ 的点出发，每个世界可以不动或可以走一条边到达下一个点 $u$ ，然后跳到下一个世界的点 $u$ ，如果跳到点 $m$ 则胜利。求一个最短的子段，使得其可胜利。</p></blockquote><p>$(i, u)$ 到 $(i + 1, v)$ 有关系，可以考虑进行状态转移。</p><p>设置 $f[i][j]$ : 表示到达第 $i$ 个世界中的 $j$ 号点最少需要经过多少世界</p><p>初始时： $f[i][1] &#x3D; 1, f[i][j] &#x3D; \infty$ </p><p>两种转移方式：</p><ul><li>在当前世界原地不动，之后到下一个世界。 $f[i][j] + 1 \rightarrow f[i+1][j] (i &lt; n)$</li><li>在当前世界走一条边，之后到下一个世界。$f[i][u]+1 \rightarrow f[i+1][v] (i &lt; n),(u, v)$  属于第 $i$ 个世界的一条边。</li></ul><p>第一维可以进行压缩，进行空间优化。</p><blockquote><p> 注意：转移的时候，是先进行走边，然后再到下一个世界。</p><p>当到达第 $i$ 个世界时， 先对上一层状态 $f[]$ 数组不为无穷的加一，代表进入当前世界。然后进行状态转移，转移时候利用的是转移到当前世界的数组（即下面代码的$f[]$ 数组）进行更新。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> db = <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> ld = <span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">f</span><span class="params">(m + <span class="number">1</span>, <span class="number">1e9</span>)</span>, nf</span>;</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="keyword">if</span>(j != <span class="number">1</span> &amp;&amp; j != m &amp;&amp; f[j] != <span class="number">1e9</span>)</span><br><span class="line">f[j]++;<span class="comment">// 走到第 i 个世界,世界数加一</span></span><br><span class="line">nf = f;</span><br><span class="line"><span class="keyword">while</span>(c--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">nf[v] = <span class="built_in">min</span>(f[u], nf[v]); <span class="comment">// 在第i个世界中进行状态转移，f[]为老的状态，新的状态存在nf[]数组中</span></span><br><span class="line">&#125;</span><br><span class="line">f = nf;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (f[m] == <span class="number">1e9</span> ? <span class="number">-1</span> : f[m]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022牛客多校1补题</title>
      <link href="/p/2541904761.html"/>
      <url>/p/2541904761.html</url>
      
        <content type="html"><![CDATA[<h1 id="2022牛客多校1补题"><a href="#2022牛客多校1补题" class="headerlink" title="2022牛客多校1补题"></a>2022牛客多校1补题</h1><p>题解有<code>A C D G I J</code>六题。</p><p>题解纯属自己玩，更多详细解释还请看官方题解。</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n$ ，将 $1,2,. . . , n$ 视为不含前导零的字符串</p><p>求这些字符串中字典序最大的字符串</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只需要在 $|n|-1$ 个9和 $n$ 两个答案之中进行选择。</p><ul><li>$n$去除最后一位其余均为9，答案为 $n$</li><li>否则为 $|n|-1$ 个9</li></ul><p>复杂度 ： $O(|n|)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">string t = <span class="built_in">string</span>(s.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>) == t) cout &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>$n$个区间 $[x_i-r_i, x_i+r_i]$ ，求 $n$ 个区间并之后的区间的空隙长度和。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>贪心，将区间按左端点从小到大排序，从前往后扫一遍，不断维护维护区间右端点 $r$ 。若当前区间的左端点小于 $r$ ，可以进行合并，并且更新区间右端点；若当前区间的左端点大于 $r$ ，计算答案。</p><blockquote><p>注意第一个区间的判断以及 $r$ 的初始值。</p></blockquote><p>复杂度 ： $O(nlogn)$</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;pii&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> c, r;</span><br><span class="line">cin &gt;&gt; c &gt;&gt; r;</span><br><span class="line">a[i] = &#123;c - r, c + r&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">ll ans = <span class="number">0</span>, rr = <span class="number">-1e18</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">ll l = a[i].first, r = a[i].second;</span><br><span class="line"><span class="keyword">if</span>(l &gt; rr &amp;&amp; i)</span><br><span class="line">ans += (l - rr);</span><br><span class="line">rr = <span class="built_in">max</span>(rr, r);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>给定一个圆和严格位于圆内的一点 $P$</p><p>Mocha 会从点 $P$ 向任意角度发射一个长度为 $2d$ 的电磁炮</p><p>电磁炮底边的中点为点P且两端位于圆内</p><p>询问单次发射能摧毁的最大圆弧长</p><p>$1≤T≤1000,-10^9≤ x, y ≤10^9,1 ≤r, d≤10^9$</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>将电磁炮方向转化为竖直向上：无论当前的电磁炮旋转角度如何，我们可以固定电磁炮的方向，将点 $P$ 绕原点旋转，从而使得电磁炮方向竖直向上（即 $y$ 轴正方向）。</p><p>那么可以将题目转化成为电磁炮的方向总是竖直向上的，点 P 绕原点旋转一周的过程中可以摧毁的最长墙壁长度。</p><p>那么我们设点 P 到原点距离是 $dis$，点 Q 绕原点旋转一周就可以转化成点Q在以 $(-dis,0)$ 和 $(dis,0)$ 为端点的线段上移动。</p><p>下面用一张动图来说明：当点 Q 位于 $x$ 轴上时，产生的弧长最长。</p><p><img src="https://uploadfiles.nowcoder.com/images/20220724/543419382_1658594584578/2CB7686E53E6883E02FCAA79818B7E3B"></p><p>所以画图进行计算，我们计算弧度以此来算弧长。 $L &#x3D; \alpha R$</p><blockquote><p> 当我们使用 $sin$ 计算时，因为正弦的 $0°-180°$表示并不唯一，所以需要分情况讨论 $dis &gt; d$ 和 $dis &lt; d$</p><p>当我们使用 $cos$ 计算时，$cos$ 可以唯一表示 $0-180$ 度，所以不需要分类讨论。</p></blockquote><p><img src="/2541904761/image-20220821221513603.png" alt="图示"></p><p>以 $cos$ 计算为例：</p><p>$\alpha &#x3D; arccos(\frac{dis - d}{r})$</p><p>$\beta &#x3D; arcos(\frac{dis + d}{r})$</p><p>$L &#x3D; (\alpha - \beta) \times r$</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> r, x, y, d;</span><br><span class="line">cin &gt;&gt; r &gt;&gt; x &gt;&gt; y &gt;&gt; d;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> dis = <span class="built_in">sqrt</span>(<span class="number">1ll</span> * x * x + <span class="number">1ll</span> * y * y);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">12</span>);</span><br><span class="line"><span class="type">double</span> a = <span class="built_in">acos</span>((dis + d) / r);</span><br><span class="line"><span class="type">double</span> b = <span class="built_in">acos</span>((dis - d) / r);</span><br><span class="line">cout &lt;&lt; (b - a) * r &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">// if(dis &gt; d)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// double a = asin((dis + d) / r);</span></span><br><span class="line"><span class="comment">// double b = asin((dis - d) / r);</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; r * (a - b) &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// double a = asin((d + dis) / r);</span></span><br><span class="line"><span class="comment">// double b = asin((d - dis) / r);</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; r * (a + b) &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>一个二维平面，黑板为 $(0,1)-(0,m)$ 的线段， $n$ 行 $m$ 列座位在黑板前面，均为整数坐标。</p><p>$k$ 个位置有人，求到黑板视线不被任何人挡住的座位数量。</p><p>$q$ 次询问，修改一个人的坐标要求计算答案。</p><p>$2 \leq n,m \leq 2\times10^5, 1 \leq k \leq 2 \times10 ^ 5, 1 \leq q \leq 200$</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>每个人会挡住自己右边的人。每个人挡住的区域为一个折线右边的区域。</p><p>每次询问维护 $mn[i], X[i]$</p><p>$mn[i]$ ： 纵坐标为 $i$ 时最大不被遮挡的人的横坐标。</p><p>$X[i]$ : 纵坐标为 $i$ 时，被遮挡的座位的最小横坐标。</p><p>可以发现一个性质，当纵坐标从小到大时，如果新出现的点 $(X[i], i)$ 与 $(0,1)$ 构成的斜率更大，如果遮挡纵坐标更大的点时，也是该点遮挡后面的点。</p><p>时间复杂度 ： $O(mq)$</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, k, q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function">vl <span class="title">x</span><span class="params">(k + <span class="number">1</span>)</span>, <span class="title">y</span><span class="params">(x)</span>, <span class="title">X</span><span class="params">(m + <span class="number">1</span>, n + <span class="number">1</span>)</span>, <span class="title">mn</span><span class="params">(m + <span class="number">1</span>, n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">cin &gt;&gt; id;</span><br><span class="line">cin &gt;&gt; x[id] &gt;&gt; y[id];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">mn[i] = n, X[i] = n + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">X[y[i]] = <span class="built_in">min</span>(X[y[i]], x[i]);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 从下往上</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// (0, 1)(X[i], i) (0, 1)(X[j], j)</span></span><br><span class="line"><span class="keyword">if</span>(X[i] != n + <span class="number">1</span> &amp;&amp; (!j || (i - <span class="number">1</span>) * X[j] &gt; (j - <span class="number">1</span>) * X[i]))</span><br><span class="line">j = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">1</span>)</span><br><span class="line">mn[i] = <span class="built_in">min</span>(mn[i], i == <span class="number">1</span> ? X[i] - <span class="number">1</span> : n);</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// y = kx+1 = (j - 1)/X[j] x + 1 = i</span></span><br><span class="line">mn[i] = <span class="built_in">min</span>(mn[i], j ? ((i - <span class="number">1</span>) * X[j] - <span class="number">1</span>) / (j - <span class="number">1</span>) : n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// (0,m)(X[i],i) (0,m)(X[j],j)</span></span><br><span class="line"><span class="keyword">if</span>(X[i] != n + <span class="number">1</span> &amp;&amp; (!j || (i - m) * X[j] &lt; (j - m) * X[i]))</span><br><span class="line">j = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j == m)</span><br><span class="line">mn[i] = <span class="built_in">min</span>(mn[i], i == m ? X[i] - <span class="number">1</span> : n);</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// y = kx+m = (j-m)/X[j] x + m = i</span></span><br><span class="line">mn[i] = <span class="built_in">min</span>(mn[i], j ? ((m - i) * X[j] - <span class="number">1</span>) / (m - j) : n);</span><br><span class="line">&#125;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">ans += mn[i];</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>初始手牌有13张麻将牌，相同牌至多出现2张</p><p>每轮可以从牌堆摸牌，若达成七对子则自摸胡牌</p><p>若不然则选择手牌中某张牌并丢弃之</p><p>给定初始手牌，求最优策略下达成七对子的期望轮数</p><p>多组数据，数据组数不超过 $10^5$ 组</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>期望DP</p><p>$f[i][j]$ : 有 $j$ 张单排，牌堆剩余 $i$ 张的期望轮数</p><p>$f[i][j] &#x3D; \frac{3 \times j}{i} \times (1 + f[i - 1][j - 2]) + \frac{i - 3 \times j}{i} \times (1 + f[i - 1][j])$</p><p>当 $j &#x3D; 1$ 时， $f[i][j] &#x3D;  \frac{3 \times j}{i} \times (1 + 0) + \frac{i - 3 \times j}{i} \times (1 + f[i - 1][j])$</p><p>初始手牌单牌数量为 $cnt$ ，答案为 $f[136-13][cnt]$</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll f[<span class="number">150</span>][<span class="number">15</span>];</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">a = a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">123</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">ll inv = <span class="built_in">ksm</span>(i, mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">13</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j] = (<span class="number">1</span> + </span><br><span class="line">f[i - <span class="number">1</span>][<span class="built_in">max</span>(<span class="number">0</span>, j - <span class="number">2</span>)] * (<span class="number">3</span> * j) % mod * inv % mod + </span><br><span class="line">f[i - <span class="number">1</span>][j] * (i - <span class="number">3</span> * j) % mod * inv % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(s.<span class="built_in">size</span>()); i += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(mp[s.<span class="built_in">substr</span>(i, <span class="number">2</span>)]) cnt--;</span><br><span class="line"><span class="keyword">else</span> cnt++;</span><br><span class="line">mp[s.<span class="built_in">substr</span>(i, <span class="number">2</span>)] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[<span class="number">123</span>][cnt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>有一张 n 个点 m 条边的无重边无自环的有向图</p><p>初始时可以选择一个点染黑，其余点均为白点</p><p>若某个点所有入边的起点均为黑点，则该点可以被染黑</p><p>最大化图中黑点数量</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>启发式合并。</p><p>当一个点的入度为 1 ，那么该点的前驱染黑的话，该点一定也被染黑。那么可以将该点和该点的前驱进行缩点合并看做一个集合。</p><p>因为每个点都可能会有对应的出边，而合并的两个点的出边可能会有重复，就要进行去重，因为缩点之后的出边只能有一条。去重就可以用到 <code>set</code>  ，自带去重操作。</p><p>合并的时候也有技巧，通过出边数较小的点合并到出边数较大的点身上，也就是启发式合并（类似并查集中的合并），达到减小时间复杂度的目的。</p><p>递归合并即可，最后输出合并后最大的块。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N], sz[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; in[N], out[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == f[x])</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(out[x].<span class="built_in">size</span>() &lt; out[y].<span class="built_in">size</span>())</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line"></span><br><span class="line">f[y] = x;</span><br><span class="line">sz[x] += sz[y];</span><br><span class="line"></span><br><span class="line">vi q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : out[y])</span><br><span class="line">&#123;</span><br><span class="line">out[x].<span class="built_in">insert</span>(v);</span><br><span class="line">in[v].<span class="built_in">erase</span>(y);</span><br><span class="line">in[v].<span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">if</span>(in[v].<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">q.<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : q)</span><br><span class="line"><span class="built_in">merge</span>(x, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">in[i].<span class="built_in">clear</span>(), out[i].<span class="built_in">clear</span>();</span><br><span class="line">f[i] = i;</span><br><span class="line">sz[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line">cin &gt;&gt; u;</span><br><span class="line">in[i].<span class="built_in">insert</span>(u);</span><br><span class="line">out[u].<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(in[i].<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">merge</span>(i, *in[i].<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">ans = <span class="built_in">max</span>(ans, sz[i]);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多校 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多校 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树上拓扑序计数|树形DP</title>
      <link href="/p/2852940489.html"/>
      <url>/p/2852940489.html</url>
      
        <content type="html"><![CDATA[<h1 id="树上拓扑序计数-树形DP"><a href="#树上拓扑序计数-树形DP" class="headerlink" title="树上拓扑序计数|树形DP"></a>树上拓扑序计数|树形DP</h1><p><a href="https://ac.nowcoder.com/acm/contest/38630/F">https://ac.nowcoder.com/acm/contest/38630/F</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每个公司是一棵树，然后每个公司可以看做连在一个虚拟的根上。每个公司的计算方案实际上就是计算这棵树的拓扑序的个数。用树形DP求解。</p><p>$f[u]$ : 以<code>u</code>为根的子树的拓扑序数</p><p>$sz[u]$ ： 以<code>u</code>为根的子树的大小（节点的数量）</p><p>当树为二叉树时，将两个子树<code>v1,v2</code>进行合并：即先把各子树的方案数乘起来算出总方案，然后考虑各子树元素的相对排列顺序，即在总的节点个数中选<code>sz[v1]</code>排在前面的<code>sz[v1]</code>个位置，剩下的排在后面，保证每颗子树的相对拓扑序不变。</p><p>$$<br>f[u] &#x3D; f[v1] \cdot f[v2] \cdot C(sz[v1] + sz[v2], sz[v1])<br>$$</p><blockquote><p>例子：<code>u</code>节点有四颗子树，子树大小分别为<code>a, b, c, d</code>，则方案数为：</p><p>$f[u] &#x3D; f[a]\cdot f[b]\cdot f[c]\cdot f[d]\cdot C(a+b+c+d, a)\cdot C(b+c+d, b)\cdot C(c+d,c)$</p><p>$&#x3D;f[a]\cdot f[b]\cdot f[c]\cdot f[d]\cdot \frac{(a+b+c+d)!}{a!(b+c+d)!}\cdot \frac{(b+c+d)!}{b!(c+d)!}\cdot \frac{(c+d)!}{c!d!}$</p><p>$&#x3D;f[a]\cdot f[b]\cdot f[c]\cdot f[d]\cdot \frac{(a+b+c+d)!}{a!b!c!d!}$</p></blockquote><p>推广到一般树：<br>$$<br>f[u] &#x3D; (\prod \limits_{v \in son(u)} f[v] ) \cdot \frac{(sz[u] - 1)!}{\prod \limits_{v \in son(u)}sz[v]!}<br>$$<br>换一下形式：<br>$$<br>f[u] &#x3D; (sz[u] - 1)! \cdot \prod \limits_{v \in son(u)} \frac{f[v]}{sz[v]!}<br>$$</p><p>拓扑序数量还可以这样计算：<br>$$<br>n! \cdot \prod \limits_{i &#x3D; 1} ^ n \frac{1}{sz[i]}<br>$$</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll fac[N], inv[N];</span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">a = a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">1</span>, tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line">cnt += c;</span><br><span class="line"><span class="function">vector&lt;vi&gt; <span class="title">g</span><span class="params">(c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; c; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line">cin &gt;&gt; u;</span><br><span class="line">u--;</span><br><span class="line">g[u].<span class="built_in">push_back</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">sz</span><span class="params">(c, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vl <span class="title">f</span><span class="params">(c, <span class="number">1</span>)</span></span>;</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">sz[u] += sz[v];</span><br><span class="line">(f[u] *= f[v] * inv[sz[v]] % mod) %= mod;</span><br><span class="line">&#125;</span><br><span class="line">(f[u] *= fac[sz[u] - <span class="number">1</span>]) %= mod;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">(tot *= f[<span class="number">0</span>] * inv[c] % mod) %= mod;</span><br><span class="line">&#125;</span><br><span class="line">ans = ans * tot % mod * fac[cnt] % mod;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">inv[N - <span class="number">1</span>] = <span class="built_in">ksm</span>(fac[N - <span class="number">1</span>], mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">inv[i] = (i + <span class="number">1</span>) * inv[i + <span class="number">1</span>] % mod;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> pll = pair&lt;ll, ll&gt;;</span><br><span class="line"><span class="keyword">using</span> arr = array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vi = vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> vl = vector&lt;ll&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assume -P &lt;= x &lt; 2P</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">norm</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x += mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mod) &#123;</span><br><span class="line">        x -= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">power</span><span class="params">(T a, ll b)</span> </span>&#123;</span><br><span class="line">    T res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Z</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">Z</span>(<span class="type">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x)) &#123;&#125;</span><br><span class="line">    <span class="built_in">Z</span>(ll x) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x % mod)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    Z <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="built_in">norm</span>(mod - x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, mod - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">ll</span>(x) * rhs.x % mod;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>/=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>*(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>+(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>-(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>/(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, Z &amp;a) &#123;</span><br><span class="line">        ll v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">Z</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> Z &amp;a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">Z ans = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; c; j++)</span><br><span class="line">ans *= ++tot;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;vi&gt; <span class="title">g</span><span class="params">(c)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; c; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line">cin &gt;&gt; u;</span><br><span class="line">u--;</span><br><span class="line">g[u].<span class="built_in">push_back</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">sz</span><span class="params">(c, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> u)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">sz[u] += sz[v];</span><br><span class="line">&#125;</span><br><span class="line">ans /= sz[u];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓扑序计数相关题目：</p><p>HDU4661 ： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4661">http://acm.hdu.edu.cn/showproblem.php?pid=4661</a></p>]]></content>
      
      
      <categories>
          
          <category> 树形DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL总结</title>
      <link href="/p/870124582.html"/>
      <url>/p/870124582.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL-总结-基于算法竞赛（悠享版）"><a href="#C-STL-总结-基于算法竞赛（悠享版）" class="headerlink" title="C++ STL 总结-基于算法竞赛（悠享版）"></a>C++ STL 总结-基于算法竞赛（悠享版）</h1><p>本文介绍常用STL知识，注重应用，强调用法，不强调原理和繁杂的记忆。看过之后请多运用，多敲代码试。</p><blockquote><p>费尽心思重新梳理了一下，注意了些美观性，修改了部分错误，添加了部分解释，编写过程非常难。</p></blockquote><p>另外C++版本一定要对（可能要加编译参数<code>-std=c++11</code>），C++11即可，C++17或20更好。</p><blockquote><p>使DEV支持C++20 ： <a href="https://blog.csdn.net/qq_50285142/article/details/122930647">https://blog.csdn.net/qq_50285142/article/details/122930647</a></p></blockquote><blockquote><p>实践才是检验真理的唯一标准！</p><p>本文章CSDN的版本：<a href="https://wyq666.blog.csdn.net/article/details/114026148">https://wyq666.blog.csdn.net/article/details/114026148</a> （CSDN更新可能不及时，毕竟多平台维护麻烦，最新版以本网站为主）</p></blockquote><h1 id="1-vector"><a href="#1-vector" class="headerlink" title="1 vector"></a>1 vector</h1><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><p><code>vector</code>为可变长数组（动态数组），定义的<code>vector</code>数组可以随时添加数值和删除元素。</p><blockquote><p>注意：<strong>在局部区域中（比如局部函数里面）开vector数组，是在堆空间里面开的。</strong> </p><p>在局部区域开数组是在栈空间开的，而栈空间比较小，如果开了非常长的数组就会发生爆栈。</p><p>故局部区域<strong>不可以</strong>开大长度数组，但是可以开大长度<code>vector</code>。</p></blockquote><ul><li>头文件：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li><p>一维初始化：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a; <span class="comment">//定义了一个名为a的一维数组,数组存储int类型数据</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; b;<span class="comment">//定义了一个名为b的一维数组，数组存储double类型数据</span></span><br><span class="line">vector&lt;node&gt; c;<span class="comment">//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型</span></span><br></pre></td></tr></table></figure><p>指定<strong>长度</strong>和<strong>初始值</strong>的初始化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;<span class="comment">// 定义一个长度为n的数组，初始值默认为0，下标范围[0, n - 1]</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n, <span class="number">1</span>)</span></span>;<span class="comment">// v[0] 到 v[n - 1]所有的元素初始值均为1</span></span><br><span class="line"><span class="comment">//注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了）</span></span><br></pre></td></tr></table></figure><p>初始化中有多个元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;<span class="comment">//数组a中有五个元素，数组长度就为5</span></span><br></pre></td></tr></table></figure><p>拷贝初始化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(a)</span></span>; <span class="comment">// 两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c = a; <span class="comment">// 也是拷贝初始化,c和a是完全一样的数组</span></span><br></pre></td></tr></table></figure></li><li><p>二维初始化<br>定义第一维固定长度为<code>5</code>，第二维可变化的二维数组</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v[<span class="number">5</span>];<span class="comment">//定义可变长二维数组</span></span><br><span class="line"><span class="comment">//注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素</span></span><br><span class="line"><span class="comment">//第一维固定长度为5，第二维长度可以改变</span></span><br></pre></td></tr></table></figure><blockquote><p><code>vector&lt;int&gt; v[5]</code>可以这样理解：长度为5的v数组，数组中存储的是<code>vector&lt;int&gt; </code>数据类型，而该类型就是数组形式，故<code>v</code>为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v[<span class="number">2</span>].<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></blockquote><p>行列均可变</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化二维均可变长数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;<span class="comment">//定义一个行和列均可变的二维数组</span></span><br></pre></td></tr></table></figure><blockquote><p>应用：可以在<code>v</code>数组里面装多个数组</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; t1&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; t2&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">v.<span class="built_in">push_back</span>(t1);</span><br><span class="line">v.<span class="built_in">push_back</span>(t2);</span><br><span class="line">v.<span class="built_in">push_back</span>(&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;) <span class="comment">// &#123;3, 4, 5, 6&#125;可以作为vector的初始化,相当于一个无名vector</span></span><br></pre></td></tr></table></figure></blockquote><p>行列长度均固定 <code>n + 1</code>行 <code>m + 1</code>列初始值为0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>c++17或者c++20支持的形式（不常用），与上面相同的初始化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector <span class="title">a</span><span class="params">(n + <span class="number">1</span>, vector(m + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-2-方法函数"><a href="#1-2-方法函数" class="headerlink" title="1.2 方法函数"></a>1.2 方法函数</h2><p>知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。</p><p><strong>c指定为数组名称</strong>，含义中会注明算法复杂度。</p><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>c.front()</code></td><td>返回第一个数据$O(1)$</td></tr><tr><td><code>c.back()</code></td><td>返回数组中的最后一个数据 $O(1)$</td></tr><tr><td><code>c.pop_back()</code></td><td>删除最后一个数据$O(1)$</td></tr><tr><td><code>c.push_back(element)</code></td><td>在尾部加一个数据$O(1)$</td></tr><tr><td><code>c.size()</code></td><td>返回实际数据个数（unsigned类型）$O(1)$</td></tr><tr><td><code>c.clear()</code></td><td>清除元素个数$O(N)$，N为元素个数</td></tr><tr><td><code>c.resize(n, v)</code></td><td>改变数组大小为<code>n</code>,<code>n</code>个空间数值赋为<code>v</code>，如果没有默认赋值为<code>0</code></td></tr><tr><td><code>c.insert(it, x)</code></td><td>向任意迭代器<code>it</code>插入一个元素<code>x</code> ，$O(N)$</td></tr><tr><td>例：<code>c.insert(c.begin() + 2,-1)</code></td><td>将<code>-1</code>插入<code>c[2]</code>的位置</td></tr><tr><td><code>c.erase(first,last)</code></td><td>删除<code>[first,last)</code>的所有元素，$O(N)$</td></tr><tr><td><code>c.begin()</code></td><td>返回首元素的迭代器（通俗来说就是地址）$O(1)$</td></tr><tr><td><code>c.end()</code></td><td>返回最后一个元素后一个位置的迭代器（地址）$O(1)$</td></tr><tr><td><code>c.empty()</code></td><td>判断是否为空，为空返回真，反之返回假 $O(1)$</td></tr></tbody></table><blockquote><p>注意：</p><ul><li><p><code>end()</code>返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，<strong>所有STL容器均是如此</strong> </p></li><li><p>使用 <code>vi.resize(n, v)</code> 函数时，若 <code>vi</code> 之前指定过大小为 <code>pre</code> </p><ul><li><code>pre &gt; n</code> ：即数组大小变小了，数组会保存前 <code>n</code> 个元素，前 <code>n</code> 个元素值为原来的值，不是都为 <code>v</code> </li><li><code>pre &lt; n</code> ：即数组大小变大了，数组会在后面插入 <code>n - pre</code> 个值为 <code>v</code> 的元素</li></ul><p>也就是说，这个初始值 <code>v</code> 只对新插入的元素生效。</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: a) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; <span class="string">&quot;\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">out</span>(a); <span class="comment">// 1 1 1 1 1</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">out</span>(a); <span class="comment">// 1 1 1 1 1 2 2 2 2 2</span></span><br><span class="line">a.<span class="built_in">resize</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">out</span>(a); <span class="comment">// 1 1 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>排序：</strong></p><p>使用<code>sort</code>排序要：  <code>sort(c.begin(), c.end());</code></p><blockquote><p><code>sort()</code>为STL函数，请参考本文最后面STL函数系列。</p></blockquote><p>对所有元素进行排序，如果要对指定区间进行排序，可以对<code>sort()</code>里面的参数进行加减改动。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">end</span>()); <span class="comment">// 对[1, n]区间进行从小到大排序</span></span><br></pre></td></tr></table></figure><h2 id="1-3-访问"><a href="#1-3-访问" class="headerlink" title="1.3  访问"></a>1.3  访问</h2><p>共三种方法：</p><ul><li><strong>下标法</strong> ： 和普通数组一样</li></ul><p>注意：一维数组的下标是从 <code>0</code> 到 <code>v.size()-1</code> ，访问之外的数会出现越界错误</p><ul><li><strong>迭代器法</strong> ： 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码进行理解（附有注释）。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi; <span class="comment">//定义一个vi数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();<span class="comment">//声明一个迭代器指向vi的初始位置</span></span><br></pre></td></tr></table></figure><ul><li><strong>使用auto</strong> ：非常简便，但是会访问数组的所有元素（特别注意0位置元素也会访问到）</li></ul><h3 id="1-3-1-下标访问"><a href="#1-3-1-下标访问" class="headerlink" title="1.3.1 下标访问"></a>1.3.1 下标访问</h3><p>直接和普通数组一样进行访问即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">vi.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下标访问 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">cout &lt;&lt; vi[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-迭代器访问"><a href="#1-3-2-迭代器访问" class="headerlink" title="1.3.2 迭代器访问"></a>1.3.2 迭代器访问</h3><p>类似指针，迭代器就是充当指针的作用。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//迭代器访问</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;   </span><br><span class="line"><span class="comment">// 相当于声明了一个迭代器类型的变量it</span></span><br><span class="line"><span class="comment">// 通俗来说就是声明了一个指针变量</span></span><br></pre></td></tr></table></figure><ul><li>方式一：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vi.<span class="built_in">begin</span>(); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">cout &lt;&lt; *(it + i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>方式二</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = vi.<span class="built_in">begin</span>(); it != vi.<span class="built_in">end</span>();it ++)</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//vi.end()指向尾元素地址的下一个地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">auto</span> it = vi.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != vi.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-智能指针"><a href="#1-3-3-智能指针" class="headerlink" title="1.3.3 智能指针"></a>1.3.3 智能指针</h3><p><strong>只能遍历完数组</strong>，如果要指定的内容进行遍历，需要另选方法。</p><p><code>auto</code> 能够自动识别并获取类型。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 输入</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x: a) &#123;</span><br><span class="line">    cin &gt;&gt; x; <span class="comment">// 可以进行输入，注意加引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 输出</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">12</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">241</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> val : v) &#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 12 241</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>vector</code>注意：</p><ul><li><p><code>vi[i]</code>  和  <code>*(vi.begin() + i)</code> 等价，与指针类似。</p></li><li><p><code>vector</code>和<code>string</code>的<code>STL</code>容器支持<code>*(it + i)</code>的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。</p></li></ul></blockquote><h1 id="2-stack"><a href="#2-stack" class="headerlink" title="2 stack"></a>2 stack</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>栈为数据结构的一种，是STL中实现的一个先进后出，后进先出的容器。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件需要添加</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">stack&lt;string&gt; s;</span><br><span class="line">stack&lt;node&gt; s;<span class="comment">//node是结构体类型</span></span><br></pre></td></tr></table></figure><h2 id="2-2-方法函数"><a href="#2-2-方法函数" class="headerlink" title="2.2 方法函数"></a>2.2 方法函数</h2><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.push(ele)</code></td><td>元素<code>ele</code>入栈，增加元素  $O(1)$</td></tr><tr><td><code>s.pop()</code></td><td>移除栈顶元素 $O(1)$</td></tr><tr><td><code>s.top()</code></td><td>取得栈顶元素（但不删除）$O(1)$</td></tr><tr><td><code>s.empty()</code></td><td>检测栈内是否为空，空为真 $O(1)$</td></tr><tr><td><code>s.size()</code></td><td>返回栈内元素的个数 $O(1)$</td></tr></tbody></table><h2 id="2-3-栈遍历"><a href="#2-3-栈遍历" class="headerlink" title="2.3 栈遍历"></a>2.3 栈遍历</h2><h3 id="2-3-1-栈遍历"><a href="#2-3-1-栈遍历" class="headerlink" title="2.3.1 栈遍历"></a>2.3.1 栈遍历</h3><p>栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) st.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="type">int</span> tp = st.<span class="built_in">top</span>(); <span class="comment">// 栈顶元素</span></span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-数组模拟栈进行遍历"><a href="#2-3-2-数组模拟栈进行遍历" class="headerlink" title="2.3.2 数组模拟栈进行遍历"></a>2.3.2 数组模拟栈进行遍历</h3><p>通过一个<strong>数组</strong>对栈进行模拟，一个存放下标的变量<code>top</code>模拟指向栈顶的指针。</p><blockquote><p>一般来说单调栈和单调队列写法均可使用额外变量 <code>tt</code> 或 <code>hh</code> 来进行模拟 </p></blockquote><p><strong>特点：</strong> 比<code>STL</code>的<code>stack</code>速度更快，遍历元素方便</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s[<span class="number">100</span>]; <span class="comment">// 栈 从左至右为栈底到栈顶</span></span><br><span class="line"><span class="type">int</span> tt = <span class="number">-1</span>; <span class="comment">// tt 代表栈顶指针,初始栈内无元素，tt为-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="comment">//入栈 </span></span><br><span class="line">s[++tt] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="type">int</span> top_element = s[tt--]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作示意</span></span><br><span class="line"><span class="comment">//  0  1  2  3  4  5  </span></span><br><span class="line"><span class="comment">//                tt</span></span><br><span class="line"><span class="comment">//出栈后示意</span></span><br><span class="line"><span class="comment">//  0  1  2  3  4 </span></span><br><span class="line"><span class="comment">//              tt</span></span><br></pre></td></tr></table></figure><h1 id="3-queue"><a href="#3-queue" class="headerlink" title="3 queue"></a>3 queue</h1><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h2><p>队列是一种先进先出的数据结构。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//定义初始化</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br></pre></td></tr></table></figure><h2 id="3-2-方法函数"><a href="#3-2-方法函数" class="headerlink" title="3.2 方法函数"></a>3.2 方法函数</h2><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>q.front()</code></td><td>返回队首元素  $O(1)$</td></tr><tr><td><code>q.back()</code></td><td>返回队尾元素 $O(1)$</td></tr><tr><td><code>q.push(element)</code></td><td>尾部添加一个元素<code>element</code>  进队$O(1)$</td></tr><tr><td><code>q.pop()</code></td><td>删除第一个元素  出队 $O(1)$</td></tr><tr><td><code>q.size()</code></td><td>返回队列中元素个数，返回值类型<code>unsigned int</code> $O(1)$</td></tr><tr><td><code>q.empty()</code></td><td>判断是否为空，队列为空，返回<code>true</code> $O(1)$</td></tr></tbody></table><h2 id="3-3-队列模拟"><a href="#3-3-队列模拟" class="headerlink" title="3.3 队列模拟"></a>3.3 队列模拟</h2><p>使用<code>q[]</code>数组模拟队列</p><p><code>hh</code>表示队首元素的下标，初始值为<code>0</code></p><p><code>tt</code>表示队尾元素的下标，初始值为<code>-1</code>，表示刚<strong>开始队列为空</strong></p><blockquote><p>一般来说单调栈和单调队列写法均可使用额外变量 <code>tt</code> 或 <code>hh</code> 来进行模拟 </p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//入队 </span></span><br><span class="line">q[++tt] = <span class="number">1</span>;</span><br><span class="line">q[++tt] = <span class="number">2</span>; </span><br><span class="line"><span class="comment">//将所有元素出队 </span></span><br><span class="line"><span class="keyword">while</span>(hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh++];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h1 id="4-deque"><a href="#4-deque" class="headerlink" title="4 deque"></a>4 deque</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p>首尾都可插入和删除的队列为双端队列。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq;</span><br></pre></td></tr></table></figure><h2 id="4-2-方法函数"><a href="#4-2-方法函数" class="headerlink" title="4.2 方法函数"></a>4.2 方法函数</h2><blockquote><p>注意双端队列的常数比较大。</p></blockquote><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>push_back(x)/push_front(x)</code></td><td>把<code>x</code>插入队尾后 &#x2F; 队首 $O(1)$</td></tr><tr><td><code>back()/front()</code></td><td>返回队尾 &#x2F; 队首元素 $O(1)$</td></tr><tr><td><code>pop_back() / pop_front()</code></td><td>删除队尾 &#x2F; 队首元素 $O(1)$</td></tr><tr><td><code>erase(iterator it)</code></td><td>删除双端队列中的某一个元素</td></tr><tr><td><code>erase(iterator first,iterator last)</code></td><td>删除双端队列中<code>[first,last)</code>中的元素</td></tr><tr><td><code>empty()</code></td><td>判断deque是否空 $O(1)$</td></tr><tr><td><code>size()</code></td><td>返回deque的元素数量 $O(1)$</td></tr><tr><td><code>clear()</code></td><td>清空deque</td></tr></tbody></table><h2 id="4-3-注意点"><a href="#4-3-注意点" class="headerlink" title="4.3 注意点"></a>4.3 注意点</h2><p>deque可以进行排序</p><blockquote><p>双端队列排序一般不用，感觉毫无用处，使用其他STL依然可以实现相同功能</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从小到大</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>())</span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//deque里面的类型需要是int型</span></span><br><span class="line"><span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), <span class="built_in">greater</span>());<span class="comment">//高版本C++才可以用</span></span><br></pre></td></tr></table></figure><h1 id="5-priority-queue"><a href="#5-priority-queue" class="headerlink" title="5. priority_queue"></a>5. priority_queue</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。</p><p>可以实现每次从优先队列中取出的元素都是队列中<strong>优先级最大</strong>的一个。</p><p>它的底层是通过<strong>堆</strong>来实现的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br></pre></td></tr></table></figure><h2 id="5-2-函数方法"><a href="#5-2-函数方法" class="headerlink" title="5.2 函数方法"></a>5.2 函数方法</h2><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>q.top()</code></td><td>访问队首元素 $O(1)$</td></tr><tr><td><code>q.push()</code></td><td>入队 $O(logN)$</td></tr><tr><td><code>q.pop()</code></td><td>堆顶（队首）元素出队 $O(logN)$</td></tr><tr><td><code>q.size()</code></td><td>队列元素个数 $O(1)$</td></tr><tr><td><code>q.empty()</code></td><td>是否为空 $O(1)$</td></tr><tr><td><strong>注意</strong>没有<code>clear()</code>！</td><td>不提供该方法</td></tr><tr><td>优先队列只能通过<code>top()</code>访问队首元素（优先级最高的元素）</td><td></td></tr></tbody></table><h2 id="5-3-设置优先级"><a href="#5-3-设置优先级" class="headerlink" title="5.3 设置优先级"></a>5.3 设置优先级</h2><h3 id="5-3-1-基本数据类型的优先级"><a href="#5-3-1-基本数据类型的优先级" class="headerlink" title="5.3.1 基本数据类型的优先级"></a>5.3.1 基本数据类型的优先级</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">// 默认大根堆, 即每次取出的元素是队列中的最大值</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q; <span class="comment">// 小根堆, 每次取出的元素是队列中的最小值</span></span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li><p>第一个参数：就是优先队列中存储的数据类型</p></li><li><p>第二个参数：</p><p><code>vector&lt;int&gt;</code> 是用来承载底层数据结构堆的容器，若优先队列中存放的是<code>double</code>型数据，就要填<code>vector&lt; double &gt;</code><br><strong>总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。</strong></p></li><li><p>第三个参数：<br><code>less&lt;int&gt;</code>   表示数字大的优先级大，堆顶为最大的数字<br><code>greater&lt;int&gt;</code>表示数字小的优先级大，堆顶为最小的数字<br><strong>int代表的是数据类型，也要填优先队列中存储的数据类型</strong></p></li></ul><hr><p>下面介绍基础数据类型优先级设置的写法：</p><ol><li>基础写法（非常常用）：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q1; <span class="comment">// 默认大根堆, 即每次取出的元素是队列中的最大值</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt; &gt; q2; <span class="comment">// 大根堆, 每次取出的元素是队列中的最大值，同第一行</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt; q3; <span class="comment">// 小根堆, 每次取出的元素是队列中的最小值</span></span><br></pre></td></tr></table></figure><ol start="2"><li>自定义排序（不常见，主要是写着麻烦）：</li></ol><p>下面的代码比较长，基础类型优先级写着太麻烦，用第一种即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp1</span> &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span> &#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp1&gt; q1; <span class="comment">// 小根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp2&gt; q2; <span class="comment">// 大根堆</span></span><br></pre></td></tr></table></figure><h3 id="5-3-2-高级数据类型-结构体-优先级"><a href="#5-3-2-高级数据类型-结构体-优先级" class="headerlink" title="5.3.2 高级数据类型(结构体)优先级"></a>5.3.2 高级数据类型(结构体)优先级</h3><blockquote><p>即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。</p></blockquote><p>优先级设置可以定义在<strong>结构体内</strong>进行小于号重载，也可以定义在<strong>结构体外</strong>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要排序的结构体（存储在优先队列里面的）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>版本一：自定义全局比较规则</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义的比较结构体</span></span><br><span class="line"><span class="comment">//注意：cmp是个结构体 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;<span class="comment">//自定义堆的排序规则 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Point&amp; a,<span class="type">const</span> Point&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化定义， </span></span><br><span class="line">priority_queue&lt;Point, vector&lt;Point&gt;, cmp&gt; q; <span class="comment">// x大的在堆顶</span></span><br></pre></td></tr></table></figure><ul><li><strong>版本二：直接在结构体里面写</strong></li></ul><blockquote><p>因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。</p></blockquote><p>结构体内部有两种方式：</p><p><strong>方式一</strong> ：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (Point a, Point b) &#123;<span class="comment">//为两个结构体参数，结构体调用一定要写上friend</span></span><br><span class="line"><span class="keyword">return</span> a.x &lt; b.x;<span class="comment">//按x从小到大排，x大的在堆顶</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>方式二</strong> ：（推荐此种）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point &amp;a) <span class="type">const</span> &#123;<span class="comment">//直接传入一个参数，不必要写friend</span></span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x;<span class="comment">//按x升序排列，x大的在堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优先队列的定义</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;Point&gt; q;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 优先队列自定义排序规则和<code>sort()</code>函数定义<code>cmp</code>函数很相似，但是最后返回的情况是<strong>相反</strong>的。即相同的符号，最后定义的排列顺序是完全相反的。<br>所以只需要记住<code>sort</code>的排序规则和优先队列的排序规则是相反的就可以了。</p><blockquote><p>当理解了堆的原理就会发现，堆调整时比较顺序是孩子和父亲节点进行比较，如果是 <code>&gt;</code> ，那么孩子节点要大于父亲节点，堆顶自然是最小值。</p></blockquote><h2 id="5-4-存储特殊类型的优先级"><a href="#5-4-存储特殊类型的优先级" class="headerlink" title="5.4 存储特殊类型的优先级"></a>5.4 存储特殊类型的优先级</h2><h3 id="5-4-1-存储pair类型"><a href="#5-4-1-存储pair类型" class="headerlink" title="5.4.1 存储pair类型"></a>5.4.1 存储pair类型</h3><ul><li>排序规则：<br>默认先对<code>pair</code>的<code>first</code>进行降序排序，然后再对<code>second</code>降序排序<br>对<code>first</code>先排序，大的排在前面，如果<code>first</code>元素相同，再对<code>second</code>元素排序，保持大的在前面。</li></ul><blockquote><p><code>pair</code>请参考下文</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;<span class="number">7</span>, <span class="number">8</span>&#125;);</span><br><span class="line">q.<span class="built_in">push</span>(&#123;<span class="number">7</span>, <span class="number">9</span>&#125;);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">8</span>, <span class="number">7</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; q.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">top</span>().second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果：<br>8 7<br>7 9<br>7 8</p></blockquote><h1 id="6-map"><a href="#6-map" class="headerlink" title="6. map"></a>6. map</h1><h2 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h2><p>映射类似于函数的对应关系，每个<code>x</code>对应一个<code>y</code>，而<code>map</code>是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。</p><blockquote><p>比如说：学习 对应 看书，学习 是键，看书 是值。<br>学习-&gt;看书<br>玩耍 对应 打游戏，玩耍 是键，打游戏 是值。<br>玩耍-&gt;打游戏</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">map&lt;string, string&gt; mp;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">map&lt;<span class="type">int</span>, node&gt; mp;<span class="comment">//node是结构体类型</span></span><br></pre></td></tr></table></figure><blockquote><p>map特性：map会按照键的顺序从小到大自动排序，键的类型必须可以比较大小</p></blockquote><h2 id="6-2-函数方法"><a href="#6-2-函数方法" class="headerlink" title="6.2 函数方法"></a>6.2 函数方法</h2><h3 id="6-2-1-函数方法"><a href="#6-2-1-函数方法" class="headerlink" title="6.2.1 函数方法"></a>6.2.1 函数方法</h3><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>mp.find(key)</code></td><td>返回键为key的映射的迭代器 $O(logN) $  注意：用find函数来定位数据出现位置，它返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回$mp.end()$</td></tr><tr><td><code>mp.erase(it)</code></td><td>删除迭代器对应的键和值$O(1)$</td></tr><tr><td><code>mp.erase(key)</code></td><td>根据映射的键删除键和值 $O(logN)$</td></tr><tr><td><code>mp.erase(first,last)</code></td><td>删除左闭右开区间迭代器对应的键和值 $O(last-first)$</td></tr><tr><td><code>mp.size()</code></td><td>返回映射的对数$ O(1)$</td></tr><tr><td><code>mp.clear()</code></td><td>清空map中的所有元素$O(N)$</td></tr><tr><td><code>mp.insert()</code></td><td>插入元素，插入时要构造键值对</td></tr><tr><td><code>mp.empty()</code></td><td>如果map为空，返回true，否则返回false</td></tr><tr><td><code>mp.begin()</code></td><td>返回指向map第一个元素的迭代器（地址）</td></tr><tr><td><code>mp.end()</code></td><td>返回指向map尾部的迭代器（最后一个元素的<strong>下一个</strong>地址）</td></tr><tr><td><code>mp.rbegin()</code></td><td>返回指向map最后一个元素的迭代器（地址）</td></tr><tr><td><code>mp.rend()</code></td><td>返回指向map第一个元素前面(上一个）的逆向迭代器（地址）</td></tr><tr><td><code>mp.count(key)</code></td><td>查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0</td></tr><tr><td><code>mp.lower_bound()</code></td><td>返回一个迭代器，指向键值&gt;&#x3D; <strong>key</strong>的第一个元素</td></tr><tr><td><code>mp.upper_bound()</code></td><td>返回一个迭代器，指向键值&gt; key的第一个元素</td></tr></tbody></table><h3 id="6-2-2-注意点"><a href="#6-2-2-注意点" class="headerlink" title="6.2.2 注意点"></a>6.2.2 注意点</h3><p><strong>下面说明部分函数方法的注意点</strong></p><blockquote><p>注意：<br>查找元素是否存在时，可以使用<br>①<code>mp.find()</code> ② <code>mp.count()</code> ③ <code>mp[key]</code><br>但是第三种情况，如果不存在对应的<code>key</code>时，会自动创建一个键值对（产生一个额外的键值对空间）<br>所以为了不增加额外的空间负担，最好使用前两种方法</p></blockquote><h3 id="6-2-3-迭代器进行正反向遍历"><a href="#6-2-3-迭代器进行正反向遍历" class="headerlink" title="6.2.3 迭代器进行正反向遍历"></a>6.2.3 迭代器进行正反向遍历</h3><ul><li><code>mp.begin()</code>和<code>mp.end()</code>用法：</li></ul><p><strong>用于正向遍历map</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">mp[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">mp[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">it ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><ul><li><code>mp.rbegin()</code>和<code>mp.rend()</code></li></ul><p><strong>用于逆向遍历map</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">mp[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">mp[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">auto</span> it = mp.<span class="built_in">rbegin</span>();</span><br><span class="line"><span class="keyword">while</span>(it != mp.<span class="built_in">rend</span>()) &#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">it ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h3 id="6-2-4-二分查找"><a href="#6-2-4-二分查找" class="headerlink" title="6.2.4 二分查找"></a>6.2.4 二分查找</h3><p>二分查找<code>lower_bound() upper_bound()</code></p><blockquote><p>map的二分查找以第一个元素（即键为准），对<strong>键</strong>进行二分查找<br>返回值为map迭代器类型</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">8</span>, <span class="number">2</span>&#125;, &#123;<span class="number">6</span>, <span class="number">2</span>&#125;&#125;;<span class="comment">//有序</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it1 = m.<span class="built_in">lower_bound</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; it1-&gt;first &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//it1-&gt;first=2</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it2 = m.<span class="built_in">upper_bound</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; it2-&gt;first &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//it2-&gt;first=6</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-3-添加元素"><a href="#6-3-添加元素" class="headerlink" title="6.3 添加元素"></a>6.3 添加元素</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先声明</span></span><br><span class="line">map&lt;string, string&gt; mp;</span><br></pre></td></tr></table></figure><ul><li><strong>方式一：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mp[<span class="string">&quot;学习&quot;</span>] = <span class="string">&quot;看书&quot;</span>;</span><br><span class="line">mp[<span class="string">&quot;玩耍&quot;</span>] = <span class="string">&quot;打游戏&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>方式二：插入元素构造键值对</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;vegetable&quot;</span>,<span class="string">&quot;蔬菜&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li><strong>方式三：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,string&gt;(<span class="string">&quot;fruit&quot;</span>,<span class="string">&quot;水果&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li><strong>方式四:</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mp.<span class="built_in">insert</span>(&#123;<span class="string">&quot;hahaha&quot;</span>,<span class="string">&quot;wawawa&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><h2 id="6-4-访问元素"><a href="#6-4-访问元素" class="headerlink" title="6.4 访问元素"></a>6.4 访问元素</h2><h3 id="6-4-1-下标访问"><a href="#6-4-1-下标访问" class="headerlink" title="6.4.1 下标访问"></a>6.4.1 下标访问</h3><p>(大部分情况用于访问单个元素)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mp[<span class="string">&quot;菜哇菜&quot;</span>] = <span class="string">&quot;强哇强&quot;</span>;</span><br><span class="line">cout &lt;&lt; mp[<span class="string">&quot;菜哇菜&quot;</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;<span class="comment">//只是简写的一个例子，程序并不完整</span></span><br></pre></td></tr></table></figure><h3 id="6-4-2-遍历访问"><a href="#6-4-2-遍历访问" class="headerlink" title="6.4.2 遍历访问"></a>6.4.2 遍历访问</h3><ul><li>方式一：迭代器访问</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,string&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"><span class="comment">//      键                 值 </span></span><br><span class="line"><span class="comment">// it是结构体指针访问所以要用 -&gt; 访问</span></span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//*it是结构体变量 访问要用 . 访问</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;(*it).first&lt;&lt;&quot; &quot;&lt;&lt;(*it).second;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二：智能指针访问</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : mp)</span><br><span class="line">cout &lt;&lt; i.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i.second &lt;&lt; endl;<span class="comment">//键，值</span></span><br></pre></td></tr></table></figure><ul><li>方式三：对指定单个元素访问</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;::iterator it = mp.<span class="built_in">find</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cout &lt;&lt; it -&gt; first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;  it-&gt;second &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>方式四：c++17特性才具有</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : mp)</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//x,y对应键和值</span></span><br></pre></td></tr></table></figure><h2 id="6-5-与unordered-map的比较"><a href="#6-5-与unordered-map的比较" class="headerlink" title="6.5 与unordered_map的比较"></a>6.5 与unordered_map的比较</h2><p>这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。</p><h3 id="6-5-1-内部实现原理"><a href="#6-5-1-内部实现原理" class="headerlink" title="6.5.1 内部实现原理"></a>6.5.1 内部实现原理</h3><p><strong>map</strong>：内部用<strong>红黑树</strong>实现，具有<strong>自动排序</strong>（按键从小到大）功能。</p><p><strong>unordered_map</strong>：内部用<strong>哈希表</strong>实现，内部元素无序杂乱。</p><h3 id="6-5-2-效率比较"><a href="#6-5-2-效率比较" class="headerlink" title="6.5.2 效率比较"></a>6.5.2 效率比较</h3><p><strong>map</strong>：</p><ul><li><p>优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为$O(logN)$</p></li><li><p>缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。</p></li></ul><p><strong>unordered_map</strong>：</p><ul><li>优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。</li><li>缺点：建立哈希表比较耗时。</li></ul><blockquote><p>两者方法函数基本一样，差别不大。</p><p>注意：</p><ul><li><p>随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。</p></li><li><p>使用<code>[]</code>查找元素时，如果元素不存在，两种容器<strong>都是</strong>创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会<strong>大大降低</strong>。</p></li><li><p>查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以 map 为例</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> x = <span class="number">999999999</span>;</span><br><span class="line"><span class="keyword">if</span>(mp.<span class="built_in">count</span>(x)) <span class="comment">// 此处判断是否存在x这个键</span></span><br><span class="line">    cout &lt;&lt; mp[x] &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">// 只有存在才会索引对应的值，避免不存在x时多余空元素的创建</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><p>另外：</p><blockquote><p>还有一种映射：<code>multimap</code></p><p>键可以重复，即一个键对应多个值，如要了解，可以自行搜索。</p></blockquote><h1 id="7-set"><a href="#7-set" class="headerlink" title="7 set"></a>7 set</h1><h2 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h2><p>set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。</p><p>即：set里面的元素<strong>不重复 且有序</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">//初始化定义</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br></pre></td></tr></table></figure><h2 id="7-2-函数方法"><a href="#7-2-函数方法" class="headerlink" title="7.2 函数方法"></a>7.2 函数方法</h2><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.begin()</code></td><td>返回set容器的第一个元素的地址（迭代器）$O(1)$</td></tr><tr><td><code>s.end()</code></td><td>返回set容器的最后一个元素的下一个地址（迭代器）$O(1)$</td></tr><tr><td><code>s.rbegin()</code></td><td>返回逆序迭代器，指向容器元素最后一个位置$O(1)$</td></tr><tr><td><code>s.rend()</code></td><td>返回逆序迭代器，指向容器第一个元素前面的位置$O(1)$</td></tr><tr><td><code>s.clear()</code></td><td>删除set容器中的所有的元素,返回unsigned int类型$O(N)$</td></tr><tr><td><code>s.empty()</code></td><td>判断set容器是否为空$O(1)$</td></tr><tr><td><code>s.insert()</code></td><td>插入一个元素</td></tr><tr><td><code>s.size()</code></td><td>返回当前set容器中的元素个数$O(1)$</td></tr><tr><td><code>erase(iterator)</code></td><td>删除定位器iterator指向的值</td></tr><tr><td><code>erase(first,second）</code></td><td>删除定位器first和second之间的值</td></tr><tr><td><code>erase(key_value)</code></td><td>删除键值key_value的值</td></tr><tr><td>查找</td><td></td></tr><tr><td><code>s.find(element)</code></td><td>查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器</td></tr><tr><td><code>s.count(element)</code></td><td>查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现</td></tr><tr><td><code>s.lower_bound(k)</code></td><td>返回大于等于k的第一个元素的迭代器$O(logN)$</td></tr><tr><td><code>s.upper_bound(k)</code></td><td>返回大于k的第一个元素的迭代器$O(logN)$</td></tr></tbody></table><h2 id="7-3-访问"><a href="#7-3-访问" class="headerlink" title="7.3 访问"></a>7.3 访问</h2><ul><li><strong>迭代器访问</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>智能指针</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li><strong>访问最后一个元素</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line">cout &lt;&lt; *s.<span class="built_in">rbegin</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//第二种</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator iter = s.<span class="built_in">end</span>();</span><br><span class="line">iter--;</span><br><span class="line">cout &lt;&lt; (*iter) &lt;&lt; endl; <span class="comment">//打印2;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第三种</span></span><br><span class="line">cout &lt;&lt; *(--s.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="7-4-重载"><a href="#7-4-重载" class="headerlink" title="7.4 重载&lt;运算符"></a>7.4 重载&lt;运算符</h2><ul><li><strong>基础数据类型</strong></li></ul><p>方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1; <span class="comment">// 默认从小到大排序</span></span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt; &gt; s2; <span class="comment">// 从大到小排序</span></span><br></pre></td></tr></table></figure><p>方式二：重载运算符。（很麻烦，不太常用，没必要）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重载 &lt; 运算符</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; u, <span class="type">const</span> <span class="type">int</span>&amp; v)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">       <span class="comment">// return + 返回条件</span></span><br><span class="line">       <span class="keyword">return</span> u &gt; v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>, cmp&gt; s; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    s.<span class="built_in">insert</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">// 10 9 8 7 6 5 4 3 2 1</span></span><br></pre></td></tr></table></figure><p>方式三：初始化时使用匿名函数定义比较规则</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>, function&lt;<span class="type">bool</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; <span class="built_in">s</span>([&amp;](<span class="type">int</span> i, <span class="type">int</span> j)&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j; <span class="comment">// 从大到小</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">    s.<span class="built_in">insert</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : s)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>高级数据类型（结构体）</strong></li></ul><p>直接重载结构体运算符即可，让结构体可以比较。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point &amp;p) <span class="type">const</span> &#123;</span><br><span class="line"><span class="comment">// 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大</span></span><br><span class="line"><span class="keyword">if</span>(x == p.x)</span><br><span class="line"><span class="keyword">return</span> y &lt; p.y;</span><br><span class="line"><span class="keyword">return</span> x &lt; p.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;Point&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    s.<span class="built_in">insert</span>(&#123;x, y&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输入</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">    cout &lt;&lt; i.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i.y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">4 8</span></span><br><span class="line"><span class="comment">5 2</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="7-5-其它set"><a href="#7-5-其它set" class="headerlink" title="7.5 其它set"></a>7.5 其它set</h2><p><code>multiset</code>:元素可以重复，且元素有序</p><p><code>unordered_set</code>  ：元素无序且只能出现一次</p><p><code>unordered_multiset</code> ：  元素无序可以出现多次</p><h1 id="8-pair"><a href="#8-pair" class="headerlink" title="8 pair"></a>8 pair</h1><h2 id="8-1-介绍"><a href="#8-1-介绍" class="headerlink" title="8.1 介绍"></a>8.1 介绍</h2><p>pair只含有两个元素，可以看作是只有两个元素的结构体。</p><p><strong>应用：</strong></p><ul><li>代替二元结构体</li><li>作为map键值对进行插入（代码如下）</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt;mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;xingmaqi&quot;</span>,<span class="number">1</span>));</span><br><span class="line"><span class="comment">// mp.insert(make_pair(&quot;xingmaqi&quot;, 1));</span></span><br><span class="line"><span class="comment">// mp.insert(&#123;&quot;xingmaqi&quot;, 1&#125;);</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化定义</span></span><br><span class="line"><span class="function">pair&lt;string,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;wangyaqi&quot;</span>,<span class="number">1</span>)</span></span>;<span class="comment">//带初始值的</span></span><br><span class="line">pair&lt;string,<span class="type">int</span>&gt; p;<span class="comment">//不带初始值的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.赋值</span></span><br><span class="line">p = &#123;<span class="string">&quot;wang&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="string">&quot;wang&quot;</span>, <span class="number">18</span>);</span><br><span class="line">p = <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;wang&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure><h2 id="8-2-访问"><a href="#8-2-访问" class="headerlink" title="8.2 访问"></a>8.2 访问</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义结构体数组</span></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"><span class="comment">//和结构体类似，first代表第一个元素，second代表第二个元素</span></span><br><span class="line">cout &lt;&lt; p[i].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p[i].second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-string"><a href="#9-string" class="headerlink" title="9 string"></a>9 string</h1><h2 id="9-1-介绍"><a href="#9-1-介绍" class="headerlink" title="9.1 介绍"></a>9.1 介绍</h2><p>string是一个字符串类，和<code>char</code>型字符串类似。</p><p>可以把string理解为一个字符串类型，像int一样可以定义</p><h2 id="9-2-初始化及定义"><a href="#9-2-初始化及定义" class="headerlink" title="9.2 初始化及定义"></a>9.2 初始化及定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line">string str1; <span class="comment">//生成空字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>; <span class="comment">//生成&quot;1234456789&quot;的复制品 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.</span></span><br><span class="line"><span class="function">string <span class="title">str3</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;<span class="comment">//结果为&quot;123&quot; ，从0位置开始，长度为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.</span></span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;123456&quot;</span>, <span class="number">5</span>)</span></span>; <span class="comment">//结果为&quot;12345&quot; ，长度为5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.</span></span><br><span class="line"><span class="function">string <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;2&#x27;</span>)</span></span>; <span class="comment">//结果为&quot;22222&quot; ,构造5个字符&#x27;2&#x27;连接而成的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.</span></span><br><span class="line"><span class="function">string <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>; <span class="comment">//结果为&quot;3456789&quot;，截取第三个元素（2对应第三位）到最后</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>简单使用</strong></p><ul><li>访问单个字符：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s = <span class="string">&quot;xing ma qi!!!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">cout &lt;&lt; s[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>string</code> 数组使用：</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">s[i] = <span class="string">&quot;loading...  &quot;</span> ;</span><br><span class="line">cout &lt;&lt; s[i] &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loading...  1</span><br><span class="line">loading...  2</span><br><span class="line">loading...  3</span><br><span class="line">loading...  4</span><br><span class="line">loading...  5</span><br><span class="line">loading...  6</span><br><span class="line">loading...  7</span><br><span class="line">loading...  8</span><br><span class="line">loading...  9</span><br></pre></td></tr></table></figure><h2 id="9-3-string-特性"><a href="#9-3-string-特性" class="headerlink" title="9.3 string 特性"></a>9.3 string 特性</h2><ul><li><p>支持<strong>比较</strong>运算符<br>string字符串支持常见的比较操作符<code>（&gt;,&gt;=,&lt;,&lt;=,==,!=）</code>，支持<code>string</code>与<code>C-string</code>的比较（如 <code>str &lt; &quot;hello&quot;</code>）。<br>在使用<code>&gt;,&gt;=,&lt;,&lt;=</code>这些操作符的时候是根据“当前字符特性”将字符按 <code>字典顺序</code> 进行逐一得 比较。字典排序靠前的字符小， 比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小（前面减后面）。</p><p>同时，<code>string (&quot;aaaa&quot;) &lt;string(aaaaa)</code>。</p></li><li><p>支持<code>+</code><strong>运算</strong>符，代表拼接字符串<br>string字符串可以拼接，通过”+”运算符进行拼接。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;456&quot;</span>;</span><br><span class="line">string s = s1 + s2;</span><br><span class="line">cout &lt;&lt; s;   <span class="comment">//123456</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="9-4-读入详解"><a href="#9-4-读入详解" class="headerlink" title="9.4 读入详解"></a>9.4 读入详解</h2><p><strong>读入字符串，遇空格，回车结束</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br></pre></td></tr></table></figure><p> <strong>读入一行字符串（包括空格），遇回车结束</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br></pre></td></tr></table></figure><p>注意: <code>getline(cin, s)</code>会获取前一个输入的换行符，需要在前面添加读取换行符的语句。如：<code>getchar()</code> 或<code> cin.get()</code></p><p>错误读取：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">getline</span>(cin, s); <span class="comment">//此时读取相当于读取了前一个回车字符</span></span><br></pre></td></tr></table></figure><p>正确读取：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">getchar</span>(); <span class="comment">//cin.get()</span></span><br><span class="line"><span class="built_in">getline</span>(cin, s);<span class="comment">//可正确读入下一行的输入</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cin</code>与<code>cin.getline()</code>混用</p><p>cin输入完后，回车，cin遇到回车结束输入，但回车还在输入流中，cin并不会清除，导致<code>getline()</code>读取回车，结束。<br>需要在cin后面加<code>cin.ignore()</code>；主动删除输入流中的换行符。（不常用）</p></blockquote><p><strong>cin和cout解锁</strong></p><p>代码（写在main函数开头）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>为什么要进行<code>cin</code>和<code>cout</code>的解锁，原因是：</p><p>在一些题目中，读入的<strong>数据量很大</strong>，往往超过了1e5（10^5^）的数据量,而<code>cin</code>和<code>cout</code>的读入输出的速度<strong>很慢</strong>（是因为<code>cin</code>和<code>cout</code>为了兼容C语言的读入输出在性能上做了妥协），远不如<code>scanf</code>和<code>printf</code>的速度，具体原因可以搜索相关的博客进行了解。</p><p><strong>所以</strong>对<code>cin</code>和<code>cout</code>进行解锁使<code>cin</code>和<code>cout</code>的速度几乎接近<code>scanf</code>和<code>printf</code>，避免输入输出超时。</p></blockquote><p><strong>注意</strong>：<code>cin cout</code>解锁使用时，不能与 <code>scanf,getchar, printf,cin.getline()</code>混用，一定要注意，会出错。</p><blockquote><p><strong>string与C语言字符串（C-string）的区别</strong></p><ul><li>string<br>是C++的一个类，专门实现字符串的相关操作。具有丰富的操作方法，数据类型为<code>string</code>，字符串结尾没有<code>\0</code>字符</li><li>C-string<br>C语言中的字符串，用char数组实现，类型为<code>const char *</code>,字符串结尾以<code>\0</code>结尾</li></ul></blockquote><p>一般来说string向char数组转换会出现一些问题，所以为了能够实现转换，string有一个方法<code>c_str()</code>实现string向char数组的转换。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;xing ma qi&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = s.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure><h2 id="9-5-函数方法"><a href="#9-5-函数方法" class="headerlink" title="9.5 函数方法"></a>9.5 函数方法</h2><ul><li><strong>获取字符串长度</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.size()</code>和<code>s.length()</code></td><td>返回string对象的字符个数，他们执行效果相同。</td></tr><tr><td><code>s.max_size()</code></td><td>返回string对象最多包含的字符数，超出会抛出length_error异常</td></tr><tr><td><code>s.capacity()</code></td><td>重新分配内存之前，string对象能包含的最大字符数</td></tr></tbody></table><ul><li><strong>插入</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.push_back()</code></td><td>在末尾插入</td></tr><tr><td>例：<code>s.push_back(&#39;a&#39;)</code></td><td>末尾插入一个字符a</td></tr><tr><td><code>s.insert(pos,element)</code></td><td>在pos位置插入element</td></tr><tr><td>例：<code>s.insert(s.begin(),&#39;1&#39;)</code></td><td>在第一个位置插入1字符</td></tr><tr><td><code>s.append(str)</code></td><td>在s字符串结尾添加str字符串</td></tr><tr><td>例：<code>s.append(&quot;abc&quot;)</code></td><td>在s字符串末尾添加字符串“abc”</td></tr></tbody></table><ul><li><strong>删除</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>erase(iterator p)</code></td><td>删除字符串中p所指的字符</td></tr><tr><td><code>erase(iterator first, iterator last)</code></td><td>删除字符串中迭代器区间<code>[first,last)</code>上所有字符</td></tr><tr><td><code>erase(pos,  len)</code></td><td>删除字符串中从索引位置pos开始的len个字符</td></tr><tr><td><code>clear()</code></td><td>删除字符串中所有字符</td></tr></tbody></table><ul><li><strong>字符替换</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.replace(pos,n,str)</code></td><td>把当前字符串从索引pos开始的n个字符替换为str</td></tr><tr><td><code>s.replace(pos,n,n1,c)</code></td><td>把当前字符串从索引pos开始的n个字符替换为n1个字符c</td></tr><tr><td><code>s.replace(it1,it2,str)</code></td><td>把当前字符串<code>[it1,it2)</code>区间替换为str    <strong>it1 ,it2为迭代器哦</strong></td></tr></tbody></table><ul><li><strong>大小写转换</strong></li></ul><p>法一：</p><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>tolower(s[i])</code></td><td>转换为小写</td></tr><tr><td><code>toupper(s[i])</code></td><td>转换为大写</td></tr></tbody></table><p>法二：</p><p>通过stl的<code>transform</code>算法配合<code>tolower</code> 和<code>toupper</code> 实现。<br>有4个参数，前2个指定要转换的容器的起止范围，第3个参数是结果存放容器的起始位置，第4个参数是一元运算。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::tolower);<span class="comment">//转换小写</span></span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),s.<span class="built_in">begin</span>(),::toupper);<span class="comment">//转换大写</span></span><br></pre></td></tr></table></figure><ul><li><strong>分割</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.substr(pos,n)</code></td><td>截取从pos索引开始的n个字符</td></tr></tbody></table><ul><li><strong>查找</strong></li></ul><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>s.find (str,  pos)</code></td><td>在当前字符串的pos索引位置（默认为0）开始，查找子串str，返回找到的位置索引，-1表示查找不到子串</td></tr><tr><td><code>s.find (c, pos)</code></td><td>在当前字符串的pos索引位置（默认为0）开始，查找字符c，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><td><code>s.rfind (str, pos)</code></td><td>在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到子串</td></tr><tr><td><code>s.rfind (c,pos)</code></td><td>在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><td><code>s.find_first_of (str, pos)</code></td><td>在当前字符串的pos索引位置（默认为0）开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><td><code>s.find_first_not_of (str,pos)</code></td><td>在当前字符串的pos索引位置（默认为0）开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><td><code>s.find_last_of(str, pos)</code></td><td>在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</td></tr><tr><td><code>s.find_last_not_of ( str, pos)</code></td><td>在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;dog bird chicken bird cat&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//字符串查找-----找到后返回首字母在字符串中的下标</span></span><br><span class="line"><span class="comment">// 1. 查找一个字符串</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&quot;chicken&quot;</span>) &lt;&lt; endl;<span class="comment">// 结果是：9</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2. 从下标为6开始找字符&#x27;i&#x27;，返回找到的第一个i的下标</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find</span>(<span class="string">&#x27;i&#x27;</span>,<span class="number">6</span>) &lt;&lt; endl;<span class="comment">// 结果是：11</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">rfind</span>(<span class="string">&quot;chicken&quot;</span>) &lt;&lt; endl;<span class="comment">// 结果是：9</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 4. 从字符串的末尾开始查找字符</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">rfind</span>(<span class="string">&#x27;i&#x27;</span>) &lt;&lt; endl;<span class="comment">// 结果是：18因为是从末尾开始查找，所以返回第一次找到的字符</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 5. 在该字符串中查找第一个属于字符串s的字符</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_first_of</span>(<span class="string">&quot;13br98&quot;</span>) &lt;&lt; endl;<span class="comment">// 结果是：4---b</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;hello dog 2006&quot;</span>) &lt;&lt; endl; <span class="comment">// 结果是：4</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;dog bird 2006&quot;</span>) &lt;&lt; endl;  <span class="comment">// 结果是：9</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 7. 在该字符串最后中查找第一个属于字符串s的字符</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_last_of</span>(<span class="string">&quot;13r98&quot;</span>) &lt;&lt; endl;<span class="comment">// 结果是：19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">find_last_not_of</span>(<span class="string">&quot;teac&quot;</span>) &lt;&lt; endl;<span class="comment">// 结果是：21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>排序</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());  <span class="comment">//按ASCII码排序</span></span><br></pre></td></tr></table></figure><h1 id="10-bitset"><a href="#10-bitset" class="headerlink" title="10 bitset"></a>10 bitset</h1><h2 id="10-1-介绍"><a href="#10-1-介绍" class="headerlink" title="10.1 介绍"></a>10.1 介绍</h2><p>bitset 在 bitset 头文件中，它类似数组，并且每一个元素只能是０或１，每个元素只用１bit空间</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="10-2-初始化定义"><a href="#10-2-初始化定义" class="headerlink" title="10.2 初始化定义"></a>10.2 初始化定义</h2><p>初始化方法</p><table><thead><tr><th>代码</th><th>含义</th></tr></thead><tbody><tr><td><code>bitset&lt;n&gt; a</code></td><td>a有n位，每位都为0</td></tr><tr><td><code>bitset&lt;n&gt; a(b)</code></td><td>a是unsigned long型u的一个副本</td></tr><tr><td><code>bitset&lt;n&gt; a(s)</code></td><td>a是string对象s中含有的位串的副本</td></tr><tr><td><code>bitset&lt;n&gt; a(s, pos, n)</code></td><td>a是s中从位置pos开始的n个位的副本</td></tr></tbody></table><blockquote><p>注意：<code>n</code>必须为常量表达式</p></blockquote><p>演示代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">bitset&lt;4&gt; bitset1;　　  <span class="comment">//无参构造，长度为４，默认每一位为0</span></span><br><span class="line"></span><br><span class="line"><span class="function">bitset&lt;9&gt; <span class="title">bitset2</span><span class="params">(<span class="number">12</span>)</span></span>;　<span class="comment">//长度为9，二进制保存，前面用0补充</span></span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;100101&quot;</span>;</span><br><span class="line"><span class="function">bitset&lt;10&gt; <span class="title">bitset3</span><span class="params">(s)</span></span>;　　<span class="comment">//长度为10，前面用0补充</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;10101&quot;</span>;</span><br><span class="line"><span class="function">bitset&lt;13&gt; <span class="title">bitset4</span><span class="params">(s2)</span></span>;　　<span class="comment">//长度为13，前面用0补充</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; bitset1 &lt;&lt; endl;　　<span class="comment">//0000</span></span><br><span class="line">cout &lt;&lt; bitset2 &lt;&lt; endl;　　<span class="comment">//000001100</span></span><br><span class="line">cout &lt;&lt; bitset3 &lt;&lt; endl;　　<span class="comment">//0000100101</span></span><br><span class="line">cout &lt;&lt; bitset4 &lt;&lt; endl;　<span class="comment">//0000000010101</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-特性"><a href="#10-3-特性" class="headerlink" title="10.3 特性"></a>10.3 特性</h2><p><code>bitset</code>可以进行<strong>位操作</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">foo</span> <span class="params">(string(<span class="string">&quot;1001&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">bar</span> <span class="params">(string(<span class="string">&quot;0011&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo ^= bar) &lt;&lt; endl;<span class="comment">// 1010 (foo对bar按位异或后赋值给foo)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo &amp;= bar) &lt;&lt; endl;<span class="comment">// 0001 (按位与后赋值给foo)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo |= bar) &lt;&lt; endl;<span class="comment">// 1011 (按位或后赋值给foo)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo&lt;&lt;=<span class="number">2</span>) &lt;&lt; endl;<span class="comment">// 0100 (左移2位，低位补0，有自身赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo&gt;&gt;=<span class="number">1</span>) &lt;&lt; endl;<span class="comment">// 0100 (右移1位，高位补0，有自身赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (~bar) &lt;&lt; endl;<span class="comment">// 1100 (按位取反)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (bar&lt;&lt;<span class="number">1</span>) &lt;&lt; endl;<span class="comment">// 0110 (左移，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (bar&gt;&gt;<span class="number">1</span>) &lt;&lt; endl;<span class="comment">// 0001 (右移，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo==bar) &lt;&lt; endl;<span class="comment">// false (1001==0011为false)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo!=bar) &lt;&lt; endl;<span class="comment">// true  (1001!=0011为true)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo&amp;bar) &lt;&lt; endl;<span class="comment">// 0001 (按位与，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo|bar) &lt;&lt; endl;<span class="comment">// 1011 (按位或，不赋值)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo^bar) &lt;&lt; endl;<span class="comment">// 1010 (按位异或，不赋值)</span></span><br></pre></td></tr></table></figure><p><strong>访问</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以通过 [] 访问元素(类似数组)，注意最低位下标为0，类似于数的二进制表示，如下：</span></span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">f</span><span class="params">(<span class="string">&quot;1011&quot;</span>)</span></span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">    cout &lt;&lt; f[i];</span><br><span class="line">&#125; <span class="comment">// 输出1101</span></span><br></pre></td></tr></table></figure><h2 id="10-4-方法函数"><a href="#10-4-方法函数" class="headerlink" title="10.4 方法函数"></a>10.4 方法函数</h2><table><thead><tr><th align="center">代码</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>b.any()</code></td><td align="center">b中是否存在置为1的二进制位，有 返回true</td></tr><tr><td align="center"><code>b.none()</code></td><td align="center">b中是否没有1，没有 返回true</td></tr><tr><td align="center"><code>b.count()</code></td><td align="center">b中为1的个数</td></tr><tr><td align="center"><code>b.size()</code></td><td align="center">b中二进制位的个数</td></tr><tr><td align="center"><code>b.test(pos)</code></td><td align="center">测试b在pos位置是否为1，是 返回true</td></tr><tr><td align="center"><code>b[pos]</code></td><td align="center">返回b在pos处的二进制位</td></tr><tr><td align="center"><code>b.set()</code></td><td align="center">把b中所有位都置为1</td></tr><tr><td align="center"><code>b.set(pos)</code></td><td align="center">把b中pos位置置为1</td></tr><tr><td align="center"><code>b.reset()</code></td><td align="center">把b中所有位都置为0</td></tr><tr><td align="center"><code>b.reset(pos)</code></td><td align="center">把b中pos位置置为0</td></tr><tr><td align="center"><code>b.flip()</code></td><td align="center">把b中所有二进制位取反</td></tr><tr><td align="center"><code>b.flip(pos)</code></td><td align="center">把b中pos位置取反</td></tr><tr><td align="center"><code>b.to_ulong()</code></td><td align="center">用b中同样的二进制位返回一个unsigned long值</td></tr></tbody></table><h2 id="10-5-bitset优化"><a href="#10-5-bitset优化" class="headerlink" title="10.5 bitset优化"></a>10.5 bitset优化</h2><p>一般会使用bitset来优化时间复杂度，大概时间复杂度会除64或32，例如没有优化的时间复杂度为 $O(NM)$ ，使用bitset优化后复杂度可能就为 $O(\frac{NM}{64})$</p><p>bitset还有开动态空间的技巧，bitset常用在<code>01背包</code>优化等算法中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态长度bitset实现</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>; <span class="comment">// 开空间的上限，一般为数据范围附近的值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> len = <span class="number">1</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">bitset_</span>(<span class="type">int</span> sz) &#123; <span class="comment">// sz即为想要开的大小</span></span><br><span class="line"><span class="keyword">if</span> (len &lt; sz) &#123; <span class="built_in">bitset_</span>&lt;<span class="built_in">min</span>(len * <span class="number">2</span>, N)&gt;(sz); <span class="keyword">return</span>; &#125;</span><br><span class="line">bitset&lt;len + 1&gt; dp;</span><br><span class="line"><span class="comment">// 具体算法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-array"><a href="#11-array" class="headerlink" title="11 array"></a>11 array</h1><h2 id="11-1-介绍"><a href="#11-1-介绍" class="headerlink" title="11.1 介绍"></a>11.1 介绍</h2><p>头文件</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br></pre></td></tr></table></figure><p><code>array</code>是C++11新增的容器，效率与普通数据相差无几，比<code>vector</code>效率要高，自身添加了一些成员函数。</p><p>和其它容器不同，array 容器的大小是<strong>固定</strong>的，无法动态的扩展或收缩，<strong>只允许访问或者替换存储的元素。</strong></p><p><strong>注意：</strong></p><p><code>array</code>的使用要在<code>std</code>命名空间里</p><h2 id="11-2-声明与初始化"><a href="#11-2-声明与初始化" class="headerlink" title="11.2 声明与初始化"></a>11.2 声明与初始化</h2><p><strong>基础数据类型</strong></p><p>声明一个大小为100的<code>int</code>型数组，元素的值不确定</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a;</span><br></pre></td></tr></table></figure><p>声明一个大小为100的<code>int</code>型数组，初始值均为<code>0</code>(初始值与默认元素类型等效)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a&#123;&#125;;</span><br></pre></td></tr></table></figure><p>声明一个大小为100的<code>int</code>型数组，初始化部分值，其余全部为<code>0</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p>或者可以用等号</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 100&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>高级数据类型</strong></p><p>不同于数组的是对元素类型不做要求，可以套结构体</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;string, 2&gt; s = &#123;<span class="string">&quot;ha&quot;</span>, <span class="built_in">string</span>(<span class="string">&quot;haha&quot;</span>)&#125;;</span><br><span class="line">array&lt;node, 2&gt; a;</span><br></pre></td></tr></table></figure><h2 id="11-3-存取元素"><a href="#11-3-存取元素" class="headerlink" title="11.3 存取元素"></a>11.3 存取元素</h2><ul><li>修改元素</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><ul><li>访问元素</li></ul><p>下标访问</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>利用<code>auto</code>访问</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p>迭代器访问</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = a.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span>(; it != a.<span class="built_in">end</span>(); it++) </span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p> <code>at()</code>函数访问</p><p>下标为<code>1</code>的元素加上下标为<code>2</code>的元素，答案为<code>5</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> res = a.<span class="built_in">at</span>(<span class="number">1</span>) + a.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p> <code>get</code>方法访问</p><p>将<code>a</code>数组下标为<code>1</code>位置处的值改为<code>x</code></p><p>注意：获取的下标只能写数字，不能填变量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(a) = x;</span><br></pre></td></tr></table></figure><h2 id="11-4-成员函数"><a href="#11-4-成员函数" class="headerlink" title="11.4 成员函数"></a>11.4 成员函数</h2><table><thead><tr><th>成员函数</th><th>功能</th></tr></thead><tbody><tr><td><code>begin()</code></td><td>返回容器中第一个元素的访问迭代器（地址）</td></tr><tr><td><code>end()</code></td><td>返回容器最后一个元素之后一个位置的访问迭代器（地址）</td></tr><tr><td><code>rbegin()</code></td><td>返回最后一个元素的访问迭代器（地址）</td></tr><tr><td><code>rend()</code></td><td>返回第一个元素之前一个位置的访问迭代器（地址）</td></tr><tr><td><code>size()</code></td><td>返回容器中元素的数量，其值等于初始化 array 类的第二个模板参数<code>N</code></td></tr><tr><td><code>max_size()</code></td><td>返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N</td></tr><tr><td><code>empty()</code></td><td>判断容器是否为空</td></tr><tr><td><code>at(n)</code></td><td>返回容器中 n 位置处元素的引用，函数会自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常</td></tr><tr><td><code>front()</code></td><td>返回容器中第一个元素的直接引用，函数不适用于空的 array 容器</td></tr><tr><td><code>back()</code></td><td>返回容器中最后一个元素的直接引用，函数不适用于空的 array 容器。</td></tr><tr><td><code>data()</code></td><td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能</td></tr><tr><td><code>fill(x)</code></td><td>将 <code>x</code> 这个值赋值给容器中的每个元素,相当于初始化</td></tr><tr><td><code>array1.swap(array2)</code></td><td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型</td></tr></tbody></table><h2 id="11-5-部分用法示例"><a href="#11-5-部分用法示例" class="headerlink" title="11.5 部分用法示例"></a>11.5 部分用法示例</h2><p><code>data()</code></p><p>指向底层元素存储的指针。对于非空容器，返回的指针与首元素地址比较相等。</p><p><code>at()</code></p><p>下标为<code>1</code>的元素加上下标为<code>2</code>的元素，答案为<code>5</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 4&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> res = a.<span class="built_in">at</span>(<span class="number">1</span>) + a.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p><code>fill()</code></p><p>array的<code>fill()</code>函数，将<code>a</code>数组全部元素值变为<code>x</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">fill</span>(x);</span><br></pre></td></tr></table></figure><p>另外还有其它的<code>fill()</code>函数:将<code>a</code>数组$[begin,end)$全部值变为<code>x</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fill</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), x);</span><br></pre></td></tr></table></figure><p><strong>get方法获取元素值</strong></p><p>将<code>a</code>数组下标为<code>1</code>位置处的值改为<code>x</code></p><p>注意:获取的下标只能写数字，不能填变量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(a) = x;</span><br></pre></td></tr></table></figure><p><strong>排序</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h1 id="12-tuple"><a href="#12-tuple" class="headerlink" title="12 tuple"></a>12 tuple</h1><h2 id="12-1-介绍"><a href="#12-1-介绍" class="headerlink" title="12.1 介绍"></a>12.1 介绍</h2><p>tuple模板是pair的泛化，可以封装不同类型任意数量的对象。</p><p>可以把tuple理解为pair的扩展，tuple可以声明二元组，也可以声明三元组。</p><p>tuple可以等价为<strong>结构体</strong>使用</p><p><strong>头文件</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="12-2-声明初始化"><a href="#12-2-声明初始化" class="headerlink" title="12.2 声明初始化"></a>12.2 声明初始化</h2><p>声明一个空的<code>tuple</code>三元组</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, string&gt; t1;</span><br></pre></td></tr></table></figure><p>赋值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">t1 = <span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;hahaha&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建的同时初始化</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>可以使用pair对象构造tuple对象，但tuple对象必须是两个元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_pair</span>(<span class="string">&quot;wang&quot;</span>, <span class="number">1</span>);</span><br><span class="line">tuple&lt;string, <span class="type">int</span>&gt; t3 &#123;p&#125;; <span class="comment">//将pair对象赋给tuple对象</span></span><br></pre></td></tr></table></figure><h2 id="12-3-元素操作"><a href="#12-3-元素操作" class="headerlink" title="12.3 元素操作"></a>12.3 元素操作</h2><p>获取tuple对象<code>t</code>的第一个元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> first = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t);</span><br></pre></td></tr></table></figure><p>修改tuple对象<code>t</code>的第一个元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t) = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="12-4-函数操作"><a href="#12-4-函数操作" class="headerlink" title="12.4 函数操作"></a>12.4 函数操作</h2><ul><li>获取元素个数</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; tuple_size&lt;<span class="keyword">decltype</span>(t)&gt;::value &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>获取对应元素的值</li></ul><p>通过<code>get&lt;n&gt;(obj)</code>方法获取,<code>n</code>必须为数字不能是变量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>tie</code>解包 获取元素值</li></ul><p><code>tie</code>可以让tuple变量中的三个值依次赋到tie中的三个变量中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> one, three;</span><br><span class="line">string two; </span><br><span class="line"><span class="function">tuple&lt;<span class="type">int</span>, string, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;hahaha&quot;</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">tie</span>(one, two, three) = t;</span><br><span class="line">cout &lt;&lt; one &lt;&lt; two &lt;&lt; three &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1hahaha3</span></span><br></pre></td></tr></table></figure><hr><h1 id="STL函数"><a href="#STL函数" class="headerlink" title="STL函数"></a>STL函数</h1><h2 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accumulate(beg, end, init)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> $O(N)$</p><blockquote><p>作用：对一个序列的元素求和</p></blockquote><p><code>init</code>为对序列元素求和的<strong>初始值</strong></p><p>返回值类型：与<code>init</code> 相同</p><ul><li><strong>基础累加求和：</strong></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对[0,2]区间求和，初始值为0，结果为0 + 1 + 3 + 5 = 9</span></span><br><span class="line"><span class="type">int</span> res1 = <span class="built_in">accumulate</span>(a, a + <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对[0,3]区间求和，初始值为5，结果为5 + 1 + 3 + 5 + 9 = 23</span></span><br><span class="line"><span class="type">int</span> res2 = <span class="built_in">accumulate</span>(a, a + <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>自定义二元对象求和：</strong></li></ul><p>使用lambda表达式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    ll num;</span><br><span class="line">&#125; st[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    st[i].num = i + <span class="number">10000000000</span>;</span><br><span class="line"><span class="comment">//返回值类型与init一致，同时注意参数类型（a）也要一样</span></span><br><span class="line"><span class="comment">//初始值为1，累加1+10000000001+10000000002+10000000003=30000000007</span></span><br><span class="line">ll res = <span class="built_in">accumulate</span>(st + <span class="number">1</span>, st + <span class="number">4</span>, <span class="number">1ll</span>, [](ll a,node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b.num;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a>atoi</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atoi(const char *)</span><br></pre></td></tr></table></figure><blockquote><p>将字符串转换为<code>int</code>类型</p></blockquote><p>注意参数为<code>char</code>型数组，如果需要将string类型转换为int类型，可以使用<code>stoi</code>函数（参考下文），或者将<code>string</code>类型转换为<code>const char *</code>类型。</p><p>关于输出数字的范围：<br><code>atoi</code><strong>不做</strong>范围检查，如果超出上界，输出上界，超出下界，输出下界。<br><code>stoi</code><strong>会做</strong>范围检查，默认必须在<code>int</code>范围内，如果超出范围，会出现RE（Runtime Error）错误。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">atoi</span>(s);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fill(beg, end, num)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> $O(N)$</p><blockquote><p>对一个序列进行初始化赋值</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对a数组的所有元素赋1</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">fill</span>(a, a + <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 1 1 1 1</span></span><br></pre></td></tr></table></figure><p>注意区分memset：</p><p><code>memset()</code>是按<strong>字节</strong>进行赋值，对于初始化赋<code>0</code>或<code>-1</code>有比较好的效果.</p><p>如果赋某个特定的数会<strong>出错</strong>，赋值特定的数建议使用<code>fill()</code></p><h2 id="is-sorted"><a href="#is-sorted" class="headerlink" title="is_sorted"></a>is_sorted</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">is_sorted(beg, end)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> $O(N)$</p><blockquote><p>判断序列是否有序（升序），返回<code>bool</code>值</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果序列有序，输出YES</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">is_sorted</span>(a, a + n))</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iota(beg, end)</span><br></pre></td></tr></table></figure><blockquote><p>让序列递增赋值</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i : a)</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure><h2 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound + upper_bound"></a>lower_bound + upper_bound</h2><p><strong>复杂度：</strong> $O(logN)$</p><blockquote><p>作用：二分查找</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在a数组中查找第一个大于等于x的元素，返回该元素的地址</span></span><br><span class="line"><span class="built_in">lower_bound</span>(a, a + n, x);</span><br><span class="line"><span class="comment">//在a数组中查找第一个大于x的元素，返回该元素的地址</span></span><br><span class="line"><span class="built_in">upper_bound</span>(a, a + n, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果未找到，返回尾地址的下一个位置的地址</span></span><br></pre></td></tr></table></figure><h2 id="max-element-min-element"><a href="#max-element-min-element" class="headerlink" title="max_element+min_element"></a>max_element+min_element</h2><p><strong>复杂度：</strong> $O(N)$</p><blockquote><p>找最大最小值</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数都是返回地址，需要加*取值</span></span><br><span class="line"><span class="type">int</span> mx = *<span class="built_in">max_element</span>(a, a + n);</span><br><span class="line"><span class="type">int</span> mn = *<span class="built_in">min_element</span>(a, a + n);</span><br></pre></td></tr></table></figure><h2 id="max-min"><a href="#max-min" class="headerlink" title="max+min"></a>max+min</h2><p><strong>复杂度：</strong> $O(1)$</p><blockquote><p>找多个元素的最大值和最小值</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找a，b的最大值和最小值</span></span><br><span class="line">mx = <span class="built_in">max</span>(a, b);</span><br><span class="line">mn = <span class="built_in">min</span>(a, b);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找到a,b,c,d的最大值和最小值</span></span><br><span class="line">mx = <span class="built_in">max</span>(&#123;a, b, c, d&#125;);</span><br><span class="line">mn = <span class="built_in">min</span>(&#123;a, b, c, d&#125;);</span><br></pre></td></tr></table></figure><h2 id="minmax"><a href="#minmax" class="headerlink" title="minmax"></a>minmax</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minmax(a, b)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> $O(1)$</p><blockquote><p>返回一个<code>pair</code>类型，第一个元素是<code>min(a, b)</code>， 第二个元素是<code>max(a, b)</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; t = <span class="built_in">minmax</span>(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// t.first = 2, t.second = 4</span></span><br></pre></td></tr></table></figure><h2 id="minmax-element"><a href="#minmax-element" class="headerlink" title="minmax_element"></a>minmax_element</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minmax_element(beg, end)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> $O(N)$</p><blockquote><p>返回序列中的最小和最大值组成pair的对应的地址，返回类型为<code>pair&lt;vector&lt;int&gt;::iterator, vector&lt;int&gt;::iterator&gt;</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">minmax_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 返回的是最小值和最大值对应的地址</span></span><br><span class="line"><span class="comment">// *t.first = 1, *t.second = 10 输出对应最小最大值时需要使用指针</span></span><br></pre></td></tr></table></figure><h2 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nth_element(beg, nth, end)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> 平均$O(N)$</p><blockquote><p>寻找第序列第n小的值</p></blockquote><p><code>nth</code>为一个迭代器，指向序列中的一个元素。第n小的值恰好在<code>nth</code>位置上。</p><p>执行<code>nth_element()</code>之后，序列中的元素会围绕nth进行划分：<strong>nth之前的元素都小于等于它，而之后的元素都大于等于它</strong></p><p><strong>实例：求序列中的第3小的元素</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nth_element</span>(a, a + <span class="number">2</span>, a + n);</span><br><span class="line">cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">next_permutation(beg, end)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> $O(N)$</p><blockquote><p>求序列的下一个排列，下一个排列是字典序大一号的排列</p></blockquote><p>返回<code>true</code>或<code>false</code></p><ul><li><p><code>next_permutation(beg, end)</code></p><p>如果是最后一个排列，返回<code>false</code>,否则求出下一个序列后，返回<code>true</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对a序列进行重排</span></span><br><span class="line"><span class="built_in">next_permutation</span>(a, a + n);</span><br></pre></td></tr></table></figure><p><strong>应用：求所有的排列</strong></p><p>输出<code>a</code>的所有排列</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组a不一定是最小字典序序列，一定注意将它排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="built_in">next_permutation</span>(a, a + n));</span><br></pre></td></tr></table></figure><ul><li><code>prev_permutation(beg, end)</code></li></ul><blockquote><p>求出前一个排列，如果序列为最小的排列，将其重排为最大的排列，返回false</p></blockquote><h2 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a>partial_sort</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">partial_sort(beg, mid, end)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> 大概$O(N logM)$ <code>M</code>为距离</p><blockquote><p>部分排序,排序mid-beg个元素，mid为要排序区间元素的尾后的一个位置</p><p>从beg到mid<strong>前</strong>的元素都排好序</p></blockquote><p>对a数组前5个元素排序按从小到大排序</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">partial_sort</span>(a, a + <span class="number">5</span>, a + <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">//1 2 3 4 5 9 8 10 7 6</span></span><br><span class="line"><span class="comment">//前五个元素都有序</span></span><br></pre></td></tr></table></figure><p>也可以添加自定义排序规则：</p><p> <code>partial_sort(beg,mid,end,cmp)</code></p><p>对a的前五个元素都是降序排列</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">partial_sort</span>(a, a + <span class="number">5</span>, a + <span class="number">10</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">//10 9 8 7 6 1 2 4 5 3</span></span><br><span class="line"><span class="comment">//前五个元素降序有序</span></span><br></pre></td></tr></table></figure><h2 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h2><p><strong>复杂度：</strong> $O(N)$</p><blockquote><ol><li>随机打乱序列的顺序</li><li><code>random_shuffle</code> 在 <code>C++14</code> 中被弃用，在 <code>C++17</code> 中被废除，C++11之后应尽量使用<code>shuffle</code>来代替。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="number">1</span>);<span class="comment">// 序列b递增赋值 1, 2, 3, 4,...</span></span><br><span class="line"><span class="comment">// 对a数组随机重排</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(a, a + n);</span><br><span class="line"><span class="comment">// C++11之后尽量使用shuffle</span></span><br><span class="line"><span class="built_in">shuffle</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reverse(beg,end)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> $O(N)$</p><blockquote><p>对序列进行翻转</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());<span class="comment">//对s进行翻转</span></span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//edcba</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对a数组进行翻转</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">reverse</span>(a, a + <span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; a[<span class="number">1</span>] &lt;&lt; a[<span class="number">2</span>] &lt;&lt; a[<span class="number">3</span>];<span class="comment">//4321</span></span><br></pre></td></tr></table></figure><h2 id="set-union-set-intersection-set-difference"><a href="#set-union-set-intersection-set-difference" class="headerlink" title="set_union, set_intersection,set_difference"></a>set_union, set_intersection,set_difference</h2><p>复杂度： $O(N+M)$ </p><blockquote><p>求两个集合的并集，交集，差集。手动实现双指针就可以搞定，嫌麻烦可以使用该函数。</p></blockquote><p>注意：两个集合必须为有序集合，所以下面演示代码使用了排序。vector容器可以替换成set容器，因为set自动会对元素进行排序。</p><p>函数的参数有五个，前两个为第一个容器的首尾迭代器，第三四个为第二个容器的首尾迭代器，最后一个为插入位置，即将结果插入到哪个地址之后。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>&#125;, b = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()); <span class="comment">// 1 2 4 5 8</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()); <span class="comment">// 2 3 5 8 9</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c, d, e;</span><br><span class="line"><span class="comment">// a并b：1 2 3 4 5 8 9</span></span><br><span class="line"><span class="built_in">set_union</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(c, c.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// a交b：2 5 8</span></span><br><span class="line"><span class="built_in">set_intersection</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(d, d.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="comment">// a差b： 1 4</span></span><br><span class="line"><span class="built_in">set_difference</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), <span class="built_in">inserter</span>(e, e.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><strong>复杂度：</strong> $O(N logN)$</p><blockquote><p>作用：对一个序列进行排序</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="built_in">sort</span>(beg, end);</span><br><span class="line"><span class="built_in">sort</span>(beg, end, cmp);</span><br></pre></td></tr></table></figure><p>几种排序的常见操作：</p><ul><li>操作一：对数组正常升序排序</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 普通数组定义</span></span><br><span class="line"><span class="comment">// 对 a 数组的[1, n]位置进行从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// vector数组定义</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><ul><li>操作二：使用第三个参数，进行降序排序</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对a数组的[0, n-1]位置从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="comment">//对a数组的[0, n-1]位置从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>()); <span class="comment">// 升序</span></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>() + <span class="number">1</span>, b.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 降序</span></span><br></pre></td></tr></table></figure><ul><li>操作三：另外一种降序排序方法，针对 <code>vector</code></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">rbegin</span>(), a.<span class="built_in">rend</span>()); <span class="comment">// 使用反向迭代器进行降序排序</span></span><br></pre></td></tr></table></figure><ul><li>操作四：自定义排序规则</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 使用函数自定义排序，定义比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按结构体里面的x值降序排列</span></span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(node, node + n, cmp); <span class="comment">// 只能接受 以函数为形式的自定义排序规则，无法接受以结构体为形式的自定义排序规则</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 或者使用匿名函数自定义排序规则</span></span><br><span class="line"><span class="built_in">sort</span>(node, node + n, [](node a, node b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="stable-sort"><a href="#stable-sort" class="headerlink" title="stable_sort"></a>stable_sort</h2><p><strong>复杂度：</strong> $O(N logN)$</p><blockquote><p>功能和 <code>sort()</code> 基本一样</p><p>区别在于<code>stable_sort()</code>能够保证相等元素的相对位置，排序时不会改变相等元素的相对位置</p></blockquote><p>使用用法和<code>sort()</code>一样，见上</p><h2 id="stoi"><a href="#stoi" class="headerlink" title="stoi"></a>stoi</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stoi(const string*)</span><br></pre></td></tr></table></figure><blockquote><p>将对应string类型字符串转换为数字（<code>int</code> 型），记忆：<code>s -&gt; t 分别对应两个数据类型的某个字母</code></p></blockquote><p>注意参数为<code>string</code>字符串类型。</p><p>如果要转换为其他类型的数字可使用 <code>stoll(转换为long long)</code> ， <code>stoull(转换为unsigned long long)</code> 等函数。</p><p>关于输出数字的范围：</p><ul><li><p><code>stoi</code><strong>会做</strong>范围检查，默认必须在<code>int</code>范围内，如果超出范围，会出现RE（Runtime Error）错误。</p></li><li><p><code>atoi</code><strong>不做</strong>范围检查，如果超出上界，输出上界，超出下界，输出下界。</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">stoi</span>(s);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 1234</span></span><br></pre></td></tr></table></figure><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p><strong>复杂度：</strong> $O(N)$</p><blockquote><p>作用：使用给定操作，将结果写到dest中</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型：</span></span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, unaryOp);</span><br></pre></td></tr></table></figure><p>一般不怎么使用，徒增记忆负担，不如手动实现。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将序列开始地址beg到结束地址end大小写转换，把结果存到起始地址为dest的序列中</span></span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, ::tolower);</span><br><span class="line"><span class="built_in">transform</span>(beg, end, dest, ::toupper);</span><br></pre></td></tr></table></figure><h2 id="to-string"><a href="#to-string" class="headerlink" title="to_string"></a>to_string</h2><blockquote><p>将数字转化为字符串，支持小数（double）</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">12345678</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">to_string</span>(a) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unique(beg, end)</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong> $O(N)$</p><blockquote><p>消除重复元素，返回消除完重复元素的下一个位置的地址</p><p>如：<code>a[] = &#123;1, 3, 2, 3, 6&#125;</code>;</p><p><code>unique</code> 之后 <code>a</code> 数组为<code>&#123;1, 2, 3, 6, 3&#125;</code>前面为无重复元素的数组，后面则是重复元素移到后面，返回<code>a[4]</code>位置的地址（不重复元素的尾后地址）</p></blockquote><p>消除重复元素一般需要原序列是<strong>有序序列</strong></p><p><strong>应用：离散化</strong> </p><ul><li>方法一：利用数组离散化</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">    b[i] = a[i];<span class="comment">//将a数组复制到b数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序后 b：&#123;1, 2, 3, 3, 6&#125;</span></span><br><span class="line"><span class="built_in">sort</span>(b, b + n);<span class="comment">//对b数组排序</span></span><br><span class="line"><span class="comment">// 消除重复元素b：&#123;1, 2, 3, 6, 3&#125; 返回的地址为最后一个元素3的地址 </span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">unique</span>(b, b + n) - b;<span class="comment">//消除 b 的重复元素，并获取长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">//因为b有序，查找到的下标就是对应的 相对大小（离散化后的值）</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(b, b + len, a[i]) - b;<span class="comment">//在b数组中二分查找第一个大于等于a[i]的下标</span></span><br><span class="line">    a[i] = pos; <span class="comment">// 离散化赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：利用 <code>vector</code> 进行离散化</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b = a;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">b.<span class="built_in">erase</span>(<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">a[i] = <span class="built_in">lower_bound</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), a[i]) - b.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 离散后的数据从1开始   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gcd"><a href="#gcd" class="headerlink" title="__gcd"></a>__gcd</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__gcd(a, b)</span><br></pre></td></tr></table></figure><blockquote><p>求a和b的最大公约数</p></blockquote><p><code>__gcd(12,15) = 3</code></p><p><code>__gcd(21,0) = 21</code></p><h2 id="lg"><a href="#lg" class="headerlink" title="__lg"></a>__lg</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__lg(a)</span><br></pre></td></tr></table></figure><blockquote><ol><li>求一个数二进制下最高位位于第几位（从<strong>第0位</strong>开始）（或二进制数下有几位）</li><li><code>__lg(x)</code>相当于返回$\lfloor log_2 x \rfloor$</li><li>复杂度$O(1)$</li></ol></blockquote><p><code>__lg(8) = 3</code></p><p><code>__lg(15) = 3</code></p><h2 id="builtin-内置位运算函数"><a href="#builtin-内置位运算函数" class="headerlink" title="__builtin_ 内置位运算函数"></a><code>__builtin_</code> 内置位运算函数</h2><blockquote><p>需要注意：内置函数有相应的<code>unsigned lnt</code>和<code>unsigned long long</code>版本，<code>unsigned long long</code>只需要在函数名后面加上<code>ll</code>就可以了，比如<code>__builtin_clzll(x)</code> ，默认是32位<code>unsigned int</code></p><p>很多题目和 <code>long long</code> 数据类型有关，如有需要注意添加 <code>ll</code> </p></blockquote><ul><li><code>__builtin_ffs</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__builtin_ffs(x)</span><br></pre></td></tr></table></figure><blockquote><p>二进制中对应最后一位<code>1</code>的位数，比如<code>4</code>会返回<code>3</code>（100）</p></blockquote><ul><li><code>__builtin_popcount</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__builtin_popcount(x)</span><br></pre></td></tr></table></figure><blockquote><p><code>x</code>中<code>1</code>的个数</p></blockquote><ul><li><code>__builtin_ctz</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__builtin_ctz(x)</span><br></pre></td></tr></table></figure><blockquote><p><code>x</code>末尾<code>0</code>的个数（<code>count tail zero</code>）</p></blockquote><ul><li><code>__builtin_clz</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__builtin_clz(x)</span><br></pre></td></tr></table></figure><blockquote><p><code>x</code>前导<code>0</code>的个数（<code>count leading zero</code>）</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; __builtin_clz(<span class="number">32</span>); <span class="comment">// 26</span></span><br><span class="line"><span class="comment">//因为共有6位,默认数据范围为32位，32 - 6 = 26</span></span><br></pre></td></tr></table></figure><ul><li><code>__builtin_parity</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__builtin_parity(x)</span><br></pre></td></tr></table></figure><blockquote><p><code>x</code>中1的个数的奇偶性， 奇数输出<code>1</code>，偶数输出<code>0</code></p></blockquote><blockquote><p>可参考链接：</p><ol><li><a href="https://www.luogu.com.cn/blog/AccRobin/grammar-candies">C++语法糖</a> <a href="https://www.luogu.com.cn/blog/AccRobin/grammar-candies">https://www.luogu.com.cn/blog/AccRobin/grammar-candies</a></li></ol></blockquote><p>可能有些人需要PDF文件，公众号【行码棋】回复 【STL】 获取（三个大写英文字母即可），抱歉😭</p><blockquote><p>2023.03.28 已更新PDF文件（除去了水印，内容进行了部分排版调整和更新）</p></blockquote><p><img src="https://wyqz.top/medias/gzh.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习总结 </tag>
            
            <tag> CPP </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【裴蜀定理】CF1055C Lucky Days</title>
      <link href="/p/4188452413.html"/>
      <url>/p/4188452413.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lucky-Days"><a href="#Lucky-Days" class="headerlink" title="Lucky Days"></a><a href="https://codeforces.com/problemset/problem/1055/C">Lucky Days</a></h1><blockquote><p>给定 $l_a,r_a,t_a,l_b,r_b,t_b$，对于所有的非负整数 $k$，将区间 $[l_a+kt_a,r_a+kt_a]$ 打上标记 $1$，将区间 $[l_b+kt_b,r_b+kt_b]$ 打上标记 $2$。求出最长的连续区间使得该区间中的所有位置都被同时打上的 $1,2$ 标记。</p></blockquote><p>样例一</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 2 5</span><br><span class="line">1 3 5</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>样例二</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 3</span><br><span class="line">2 3 6</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/CF1055C/19d7a3762431cf8ed7d41c7aa787eb194dc6ab47.png" alt="样例一"></p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/CF1055C/dee255111b7c12483568555df6c88766f900f855.png" alt="样例二"></p><hr><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目要求两个区间的重合度最大的长度。</p><p>首先第一个点我们要想到：要想使两个区间的重合度最高，需要让两个区间尽可能逼近。最优的情况就是两个区间的<strong>左端点尽可能相等</strong>，这样重合度是最大的。</p><p>即使 $la + x * ta &#x3D; lb + y * tb$</p><p>将式子进行移项得 $x * ta - y * tb &#x3D; lb - la$ （此时我们假设$la &lt; lb$，代码中已做相关的操作，这样只是为了方便）</p><p>我们需要看式子是否有解，式子结构和<strong>裴蜀定理</strong>比较像，拿出来进行对比。</p><p>裴蜀定理 ： 存在整数 $x, y$，满足$a * x + b * y &#x3D; gcd(a,b)$</p><p> 该式子进行$y$符号变为正，表示$y$是整数，则 $x * ta + y * tb &#x3D; lb - la$</p><p>我们令$d &#x3D; gcd(ta, tb)$</p><p>那么可以发现如果$d | (lb - la)$，则该式子有解，左端点可以重合。</p><hr><p>但是如果左端点不能重合怎么办，尽可能逼近就行。</p><p>此时别忘了式子右边的$lb-la$代表的是什么，是 <strong>区间a左端点移动的距离</strong>，那么因为$x * ta + y * tb &#x3D; d$是存在解的，则<strong>区间a移动的距离可进一步变为</strong> $d$ 。</p><blockquote><p> 注意：我说的区间a可以移动，是指的一定存在某种状态，上下两个人有两个区间的距离发生了变化，叫为区间移动更容易理解。如</p><p>$ta &#x3D; 3,[1,4]-&gt;[4,7]-&gt;[7,10]-&gt;[10,13]$</p><p>$tb &#x3D; 4,[3,5]-&gt;[7,9]-&gt;[11,13]$</p><p>$[1,4][3,5]$左端点相差$2$，这是一种区间状态，通过移动，会出现另一种区间状态$[10,13][11,13]$左端点相差$1$。移动了一步（$d &#x3D; gcd(3,4) &#x3D; 1$）</p></blockquote><p>左端点不重合就尽可能逼近。</p><p>有两种状态可能是合适的。</p><blockquote><p>$dis$代表a区间左端点与b区间左端点相差的最小距离（a区间左端点我认为小于等于b区间左端点），即$dis &#x3D; (lb - la) % d$</p></blockquote><ul><li><p>区间a左端点移动到和区间b左端点相差$(lb-la) % d$，可能是距离最近的</p><ul><li>$min(rb - lb + 1, ra - la + 1 - dis)$</li></ul></li><li><p>然后是上面的情况在往后移一步，即区间a左端点超过区间b左端点$d-(lb-la)%d$</p><ul><li>$dis &#x3D; d - dis$ </li><li>$min(ra - la + 1, rb - lb + 1 - dis)$</li></ul></li></ul><blockquote><p>两个计算请画图领悟计算方法。</p><p>计算：左端点重合的情况可以合并在左端点能合并的代码里面，即左端点合并是左端点不合并的特殊情况。</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [l[a] + k * ta, r[a] + k * ta]</span></span><br><span class="line"><span class="comment">// 3 [1, 4] [4, 7] [7, 10] [10, 13] [13, 16] ---</span></span><br><span class="line"><span class="comment">// 4 [3, 5] [7, 9] [11, 13]         [15, 17] ---</span></span><br><span class="line"><span class="comment">// 起点尽可能相同</span></span><br><span class="line"><span class="comment">// 裴蜀定理：存在x,y 使 ax + by = gcd(a, b)</span></span><br><span class="line"><span class="comment">// la + x * ta = lb + y * tb</span></span><br><span class="line"><span class="comment">// x * ta - y * tb = lb - la</span></span><br><span class="line"><span class="comment">// gcd(ta, tb) | (lb - la)有解</span></span><br><span class="line"><span class="comment">// d = gcd(ta, tb) 看成相对移动的距离</span></span><br><span class="line"><span class="comment">// la -&gt; la + d -&gt; la + k * d    lb</span></span><br><span class="line"><span class="comment">// 差 = lb - la </span></span><br><span class="line"><span class="comment">// dis = (lb - la) % d</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> la, ra, ta, lb, rb, tb;</span><br><span class="line">cin &gt;&gt; la &gt;&gt; ra &gt;&gt; ta &gt;&gt; lb &gt;&gt; rb &gt;&gt; tb;</span><br><span class="line"><span class="keyword">if</span>(la &gt; lb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(la, lb);</span><br><span class="line"><span class="built_in">swap</span>(ra, rb);</span><br><span class="line"><span class="built_in">swap</span>(ta, tb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> d = __gcd(ta, tb);</span><br><span class="line"><span class="type">int</span> dis = (lb - la) % d; <span class="comment">// 左端点的差</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(rb - lb + <span class="number">1</span>, ra - la + <span class="number">1</span> - dis));</span><br><span class="line">dis = d - dis; <span class="comment">// 向右移动一步</span></span><br><span class="line">ans = <span class="built_in">max</span>(ans, <span class="built_in">min</span>(ra - la + <span class="number">1</span>, rb - lb + <span class="number">1</span> - dis));</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx知识总结</title>
      <link href="/p/386249329.html"/>
      <url>/p/386249329.html</url>
      
        <content type="html"><![CDATA[<h1 id="开关nginx"><a href="#开关nginx" class="headerlink" title="开关nginx"></a>开关nginx</h1><p><code>Ubuntu</code>下：</p><p>打开<code>nginx</code>服务，需要在root权限下（docker容器下也可以用）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/nginx start</span><br></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><h2 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h2><h3 id="server区"><a href="#server区" class="headerlink" title="server区"></a>server区</h3><p>进行端口监听，转发流量</p><ul><li>访问80端口，即浏览器直接输入地址，访问网页，内容位于<code>/home/hexo/blog</code>处</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    server&#123;</span><br><span class="line">        listen 80; <span class="comment"># 监听80端口</span></span><br><span class="line">        server_name 101.35.203.216; <span class="comment">#访问输的地址，可以填域名</span></span><br><span class="line">        root /home/hexo/blog; <span class="comment"># 访问文件的目录</span></span><br><span class="line">        location / &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>域名转发，即访问<code>game.wyqz.top</code>域名，转发到本地<code>10000</code>端口。</li></ul><p><code>game.wyqz.top</code>域名解析到的是服务器IP地址，等于说访问的还是80端口，我们通过域名匹配，将其转发到域名对应的端口处。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name game.wyqz.top;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_pass  http://127.0.0.1:10000; <span class="comment"># 转发规则</span></span><br><span class="line">        proxy_set_header Host <span class="variable">$proxy_host</span>; <span class="comment"># 修改转发请求头，让10000端口的应用可以受到真实的请求</span></span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        access_log  /www/wwwlogs/access.log;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重定向，即通过80端口访问<code>vj.wyqz.top</code>域名（80端口是http访问），直接return一个地址，即对应的<strong>https</strong>地址，实现<strong>https</strong>访问。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    server&#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name vj.wyqz.top;</span><br><span class="line">        <span class="built_in">return</span>  301 https://$host<span class="variable">$request_uri</span>; <span class="comment">#重定向至https访问。</span></span><br><span class="line">        location / &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>https配置</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    <span class="comment"># 服务器端口使用443，开启ssl, 这里ssl就是上面安装的ssl模块</span></span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    root /home/hexo/blog;</span><br><span class="line">    <span class="comment"># 域名，多个以空格分开</span></span><br><span class="line">    server_name  wyqz.top www.wyqz.top;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ssl证书地址</span></span><br><span class="line">    ssl_certificate     /etc/nginx/ssl.pem;  <span class="comment"># pem文件的路径</span></span><br><span class="line">    ssl_certificate_key  /etc/nginx/ssl.key; <span class="comment"># key文件的路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ssl验证相关配置</span></span><br><span class="line">    ssl_session_timeout  5m;    <span class="comment">#缓存有效期</span></span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    <span class="comment">#加密算法</span></span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    <span class="comment">#安全链接可选的加密协议</span></span><br><span class="line">    ssl_prefer_server_ciphers on;   <span class="comment">#使用服务器端的首选算法</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul><li>server_name 值为<code>_</code>时，匹配任何域名。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1076E.Vasya and a Tree|树上差分</title>
      <link href="/p/3632168690.html"/>
      <url>/p/3632168690.html</url>
      
        <content type="html"><![CDATA[<h1 id="CF-1076E-Vasya-and-a-Tree-树上差分"><a href="#CF-1076E-Vasya-and-a-Tree-树上差分" class="headerlink" title="CF 1076E. Vasya and a Tree|树上差分"></a>CF 1076E. Vasya and a Tree|树上差分</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>一棵树，它有n个节点，1号节点为根节点，初始所有点的权值为0。</p><p>定义以下两个东西：</p><ul><li><p>函数$d(i,j)$ : 指节点$i$到$j$所经过边的数量。</p></li><li><p>$x$节点的$k$级子树，指满足以下条件点的集合：</p><p>① x为该点的祖先，规定自己也是自己的祖先。</p><p>②$d(i,j) \leq k$。</p></li></ul><p>$m$条要求要你来解决：</p><p>给出$v,d,x$，将以$v$节点的$d$级子树的权值加上$x$。</p><p>当处理完所有的要求时，输出所有点的权值。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求对一段深度的某节点的子树进行加和操作，这种操作类似单纯的一维前缀和差分操作，所以可以在树上进行差分操作。</p><p>首先就是将所有的操作离线下来，将所有操作挂在节点上。对应下面的代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">q</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u, d, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; d &gt;&gt; v;</span><br><span class="line">    q[u].<span class="built_in">push_back</span>(&#123;d, v&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>接下来的关键点就是如何在树上进行差分操作（对应一维差分 区间左端点的加 和 区间右端点的减）。</p><p>因为树中的遍历是基于DFS序的，<strong>访问一个子树过后才会访问到另一棵子树</strong>。</p><p>我们在DFS过程中维护差分数组（$b[i]$），DFS时携带一个前缀和（$sum$）变量，每访问到一个节点时，先遍历该节点的所有操作，将前缀和（其实就是该路径上差分数组的前缀和，等于当前节点的值）加上操作的值，然后标记差分数组结束的位置（就是在该位置减去操作的那个值）。</p><p>当回溯的时候，删除之前打的标记。树遍历是DFS序的，删除之后才会访问到另一棵树相同的深度节点，不会影响$b[i]$的值。</p><blockquote><p>$b[i]$ : 代表深度为$i$的节点的标记值</p></blockquote><p>标记：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(dep[u] + d &lt; n - <span class="number">1</span>)</span><br><span class="line">    b[dep[u] + d + <span class="number">1</span>] -= v;<span class="comment">//mark</span></span><br></pre></td></tr></table></figure><p>删除标记：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [d, v] : q[u])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u] + d &lt; n - <span class="number">1</span>)</span><br><span class="line">        b[dep[u] + d + <span class="number">1</span>] += v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dep</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">q</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u, d, v;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; d &gt;&gt; v;</span><br><span class="line">q[u].<span class="built_in">push_back</span>(&#123;d, v&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">b</span><span class="params">(<span class="number">3e5</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, ll)&gt; dfs = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa, ll sum)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 加上标记值</span></span><br><span class="line">sum += b[dep[u]]; <span class="comment">// minus</span></span><br><span class="line">        <span class="comment">// 枚举节点操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [d, v] : q[u])</span><br><span class="line">&#123;</span><br><span class="line">sum += v;<span class="comment">//累加</span></span><br><span class="line"><span class="keyword">if</span>(dep[u] + d &lt; n - <span class="number">1</span>)</span><br><span class="line">b[dep[u] + d + <span class="number">1</span>] -= v;<span class="comment">//mark</span></span><br><span class="line">&#125;</span><br><span class="line">ans[u] = sum;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v, u, sum);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 删除标记</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [d, v] : q[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[u] + d &lt; n - <span class="number">1</span>)</span><br><span class="line">b[dep[u] + d + <span class="number">1</span>] += v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == n];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 树 </tag>
            
            <tag> CF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM模板</title>
      <link href="/p/3941430957.html"/>
      <url>/p/3941430957.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-杂项"><a href="#1-杂项" class="headerlink" title="1 杂项"></a>1 杂项</h1><h2 id="1-1-int128和快读"><a href="#1-1-int128和快读" class="headerlink" title="1.1 __int128和快读"></a>1.1 __int128和快读</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> __int128 <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">__int128 x = <span class="number">0</span>; <span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch; ch = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123; <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(__int128 x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>); x = -x; &#125;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) <span class="built_in">print</span>(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">std::istream&amp; <span class="keyword">operator</span> &gt;&gt;(std::istream&amp;in, __int128 &amp;x) &#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="keyword">while</span>(c = in.<span class="built_in">get</span>(), c != <span class="string">&#x27;-&#x27;</span> &amp;&amp; !<span class="built_in">isdigit</span>(c));</span><br><span class="line">  <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) &#123;x = <span class="string">&#x27;0&#x27;</span> - (c = in.<span class="built_in">get</span>()); <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c = <span class="built_in">getchar</span>()))x = x * <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span> - c;&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;x = c - <span class="string">&#x27;0&#x27;</span>; <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c = in.<span class="built_in">get</span>()))x = x * <span class="number">10</span> - <span class="string">&#x27;0&#x27;</span> + c;&#125;;</span><br><span class="line">  <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span> &lt;&lt;(std::ostream&amp;out, __int128 x) &#123;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;out &lt;&lt; <span class="string">&quot;-&quot;</span>; out &lt;&lt; -x; <span class="keyword">return</span> out;&#125;</span><br><span class="line">  <span class="keyword">if</span>(x == <span class="number">0</span>) &#123;out &lt;&lt; <span class="string">&quot;0&quot;</span>; <span class="keyword">return</span> out;&#125;</span><br><span class="line">  <span class="keyword">if</span>(x &gt; <span class="number">10</span>) out &lt;&lt; x / <span class="number">10</span>;</span><br><span class="line">  out &lt;&lt; <span class="string">&quot;0123456789&quot;</span>[x % <span class="number">10</span>];</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>; <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">for</span>(; c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>()) ;</span><br><span class="line"><span class="keyword">for</span>(; c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>; c = <span class="built_in">getchar</span>())</span><br><span class="line">x = x * <span class="number">10</span> + (c &amp; <span class="number">15</span>);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">9</span>) <span class="built_in">out</span>(x / <span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-STL"><a href="#1-2-STL" class="headerlink" title="1.2 STL"></a>1.2 STL</h2><h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态长度bitset实现</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> len = <span class="number">1</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">bitset_</span>(<span class="type">int</span> sz) &#123;</span><br><span class="line"><span class="keyword">if</span> (len &lt; sz) &#123;</span><br><span class="line"><span class="built_in">bitset_</span>&lt;<span class="built_in">min</span>(len * <span class="number">2</span>, N)&gt;(sz);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">bitset&lt;len + 1&gt; dp;</span><br><span class="line"><span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line">bitset&lt;5&gt;b;<span class="comment">//坐标从后往前计数，高位在前</span></span><br><span class="line">bitset&lt;5&gt;<span class="built_in">b</span>(<span class="number">13</span>);</span><br><span class="line">bitset&lt;5&gt;<span class="built_in">b</span>(<span class="string">&quot;1101&quot;</span>);</span><br><span class="line">b.<span class="built_in">count</span>();<span class="comment">//count函数用来求bitset中1的位数，一共3</span></span><br><span class="line">b.<span class="built_in">size</span>();<span class="comment">//size函数用来求bitset的大小，一共5</span></span><br><span class="line">b.<span class="built_in">any</span>();<span class="comment">//any函数检查bitset中是否有１</span></span><br><span class="line">b.<span class="built_in">none</span>();<span class="comment">//none函数检查bitset中是否没有１</span></span><br><span class="line">b.<span class="built_in">all</span>();<span class="comment">//all函数检查bitset中是全部为１</span></span><br><span class="line">foo.<span class="built_in">flip</span>();<span class="comment">//flip函数不指定参数时，将bitset每一位全部取反</span></span><br><span class="line">foo.<span class="built_in">set</span>();<span class="comment">//set函数不指定参数时，将bitset的每一位全部置为１</span></span><br><span class="line">foo.<span class="built_in">reset</span>();<span class="comment">//reset函数不传参数时将bitset的每一位全部置为０</span></span><br><span class="line">string s = foo.<span class="built_in">to_string</span>();<span class="comment">//将bitset转换成string类型</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> a = foo.<span class="built_in">to_ulong</span>();<span class="comment">//将bitset转换成unsigned long类型</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> b = foo.<span class="built_in">to_ullong</span>();<span class="comment">//将bitset转换成unsigned long long类型 </span></span><br></pre></td></tr></table></figure><h2 id="1-3-取模"><a href="#1-3-取模" class="headerlink" title="1.3 取模"></a>1.3 取模</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// assume -P &lt;= x &lt; 2P</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">norm</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x += mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mod) &#123;</span><br><span class="line">        x -= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">power</span><span class="params">(T a, ll b)</span> </span>&#123;</span><br><span class="line">    T res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Z</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">Z</span>(<span class="type">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x)) &#123;&#125;</span><br><span class="line">    <span class="built_in">Z</span>(ll x) : <span class="built_in">x</span>(<span class="built_in">norm</span>(x % mod)) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    Z <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Z</span>(<span class="built_in">norm</span>(mod - x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Z <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, mod - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">ll</span>(x) * rhs.x % mod;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Z &amp;<span class="keyword">operator</span>/=(<span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>*(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>+(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>-(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Z <span class="keyword">operator</span>/(<span class="type">const</span> Z &amp;lhs, <span class="type">const</span> Z &amp;rhs) &#123;</span><br><span class="line">        Z res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, Z &amp;a) &#123;</span><br><span class="line">        ll v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">Z</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> Z &amp;a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-4-随机数"><a href="#1-4-随机数" class="headerlink" title="1.4 随机数"></a>1.4 随机数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">mt19937 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function">ll <span class="title">rnd</span><span class="params">(ll l, ll r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">uniform_int_distribution</span>&lt;ll&gt;(l, r)(rng); &#125;</span><br><span class="line"><span class="comment">// rnd(1, n) 生成[1, n]之间的随机数</span></span><br></pre></td></tr></table></figure><h2 id="1-5-Hash"><a href="#1-5-Hash" class="headerlink" title="1.5 Hash"></a>1.5 Hash</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hash_map</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> u;</span><br><span class="line"><span class="type">int</span> v, nxt;</span><br><span class="line">&#125;;</span><br><span class="line">data e[SZ &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt, h[SZ]; <span class="comment">// SZ 为const int的大小</span></span><br><span class="line"><span class="built_in">hash_map</span>() &#123;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span> <span class="params">(<span class="type">long</span> <span class="type">long</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (u % SZ + SZ) % SZ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>[] (<span class="type">long</span> <span class="type">long</span> u) &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">hash</span>(u);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[a]; ~i; i = e[i].nxt) &#123;</span><br><span class="line"><span class="keyword">if</span> (e[i].u == u) <span class="keyword">return</span> e[i].v;</span><br><span class="line">&#125;</span><br><span class="line">e[cnt] = (data)&#123;u, <span class="number">0</span>, h[a]&#125;;</span><br><span class="line">h[a] = cnt++;</span><br><span class="line"><span class="keyword">return</span> e[cnt - <span class="number">1</span>].v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h1><h2 id="2-1-线段树"><a href="#2-1-线段树" class="headerlink" title="2.1 线段树"></a>2.1 线段树</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">ll sum, add;</span><br><span class="line">&#125; tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span>].add += tr[u].add;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].add += tr[u].add;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span>].sum += <span class="number">1ll</span> * (mid - l + <span class="number">1</span>) * tr[u].add;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += <span class="number">1ll</span> * (r - mid) * tr[u].add;</span><br><span class="line">tr[u].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">tr[u].sum = b[l];</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line"><span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="comment">// if(l &gt; y || r &lt; x) return;</span></span><br><span class="line"><span class="keyword">if</span>(l &gt;= x <span class="keyword">and</span> r &lt;= y) &#123;</span><br><span class="line">tr[u].sum += <span class="number">1ll</span> * (r - l + <span class="number">1</span>) * d;</span><br><span class="line">tr[u].add += d;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(u, l, r);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, mid, x, y, d);</span><br><span class="line"><span class="keyword">if</span>(y &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, d);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if(l &gt; y || r &lt; x) return 0;</span></span><br><span class="line"><span class="keyword">if</span>(l &gt;= x <span class="keyword">and</span> r &lt;= y)</span><br><span class="line"><span class="keyword">return</span> tr[u].sum;</span><br><span class="line"><span class="built_in">pushdown</span>(u, l, r);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= mid) res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, mid, x, y);</span><br><span class="line"><span class="keyword">if</span>(y &gt; mid) res += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span> , r, x, y);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-RMQ-ST表"><a href="#2-2-RMQ-ST表" class="headerlink" title="2.2 RMQ&#x2F;ST表"></a>2.2 RMQ&#x2F;ST表</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> f[N][<span class="number">30</span>], lg[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">lg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">lg[i] = lg[i - <span class="number">1</span>] + (i &amp; (i - <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">f[i][<span class="number">0</span>] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lg[n]; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-并查集"><a href="#2-3-并查集" class="headerlink" title="2.3 并查集"></a>2.3 并查集</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; f, sz;</span><br><span class="line"><span class="built_in">DSU</span>(<span class="type">int</span> n): <span class="built_in">f</span>(n), <span class="built_in">sz</span>(n, <span class="number">1</span>) &#123; <span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(sz[x] &lt; sz[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">f[y] = x;</span><br><span class="line">sz[x] += sz[y];</span><br><span class="line">sz[y] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4-树状数组"><a href="#2-4-树状数组" class="headerlink" title="2.4 树状数组"></a>2.4 树状数组</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">vector&lt;T&gt; tr;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n;</span><br><span class="line"><span class="built_in">Fenwick</span>(<span class="type">int</span> n): <span class="built_in">n</span>(n), <span class="built_in">tr</span>(n) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x, T d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(; x &lt; n; x += x &amp; (-x))</span><br><span class="line">tr[x] += d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">T res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; x; x -= x &amp; (-x))</span><br><span class="line">res += tr[x];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">RangeSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-5-分块"><a href="#2-5-分块" class="headerlink" title="2.5 分块"></a>2.5 分块</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Part</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;ll&gt; a, s, add;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; L, R, id;</span><br><span class="line">    <span class="type">int</span> n, t;</span><br><span class="line">    <span class="built_in">Part</span>(<span class="type">int</span> n):<span class="built_in">n</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        L.<span class="built_in">resize</span>(n);</span><br><span class="line">        R.<span class="built_in">resize</span>(n);</span><br><span class="line">        id.<span class="built_in">resize</span>(n);</span><br><span class="line">        a.<span class="built_in">resize</span>(n);</span><br><span class="line">        s.<span class="built_in">resize</span>(n);</span><br><span class="line">        add.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            L[i] = (i - <span class="number">1</span>) * t + <span class="number">1</span>;</span><br><span class="line">            R[i] = i * t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(R[t] &lt; n) t++, L[t] = R[t - <span class="number">1</span>] + <span class="number">1</span>, R[t] = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)</span><br><span class="line">                id[j] = i, s[i] += a[j];    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = id[l], q = id[r];</span><br><span class="line">        <span class="keyword">if</span>(p == q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i ++)</span><br><span class="line">                a[i] += d;</span><br><span class="line">            s[p] += d * (r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = p + <span class="number">1</span>; i &lt;= q - <span class="number">1</span>; i++)</span><br><span class="line">                add[i] += d;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= R[p]; i++)</span><br><span class="line">                a[i] += d;</span><br><span class="line">            s[p] += d * (R[p] - l + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = L[q]; i &lt;= r; i++)</span><br><span class="line">                a[i] += d;</span><br><span class="line">            s[q] += d * (r - L[q] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = id[l], q = id[r];</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(q == p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">                ans += a[i];</span><br><span class="line">            ans += add[p] * (r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = p + <span class="number">1</span>; i &lt;= q - <span class="number">1</span>; i++)</span><br><span class="line">                ans += s[i] + add[i] * (R[i] - L[i] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= R[p]; i++)</span><br><span class="line">                ans += a[i];</span><br><span class="line">            ans += add[p] * (R[p] - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = L[q]; i &lt;= r; i++)</span><br><span class="line">                ans += a[i];</span><br><span class="line">            ans += add[q] * (r - L[q] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-6-主席树"><a href="#2-6-主席树" class="headerlink" title="2.6 主席树"></a>2.6 主席树</h2><p>求第k小数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> lc[N &lt;&lt; <span class="number">5</span>], rc[N &lt;&lt; <span class="number">5</span>], rt[N], tot;</span><br><span class="line">ll sum[N &lt;&lt; <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> root = ++tot;</span><br><span class="line"><span class="keyword">if</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">lc[root] = <span class="built_in">build</span>(l, mid);</span><br><span class="line">rc[root] = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> last, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> root = ++tot;</span><br><span class="line">lc[root] = lc[last], rc[root] = rc[last], sum[root] = sum[last] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= mid) lc[root] = <span class="built_in">modify</span>(lc[root], l, mid, x);</span><br><span class="line"><span class="keyword">else</span> rc[root] = <span class="built_in">modify</span>(rc[root], mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回的是第k小数的对应的数的等级（在所有数中的等级）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> x = sum[lc[v]] - sum[lc[u]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k &lt;= x) <span class="keyword">return</span> <span class="built_in">query</span>(lc[u], lc[v], l, mid, k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rc[u], rc[v], mid + <span class="number">1</span>, r, k - x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">b[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line">rt[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, len);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + len, a[i]) - b;</span><br><span class="line">rt[i] = <span class="built_in">modify</span>(rt[i - <span class="number">1</span>], <span class="number">1</span>, len, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l, r, k;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">cout &lt;&lt; b[<span class="built_in">query</span>(rt[l - <span class="number">1</span>], rt[r], <span class="number">1</span>, len, k)] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-数学"><a href="#3-数学" class="headerlink" title="3 数学"></a>3 数学</h1><h2 id="3-1-高精度"><a href="#3-1-高精度" class="headerlink" title="3.1 高精度"></a>3.1 高精度</h2><p>数组存储均为倒序存储</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高精度加法</span></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高精度减法</span></span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高精乘低精</span></span><br><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前导零</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高精度乘高精度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span> ;</span><br><span class="line"><span class="type">int</span> na = a.<span class="built_in">size</span>(), nb = b.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(na + nb)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; na; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; nb; j++) &#123;</span><br><span class="line">c[i + j] += a[i] * b[j];</span><br><span class="line">c[i + j + <span class="number">1</span>] += c[i + j] / <span class="number">10</span>;</span><br><span class="line">c[i + j] %= <span class="number">10</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c.<span class="built_in">size</span>() &gt; <span class="number">1</span> <span class="keyword">and</span> c.<span class="built_in">back</span>() == <span class="number">0</span>) c.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-质数"><a href="#3-2-质数" class="headerlink" title="3.2 质数"></a>3.2 质数</h2><p>约数个数估计：<br>$$<br>r(n) &#x3D; n ^ {\Large \frac{1.066}{\Large\ln \Large \ln n}}<br>$$</p><h3 id="3-2-1-质因数分解"><a href="#3-2-1-质因数分解" class="headerlink" title="3.2.1 质因数分解"></a>3.2.1 质因数分解</h3><p>试除法 $O(\sqrt N)$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p[] : 存储质因子 c[] : 存储质因子对应的次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            p[++m] = <span class="number">0</span>, c[m] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>) n /= i, c[m]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>) p[++m] = n, c[m] = <span class="number">1</span>; <span class="comment">// n是质数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-欧拉筛"><a href="#3-2-2-欧拉筛" class="headerlink" title="3.2.2 欧拉筛"></a>3.2.2 欧拉筛</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// true：筛掉的合数 false ：为质数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] * i &lt;= n; j++) &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-扩展欧几里得"><a href="#3-3-扩展欧几里得" class="headerlink" title="3.3  扩展欧几里得"></a>3.3  扩展欧几里得</h2><p>费马小定理 ： $gcd(a,p) \equiv 1$，则 $a^{p-1} \equiv 1(mod \ p), a ^ p \equiv a(mod \ p)$</p><p>$ax+by&#x3D;c$  有解条件：$d|c$</p><p>$ax+by&#x3D;d$ 求出特解$x_0,y_0$ 后，两边同时乘 $\frac{c}{d}$ 即可推出 $ax+by &#x3D; c$ 的特解</p><p>特解：$\frac{c}{d}x_0, \frac{c}{d}y_0$ ， （$x_0, y_0$ 为 $ax + by &#x3D; d$ 的特解）</p><p>通解：$\begin{cases} x &#x3D; \frac{c}{d}x_0 + k \frac{b}{d} \ y &#x3D;\frac{c}{d} y_0 - k\frac{a}{d} \end{cases}$（周期还是为$\frac{b}{d},\frac{a}{d}$）</p><p>通解是所有模$b&#x2F;gcd(a,b)$与x同余的值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回的是gcd(a,b) 求出一组特解(x0, y0)</span></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>) &#123;x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">ll g = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">ll temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp - (a / b) * y;</span><br><span class="line"><span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逆元</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> inv[N]; <span class="comment">// 逆元数组</span></span><br><span class="line"><span class="comment">// 线性求逆元</span></span><br><span class="line">inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">inv[i] = inv[mod % i] * (mod - mod / i) % mod;</span><br><span class="line"><span class="comment">// 阶乘逆元</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">inv[i] = inv[i - <span class="number">1</span>] * inv[i] % mod;</span><br></pre></td></tr></table></figure><p>同余相关性质：<br>$$<br>除法性质：ac \equiv bc \pmod d \Leftrightarrow a \equiv b \pmod {\frac{d}{gcd(c, d)}} \<br>同余相加(乘)： a \equiv b \pmod m, c \equiv d \pmod m \Rightarrow a \pm(\times) c \equiv b \pm(\times) d \pmod m \<br>ac \equiv bc \pmod m, gcd(c, m)&#x3D;1 \Rightarrow a \equiv b \pmod m<br>$$<br>完全剩余系：给定一个正整数 $n$ ，有 $n$ 个不同的模 $n$ 的剩余类，从这 $n$ 个不同的剩余类中各取出一个元素，总共 $n$ 个数，将这些数构成一个新的集合，则称这个集合为模 $n$ 的完全剩余系。</p><p>定理：对于一个模 $n$ 的完全剩余系 $r$ ，若有 $a\in Z,\ b\in Z$ ，且 $gcd(n, a) &#x3D; 1$ ，则 $a \times r_i + b, i \in [0, n -1]$ 也构成一个模 $n$ 的完全剩余系。</p><p>或者 若 $gcd(a, n) &#x3D; 1$ ， 那么在 $x$ 在模 $n$ 的完全剩余系 $[0, n - 1]$ 内 $ax \equiv b \pmod n$ 有唯一解 $x$ ，或者说恰好有 $d &#x3D; gcd(a, n)$ 个解。例若 $d&#x3D;1,x 在 [0, n -1]$ 中有唯一解。</p><h2 id="3-4-欧拉函数"><a href="#3-4-欧拉函数" class="headerlink" title="3.4 欧拉函数"></a>3.4 欧拉函数</h2><p>欧拉定理： $gcd(a, n) &#x3D;1, 则 a^{\varphi (n)} \equiv 1(mod \ n)$</p><p>扩展欧拉定理：</p><p>$ a^b \equiv \begin{cases} a^{b \ \bmod\  \varphi(m)}, &amp;\gcd(a,m) &#x3D; 1, \ a^b, &amp;\gcd(a,m)\ne 1, b &lt; \varphi(m), \ a^{(b \  \bmod \  \varphi(m)) + \varphi(m)}, &amp;\gcd(a,m)\ne 1, b \ge \varphi(m). \end{cases} \pmod m $</p><p>单个欧拉函数的值 $O(\sqrt N)$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_phi</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个欧拉函数的值 $O(N)$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], phi[N], cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] * i &lt;= n; j ++ ) &#123;</span><br><span class="line">            st[i * primes[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                phi[i * primes[j]] = phi[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            phi[i * primes[j]] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-矩阵乘法"><a href="#3-5-矩阵乘法" class="headerlink" title="3.5 矩阵乘法"></a>3.5 矩阵乘法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a是第一个乘数，b是第二个乘数，t是结果最后存储的数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a[][N],<span class="type">int</span> b[][N],<span class="type">int</span> t[][N])</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c[N][N];</span><br><span class="line"><span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span> c);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;N;k++)</span><br><span class="line">c[i][j]=(c[i][j] + <span class="number">1ll</span> * a[i][k]*b[k][j]+m)%m;</span><br><span class="line"><span class="built_in">memcpy</span>(t,c,<span class="keyword">sizeof</span> c);<span class="comment">//复制数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-组合数"><a href="#3-6-组合数" class="headerlink" title="3.6 组合数"></a>3.6 组合数</h2><p>含重复元素排列方案数：共有 $n$ 个元素， $c_1$ 个 $a_1$ ，$c_2$ 个 $a_2$ ，…，$c_k$ 个 $a_k$ ，这 $n$ 个元素的排列数为 $\frac{n!}{c_1! c_2! \cdots c_k!}$</p><h2 id="3-7-高斯消元"><a href="#3-7-高斯消元" class="headerlink" title="3.7 高斯消元"></a>3.7 高斯消元</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> b[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//化为上三角矩阵</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">1</span>,c=<span class="number">1</span>;c&lt;=n;r++,c++)<span class="comment">//主循环每次查一个对角元素。按列查，主要要看对角元素，r=c</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找主元，找该列绝对值最大的一个数，将那行和本行交换</span></span><br><span class="line"><span class="type">int</span> t = r;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=r+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(b[i][c]) &gt; <span class="built_in">fabs</span>(b[t][c]))</span><br><span class="line">t = i;</span><br><span class="line"><span class="comment">//交换，行的交换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=c;i&lt;=n+<span class="number">1</span>;i++)<span class="built_in">swap</span>(b[r][i],b[t][i]);</span><br><span class="line"><span class="comment">//主元归一，将对角元素化为1，即该行所有值除以该行对应的对角元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&gt;=c;--i)b[r][i] /= b[r][c];</span><br><span class="line"><span class="comment">//消元，即对角元素下面的值都要变为0，那么需要下面的每一行的所有值减去对角元素那一行元素的一个倍数（b[i][c]）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=r+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=n+<span class="number">1</span>;j&gt;=c;j--)</span><br><span class="line">b[i][j] -= b[r][j] * b[i][c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//化为对角阵（只有对角线有元素且为1）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)<span class="comment">//按列消，对角元素行=列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)<span class="comment">//消去第i行上面所有的元素</span></span><br><span class="line">&#123;</span><br><span class="line">b[j][n+<span class="number">1</span>] -= b[i][n+<span class="number">1</span>]*b[j][i];<span class="comment">//只对右边的值做变化</span></span><br><span class="line">b[j][i] = <span class="number">0</span>;<span class="comment">//最后一定消完为0</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>卡特兰数列<br>$$<br>Cat_n &#x3D; \frac{C_{2n}^{n}}{n + 1}<br>$$</p><p> 错排数<br>$$<br>d[i] &#x3D; (i - 1) \times (d[i - 1] + d[i - 2])<br>$$</p><h2 id="3-8-中国剩余定理"><a href="#3-8-中国剩余定理" class="headerlink" title="3.8 中国剩余定理"></a>3.8 中国剩余定理</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x = a[i] (mod mi[i])</span></span><br><span class="line"><span class="comment">// Mi[i] = mu / mi[i]</span></span><br><span class="line">ll Mi[N], mi[N], mu = <span class="number">1</span>, a[N];</span><br><span class="line"><span class="function">ll <span class="title">crt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">mu *= mi[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">Mi[i] = mu / mi[i];</span><br><span class="line">ll x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exgcd</span>(Mi[i], mi[i], x, y);</span><br><span class="line">ans += a[i] * Mi[i] * (x &lt; <span class="number">0</span> ? x + mi[i] : x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans % mu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>扩展CRT</strong><br>$$<br>x\equiv c_{1}\left( mod\ m_{1}\right) \ x\equiv c_{2}\left( mod\ m_{2}\right)<br>$$</p><p>得到</p><p>$$<br>c&#x3D;(inv(\frac{ m_1 }{ (m_1,m_2) },\frac{m_2}{(m_1,m_2)}) \mathop{ \times } \frac{ (c_2-c_1) }{ (m_1,m_2) })\mathop{ % }\frac{ m_2 }{ (m_1,m_2) } \times m_1 + c_1<br>$$</p><p>$$<br>m&#x3D;{m_1m_2\over (m_1,m_2)}<br>$$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a,ll b,ll mod)</span> </span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=(res+a)%mod;</span><br><span class="line">        a=(a+a)%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    ll r = <span class="built_in">exgcd</span>(b, a % b, x, y), tmp;</span><br><span class="line">    tmp = x; x = y; y = tmp - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x = bi[i](mod ai[i])</span></span><br><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x, y, k;</span><br><span class="line">    ll M = bi[<span class="number">1</span>],ans = ai[<span class="number">1</span>];<span class="comment">//第一个方程的解特判</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        ll a = M,b = bi[i], c = (ai[i] - ans % b + b) % b;<span class="comment">//ax≡c(mod b)</span></span><br><span class="line">        ll gcd=<span class="built_in">exgcd</span>(a,b,x,y),bg=b/gcd;</span><br><span class="line">        <span class="keyword">if</span>(c%gcd!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//判断是否无解</span></span><br><span class="line">   </span><br><span class="line">        x=<span class="built_in">mul</span>(x,c/gcd,bg);</span><br><span class="line">        ans+=x*M;<span class="comment">//更新前k个方程组的答案</span></span><br><span class="line">        M*=bg;<span class="comment">//M为前k个m的lcm</span></span><br><span class="line">        ans=(ans%M+M)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans%M+M)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-多项式"><a href="#3-9-多项式" class="headerlink" title="3.9 多项式"></a>3.9 多项式</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = (<span class="number">1</span> &lt;&lt; <span class="number">21</span>) + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">comp</span> &#123;</span><br><span class="line"><span class="type">double</span> x, y;</span><br><span class="line"><span class="built_in">comp</span>(<span class="type">double</span> xx = <span class="number">0</span>, <span class="type">double</span> yy = <span class="number">0</span>) &#123; x = xx, y = yy; &#125;</span><br><span class="line">comp <span class="keyword">operator</span> +(<span class="type">const</span> comp&amp; b) &#123; <span class="keyword">return</span> <span class="built_in">comp</span>(x + b.x , y + b.y);&#125;</span><br><span class="line">comp <span class="keyword">operator</span> -(<span class="type">const</span> comp&amp; b) &#123; <span class="keyword">return</span> <span class="built_in">comp</span>(x - b.x , y - b.y);&#125;</span><br><span class="line">comp <span class="keyword">operator</span> *(<span class="type">const</span> comp&amp; b) &#123; <span class="keyword">return</span> <span class="built_in">comp</span>(x * b.x - y * b.y , x * b.y + y * b.x);&#125;</span><br><span class="line">comp&amp; <span class="keyword">operator</span> *=(<span class="type">const</span> comp&amp; b) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> * b; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">comp&amp; <span class="keyword">operator</span> +=(<span class="type">const</span> comp&amp; b) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> + b; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">&#125; a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, m, lim, r[N]; <span class="comment">//F(x)的系数个数n+1,G(x)的系数m+1,从低位到高位</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fft</span><span class="params">(comp *a, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++)</span><br><span class="line"><span class="keyword">if</span>(i &lt; r[i]) <span class="built_in">swap</span>(a[i], a[r[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; lim; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="function">comp <span class="title">x</span><span class="params">(cos(PI / i), type * sin(PI / i))</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; lim; j += (i &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="function">comp <span class="title">y</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k ++, y *= x) &#123;</span><br><span class="line">comp p = a[j + k], q = y * a[j + k + i];</span><br><span class="line">a[j + k] = p + q; a[j + k + i] = p - q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) a[i].x = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i ++) b[i].x = <span class="built_in">read</span>();</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(lim = <span class="number">1</span>; lim &lt;= n + m; lim &lt;&lt;= <span class="number">1</span>) ++ l;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lim; i ++)</span><br><span class="line">r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (l - <span class="number">1</span>));</span><br><span class="line"><span class="built_in">fft</span>(a, <span class="number">1</span>), <span class="built_in">fft</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lim; i ++) a[i] *= b[i];</span><br><span class="line"><span class="built_in">fft</span>(a, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + m; i ++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, (<span class="type">int</span>)(<span class="number">0.5</span> + a[i].x / lim));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3</span> * <span class="number">1e6</span> + <span class="number">10</span>, P = <span class="number">998244353</span>, G = <span class="number">3</span>, Gi = <span class="number">332748118</span>; </span><br><span class="line"><span class="type">int</span> n, m, limit = <span class="number">1</span>, L, r[N];</span><br><span class="line">LL a[N], b[N];</span><br><span class="line"><span class="function">LL <span class="title">fastpow</span><span class="params">(LL a, LL k)</span> </span>&#123;</span><br><span class="line">LL base = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k) &#123;</span><br><span class="line"><span class="keyword">if</span>(k &amp; <span class="number">1</span>) base = (base * a ) % P;</span><br><span class="line">a = (a * a) % P;</span><br><span class="line">k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> base % P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ntt</span><span class="params">(LL *A, <span class="type">int</span> type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) </span><br><span class="line"><span class="keyword">if</span>(i &lt; r[i]) <span class="built_in">swap</span>(A[i], A[r[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mid = <span class="number">1</span>; mid &lt; limit; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">LL Wn = <span class="built_in">fastpow</span>( type == <span class="number">1</span> ? G : Gi , (P - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; limit; j += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">LL w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; mid; k++, w = (w * Wn) % P) &#123;</span><br><span class="line"> <span class="type">int</span> x = A[j + k], y = w * A[j + k + mid] % P;</span><br><span class="line"> A[j + k] = (x + y) % P,</span><br><span class="line"> A[j + k + mid] = (x - y + P) % P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) a[i] = (<span class="built_in">read</span>() + P) % P;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) b[i] = (<span class="built_in">read</span>() + P) % P;</span><br><span class="line"><span class="keyword">while</span>(limit &lt;= n + m) limit &lt;&lt;= <span class="number">1</span>, L++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) r[i] = (r[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (L - <span class="number">1</span>));</span><br><span class="line"><span class="built_in">ntt</span>(a, <span class="number">1</span>); <span class="built_in">ntt</span>(b, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; limit; i++) a[i] = (a[i] * b[i]) % P;</span><br><span class="line"><span class="built_in">ntt</span>(a, <span class="number">-1</span>);</span><br><span class="line">LL inv = <span class="built_in">fastpow</span>(limit, P - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + m; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, (a[i] * inv) % P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-图论"><a href="#4-图论" class="headerlink" title="4.图论"></a>4.图论</h1><p>链式前向星：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N], ne[N], e[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[++idx] = b, ne[idx] = h[a], h[a] = idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-1-最短路"><a href="#4-1-最短路" class="headerlink" title="4.1 最短路"></a>4.1 最短路</h2><h3 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> d[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)<span class="comment">//k在最外层，</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(d[i][k] != <span class="number">0x3f3f3f3f</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(d[i][j] &gt; d[i][k] + d[k][j])</span><br><span class="line">                    d[i][j] = d[i][k] + d[k][j];</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;-dis[s], s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"> <span class="type">int</span> u = t.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w]: g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;-dis[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h3><p>对边不断松弛优化，如果该点被松弛就加入队列，同时标记数组记为true，标记数组代表该点是否在队列中。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">q.<span class="built_in">push</span>(s);</span><br><span class="line">inq[s] = <span class="literal">true</span>, dis[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">inq[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [v, w]: g[u]) &#123;</span><br><span class="line"><span class="keyword">if</span>(dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">dis[v] = dis[u] + w;</span><br><span class="line">                cnt[v] = cnt[u] + <span class="number">1</span>;<span class="comment">// 判负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[v] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//大于等于节点个数</span></span><br><span class="line"><span class="keyword">if</span>(!inq[v]) &#123;</span><br><span class="line">inq[v] = <span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-树上问题"><a href="#4-2-树上问题" class="headerlink" title="4.2 树上问题"></a>4.2 树上问题</h2><h3 id="树上启发式合并"><a href="#树上启发式合并" class="headerlink" title="树上启发式合并"></a>树上启发式合并</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 颜色平衡树：一个树中的每种颜色的结点个数相等，求多少个子树是颜色平衡树</span></span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">color</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="type">int</span> fa;</span><br><span class="line">cin &gt;&gt; color[i] &gt;&gt; fa;</span><br><span class="line"><span class="keyword">if</span> (fa != <span class="number">0</span>) &#123;</span><br><span class="line">g[fa].<span class="built_in">push_back</span>(i);</span><br><span class="line">g[i].<span class="built_in">push_back</span>(fa);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// sum[i]:颜色出现次数为i的个数, cnt[i]:颜色i对应的个数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">L</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">R</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">big</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">sz</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">node</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>; </span><br><span class="line"><span class="type">int</span> dfn = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>, mx = <span class="number">0</span>, mn = <span class="number">1e9</span>; <span class="comment">// 颜色出现次数的最大值和最小值</span></span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs1 = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa) &#123;</span><br><span class="line">sz[u] = <span class="number">1</span>;</span><br><span class="line">L[u] = ++dfn;</span><br><span class="line">node[dfn] = u;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line"><span class="built_in">dfs1</span>(v, u);</span><br><span class="line">sz[u] += sz[v];</span><br><span class="line"><span class="keyword">if</span> (!big[u] || sz[big[u]] &lt; sz[v]) &#123;</span><br><span class="line">big[u] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">R[u] = dfn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> u) &#123;</span><br><span class="line">sum[cnt[color[u]]]--;</span><br><span class="line"><span class="keyword">if</span>(sum[cnt[color[u]]] == <span class="number">0</span> &amp;&amp; mn == cnt[color[u]]) &#123;</span><br><span class="line">mn = cnt[color[u]] + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mn = <span class="built_in">min</span>(mn, cnt[color[u]] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cnt[color[u]]++;</span><br><span class="line">sum[cnt[color[u]]]++;</span><br><span class="line">mx = <span class="built_in">max</span>(mx, cnt[color[u]]);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> del = [&amp;](<span class="type">int</span> u) &#123;</span><br><span class="line">mx = <span class="number">0</span>, mn = <span class="number">1e9</span>;</span><br><span class="line">sum[cnt[color[u]]] = <span class="number">0</span>;</span><br><span class="line">cnt[color[u]] = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>)&gt; dfs2 = [&amp;](<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">bool</span> keep) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (v != fa &amp;&amp; v != big[u]) &#123;</span><br><span class="line"><span class="built_in">dfs2</span>(v, u, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (big[u]) &#123;</span><br><span class="line"><span class="built_in">dfs2</span>(big[u], u, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (v != fa &amp;&amp; v != big[u]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = L[v]; i &lt;= R[v]; i++) &#123;</span><br><span class="line"><span class="built_in">add</span>(node[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">add</span>(u);</span><br><span class="line"><span class="keyword">if</span> (mx == mn) ans++;</span><br><span class="line"><span class="keyword">if</span> (keep == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = L[u]; i &lt;= R[u]; i++) &#123;</span><br><span class="line"><span class="built_in">del</span>(node[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="literal">false</span>);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">2</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, r, p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span> &#123;</span><br><span class="line">ll add, sum;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dep[N], fa[N], son[N], sz[N];</span><br><span class="line"><span class="type">int</span> cnt, nw[N], top[N], id[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[M], h[N], ne[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">tr[u].sum = (tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[u].add) &#123;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span>].add += tr[u].add;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span>].sum += <span class="number">1ll</span> * (mid - l + <span class="number">1</span>) * tr[u].add;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span>].sum %= p;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].add += tr[u].add;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += <span class="number">1ll</span> * (r - mid) * tr[u].add;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum %= p;</span><br><span class="line">tr[u].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">tr[u].sum = nw[l];</span><br><span class="line"><span class="keyword">if</span>(tr[u].sum &gt; p) tr[u].sum %= p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line"><span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">tr[u].sum += <span class="number">1ll</span> * (r - l + <span class="number">1</span>) * d;</span><br><span class="line">tr[u].sum %= p;</span><br><span class="line">tr[u].add += d;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(u, l, r);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, mid, x, y, d);</span><br><span class="line"><span class="keyword">if</span>(y &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, d);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= x &amp;&amp; r &lt;= y)</span><br><span class="line"><span class="keyword">return</span> tr[u].sum % p;</span><br><span class="line"><span class="built_in">pushdown</span>(u, l, r);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= mid) ans = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, mid, x, y) % p;</span><br><span class="line"><span class="keyword">if</span>(y &gt; mid) ans = (ans + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y)) % p;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理dep[],fa[],sz[],son[](重儿子节点)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f, <span class="type">int</span> depth)</span> </span>&#123; <span class="comment">//x : 当前节点, f：父亲, depth：深度 </span></span><br><span class="line">dep[x] = depth;</span><br><span class="line">fa[x] = f;</span><br><span class="line">sz[x] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> mxson = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> y = e[i];</span><br><span class="line"><span class="keyword">if</span>(y == f) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(y, x, depth + <span class="number">1</span>);</span><br><span class="line">sz[x] += sz[y];</span><br><span class="line"><span class="keyword">if</span>(sz[y] &gt; mxson) &#123; <span class="comment">// 记录重儿子编号</span></span><br><span class="line">son[x] = y;</span><br><span class="line">mxson = sz[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标新序号 求id[], nw[], top[] 新id-新节点权重-链顶端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> topf)</span> </span>&#123;</span><br><span class="line">id[x] = ++cnt;</span><br><span class="line">nw[cnt] = w[x];</span><br><span class="line">top[x] = topf;</span><br><span class="line"><span class="keyword">if</span>(!son[x]) <span class="keyword">return</span>;<span class="comment">//无儿子返回</span></span><br><span class="line"><span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[x]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> y = e[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa[x] || y == son[x])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(y, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">queryRange</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[x] != top[y]) &#123; <span class="comment">//不在同一条链上</span></span><br><span class="line"><span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line">ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x]);</span><br><span class="line">ans %= p;</span><br><span class="line">x = fa[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[x] &gt; dep[y])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line">ans = (ans + <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y])) % p;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyRange</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">d %= p;</span><br><span class="line"><span class="keyword">while</span>(top[x] != top[y]) &#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x], d);</span><br><span class="line">x = fa[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[x] &gt; dep[y])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y], d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">querySon</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x] + sz[x] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifySon</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x] + sz[x] - <span class="number">1</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LCA最近公共祖先"><a href="#LCA最近公共祖先" class="headerlink" title="LCA最近公共祖先"></a>LCA最近公共祖先</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树上倍增法</span></span><br><span class="line"><span class="comment">// f[i][j]：i节点向根走2^j到达的节点</span></span><br><span class="line"><span class="comment">// 初始化 f[i][0] : 父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(d[x] &gt; d[y]) <span class="built_in">swap</span>(x, y);<span class="comment">//保证x深度小于等于y</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = k; i &gt;= <span class="number">0</span>; i--)<span class="comment">//y走到和x同一深度</span></span><br><span class="line"><span class="keyword">if</span>(d[f[y][i]] &gt;= d[x])</span><br><span class="line">y = f[y][i];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = k; i &gt;= <span class="number">0</span>; i--)<span class="comment">//x,y一起向上走</span></span><br><span class="line"><span class="keyword">if</span>(f[x][i] != f[y][i])</span><br><span class="line">x = f[x][i], y = f[y][i];</span><br><span class="line"><span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 树链剖分法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; sz, top, dep, parent, in;</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; e;</span><br><span class="line">    <span class="built_in">Tree</span>(<span class="type">int</span> n) : <span class="built_in">sz</span>(n), <span class="built_in">top</span>(n), <span class="built_in">dep</span>(n), <span class="built_in">parent</span>(n, <span class="number">-1</span>), <span class="built_in">e</span>(n), <span class="built_in">in</span>(n), <span class="built_in">cur</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfsSz</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfsHLD</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfsSz</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[u] != <span class="number">-1</span>)</span><br><span class="line">            e[u].<span class="built_in">erase</span>(std::<span class="built_in">find</span>(e[u].<span class="built_in">begin</span>(), e[u].<span class="built_in">end</span>(), parent[u]));</span><br><span class="line">        sz[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;v : e[u]) &#123;</span><br><span class="line">            parent[v] = u;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfsSz</span>(v);</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">            <span class="keyword">if</span> (sz[v] &gt; sz[e[u][<span class="number">0</span>]])</span><br><span class="line">                std::<span class="built_in">swap</span>(v, e[u][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfsHLD</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        in[u] = cur++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == e[u][<span class="number">0</span>]) &#123;</span><br><span class="line">                top[v] = top[u];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                top[v] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfsHLD</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">                u = parent[top[u]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = parent[top[v]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dep[u] &lt; dep[v]) &#123;</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-3-差分约束"><a href="#4-3-差分约束" class="headerlink" title="4.3 差分约束"></a>4.3 差分约束</h2><p>$x_u + w \ge x_v$ 转化为最短路中的 $dis[u] + w \ge dis[v]$ </p><ul><li>用SPFA时需要建立一个总源点代表一个值，使所有点可达，可通过这个点连边限制每个变量的最大值和最小值</li><li>求最大值用最短路，求最小值用最长路</li><li>$x_a + c &#x3D; x_b$ 加边 $(a, b, c), (b, a, -c)$</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">3</span> * N;</span><br><span class="line"><span class="type">int</span> e[M], h[N], ne[M], w[M], idx, cnt[N];</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="built_in">memset</span>(dis, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line"></span><br><span class="line">dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">st[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">st[t] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> v = e[i];</span><br><span class="line"><span class="keyword">if</span>(dis[t] + w[i] &gt; dis[v]) &#123;</span><br><span class="line">dis[v] = dis[t] + w[i];</span><br><span class="line">cnt[v] = cnt[t] + <span class="number">1</span>; <span class="comment">// 判负环</span></span><br><span class="line"><span class="keyword">if</span>(cnt[v] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!st[v]) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">st[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-最小生成树"><a href="#4-4-最小生成树" class="headerlink" title="4.4 最小生成树"></a>4.4 最小生成树</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; f, sz;</span><br><span class="line"><span class="built_in">DSU</span>(<span class="type">int</span> n): <span class="built_in">f</span>(n), <span class="built_in">sz</span>(n, <span class="number">1</span>) &#123; <span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(sz[x] &lt; sz[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">f[y] = x;</span><br><span class="line">sz[x] += sz[y];</span><br><span class="line">sz[y] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;  <span class="comment">// dis, node</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; cnt &lt;= m) &#123;</span><br><span class="line"><span class="keyword">auto</span> tmp = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u = tmp.second;</span><br><span class="line"><span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cnt++;</span><br><span class="line">ans += tmp.first; <span class="comment">// 处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : g[u]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;<span class="built_in">dis</span>(u, v), v&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-tarjan"><a href="#4-5-tarjan" class="headerlink" title="4.5 tarjan"></a>4.5 tarjan</h2><h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><p>点双，求割点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无向图求割点 点双</span></span><br><span class="line"><span class="type">int</span> low[N], dfn[N], stk[N], top, ts, dcc_cnt, root = <span class="number">1</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dcc[N]; <span class="comment">// 点双连通分量数组</span></span><br><span class="line"><span class="type">bool</span> cut[N]; <span class="comment">// 是否为割点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++ts;</span><br><span class="line">stk[++top] = u;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line"><span class="keyword">if</span>(dfn[u] &lt;= low[v]) &#123;</span><br><span class="line">flag++;</span><br><span class="line">dcc_cnt++;</span><br><span class="line"><span class="keyword">if</span>(u != root || flag &gt; <span class="number">1</span>) cut[u] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">x = stk[top--];</span><br><span class="line">dcc[dcc_cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125; <span class="keyword">while</span>(x != v);</span><br><span class="line">dcc[dcc_cnt].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         low[u] = <span class="built_in">min</span>(low[u], dfn[v]);   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><p>缩点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stk栈, scnt:强连通分量的编号, c[i]:i节点对应的强连通分量编号</span></span><br><span class="line"><span class="type">int</span> stk[N], dfn[N], low[N], c[N], tid, top, scnt;</span><br><span class="line"><span class="type">bool</span> ins[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++tid;</span><br><span class="line">stk[++top] = u, ins[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> v = e[i];</span><br><span class="line"><span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ins[v]) &#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u] == low[u]) &#123;</span><br><span class="line">++scnt;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">v = stk[top--], ins[v] = <span class="number">0</span>;</span><br><span class="line">c[v] = scnt;</span><br><span class="line"><span class="comment">// sz[scnt]++;</span></span><br><span class="line">&#125; <span class="keyword">while</span>(u != v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Two-sat"><a href="#Two-sat" class="headerlink" title="Two-sat"></a>Two-sat</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TwoSat</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; e;</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; ans;</span><br><span class="line">    <span class="built_in">TwoSat</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">e</span>(<span class="number">2</span> * n), <span class="built_in">ans</span>(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addClause</span><span class="params">(<span class="type">int</span> u, <span class="type">bool</span> f, <span class="type">int</span> v, <span class="type">bool</span> g)</span> </span>&#123;</span><br><span class="line">        e[<span class="number">2</span> * u + !f].<span class="built_in">push_back</span>(<span class="number">2</span> * v + g);</span><br><span class="line">        e[<span class="number">2</span> * v + !g].<span class="built_in">push_back</span>(<span class="number">2</span> * u + f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">satisfiable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">id</span><span class="params">(<span class="number">2</span> * n, <span class="number">-1</span>)</span>, <span class="title">dfn</span><span class="params">(<span class="number">2</span> * n, <span class="number">-1</span>)</span>, <span class="title">low</span><span class="params">(<span class="number">2</span> * n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; tarjan = [&amp;](<span class="type">int</span> u) &#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(u);</span><br><span class="line">            dfn[u] = low[u] = now++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : e[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfn[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">tarjan</span>(v);</span><br><span class="line">                    low[u] = std::<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    low[u] = std::<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">                <span class="type">int</span> v;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    v = stk.<span class="built_in">back</span>();</span><br><span class="line">                    stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                    id[v] = cnt;</span><br><span class="line">                &#125; <span class="keyword">while</span> (v != u);</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; ++i) <span class="keyword">if</span> (dfn[i] == <span class="number">-1</span>) <span class="built_in">tarjan</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[<span class="number">2</span> * i] == id[<span class="number">2</span> * i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ans[i] = id[<span class="number">2</span> * i] &gt; id[<span class="number">2</span> * i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">bool</span>&gt; <span class="title">answer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-6-二分图"><a href="#4-6-二分图" class="headerlink" title="4.6 二分图"></a>4.6 二分图</h2><p>二分图最大匹配：匈牙利算法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vis和match针对均为右部节点, u针对左部节点</span></span><br><span class="line"><span class="type">int</span> id = <span class="number">0</span>; <span class="comment">// 优化vis数组,用在全局,防止多样例冲突</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v: g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[v] != id) &#123; <span class="comment">//!vis[v]</span></span><br><span class="line">            vis[v] = id; <span class="comment">// vis[v] = 1;</span></span><br><span class="line">            <span class="keyword">if</span> (!match[v] || <span class="built_in">dfs</span>(match[v])) &#123;</span><br><span class="line">                match[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>; <span class="comment">// 二分图最大匹配数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    id++; <span class="comment">// memset(vis, 0, sizeof(vis));</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dfs</span>(i)) ans++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-网络流"><a href="#4-7-网络流" class="headerlink" title="4.7 网络流"></a>4.7 网络流</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Flow</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">        <span class="type">int</span> to;</span><br><span class="line">        T cap;</span><br><span class="line">        <span class="built_in">edge</span>(<span class="type">int</span> to, T cap) : <span class="built_in">to</span>(to), <span class="built_in">cap</span>(cap) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;edge&gt; e;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c, h;</span><br><span class="line">    <span class="built_in">Flow</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">g</span>(n) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        h.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        h[s] = <span class="number">0</span>;</span><br><span class="line">        que.<span class="built_in">push</span>(s);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> u = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : g[u]) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [v, cap] = e[i];</span><br><span class="line">                <span class="keyword">if</span> (cap &gt; <span class="number">0</span> &amp;&amp; h[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    h[v] = h[u] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (v == t) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    que.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">T <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t, T f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == t) &#123;</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> r = f;</span><br><span class="line">        <span class="keyword">while</span> (c[u]++ &lt; <span class="built_in">int</span>(g[u].<span class="built_in">size</span>())) &#123;</span><br><span class="line">            <span class="type">int</span> j = g[u][c[u] - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> [v, cap] = e[j];</span><br><span class="line">            <span class="keyword">if</span> (cap &gt; <span class="number">0</span> &amp;&amp; h[v] == h[u] + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> a = <span class="built_in">dfs</span>(v, t, <span class="built_in">min</span>(r, cap));</span><br><span class="line">                e[j].cap -= a;</span><br><span class="line">                e[j ^ <span class="number">1</span>].cap += a;</span><br><span class="line">                r -= a;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f - r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, T cap)</span> </span>&#123;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">        e.<span class="built_in">emplace_back</span>(v, cap);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(e.<span class="built_in">size</span>());</span><br><span class="line">        e.<span class="built_in">emplace_back</span>(u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">maxFlow</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, T lim = numeric_limits&lt;T&gt;::max())</span> </span>&#123;</span><br><span class="line">        T ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">bfs</span>(s, t) &amp;&amp; ans &lt; lim) &#123;</span><br><span class="line">            c.<span class="built_in">assign</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">dfs</span>(s, t, lim - ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="5-字符串"><a href="#5-字符串" class="headerlink" title="5 字符串"></a>5 字符串</h1><h2 id="5-1-hash"><a href="#5-1-hash" class="headerlink" title="5.1 hash"></a>5.1 hash</h2><p>$$<br>f[i] &#x3D; f[i - 1] * 131 + (s[i] - ‘a’); \<br>hash(l,r) &#x3D; f[r] - f[l - 1] * 131^{r - l + 1};<br>$$</p><h2 id="5-2-KMP"><a href="#5-2-KMP" class="headerlink" title="5.2 KMP"></a>5.2 KMP</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[N], p[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line">cin &gt;&gt; s + <span class="number">1</span> &gt;&gt; p + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="built_in">strlen</span>(p + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];<span class="comment">//回退</span></span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;<span class="comment">//最长公共前后缀最多增加一</span></span><br><span class="line">    ne[i] = j;<span class="comment">//对当前下标的next数组赋值为最长长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; (j == n || s[i] != p[j + <span class="number">1</span>])) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">    <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">        j = ne[j]; <span class="comment">//匹配成功，后面必然不能再匹配，所以回退一步 </span></span><br><span class="line">        cout &lt;&lt; i - m + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">//匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-Trie"><a href="#5-3-Trie" class="headerlink" title="5.3 Trie"></a>5.3 Trie</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; trie;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">Trie</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">trie.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>));</span><br><span class="line">cnt.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][x]) trie[p][x] = ++idx;</span><br><span class="line">p = trie[p][x];</span><br><span class="line">&#125;</span><br><span class="line">cnt[p++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(s.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line"><span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">p = trie[p][x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-4-Manacher"><a href="#5-4-Manacher" class="headerlink" title="5.4 Manacher"></a>5.4 Manacher</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #a#b#c#b# 返回对应位置最长回文串向前(后)的长度, 包括当前位置 时间复杂度：O(N)</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">manacher</span><span class="params">(std::string s)</span> </span>&#123;</span><br><span class="line">    std::string t = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">        t += c;</span><br><span class="line">        t += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n = t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * j - i &gt;= <span class="number">0</span> &amp;&amp; j + r[j] &gt; i) &#123;</span><br><span class="line">            r[i] = std::<span class="built_in">min</span>(r[<span class="number">2</span> * j - i], j + r[j] - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i - r[i] &gt;= <span class="number">0</span> &amp;&amp; i + r[i] &lt; n &amp;&amp; t[i - r[i]] == t[i + r[i]]) &#123;</span><br><span class="line">            r[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + r[i] &gt; j + r[j]) &#123;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-SAM后缀自动机"><a href="#5-5-SAM后缀自动机" class="headerlink" title="5.5 SAM后缀自动机"></a>5.5 SAM后缀自动机</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SuffixAutomaton</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> ALPHABET_SIZE = <span class="number">26</span>, N = <span class="number">1e5</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> link;</span><br><span class="line">        <span class="type">int</span> next[ALPHABET_SIZE];</span><br><span class="line">        <span class="built_in">Node</span>() : <span class="built_in">len</span>(<span class="number">0</span>), <span class="built_in">link</span>(<span class="number">0</span>), next&#123;&#125; &#123;&#125;</span><br><span class="line">    &#125; t[<span class="number">2</span> * N];</span><br><span class="line">    <span class="type">int</span> cntNodes;</span><br><span class="line">    <span class="built_in">SuffixAutomaton</span>() &#123;</span><br><span class="line">        cntNodes = <span class="number">1</span>;</span><br><span class="line">        std::<span class="built_in">fill</span>(t[<span class="number">0</span>].next, t[<span class="number">0</span>].next + ALPHABET_SIZE, <span class="number">1</span>);</span><br><span class="line">        t[<span class="number">0</span>].len = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : s)</span><br><span class="line">            p = <span class="built_in">extend</span>(p, x - <span class="string">&#x27;a&#x27;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[p].next[c]) &#123;</span><br><span class="line">            <span class="type">int</span> q = t[p].next[c];</span><br><span class="line">            <span class="keyword">if</span> (t[q].len == t[p].len + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            <span class="type">int</span> r = ++cntNodes;</span><br><span class="line">            t[r].len = t[p].len + <span class="number">1</span>;</span><br><span class="line">            t[r].link = t[q].link;</span><br><span class="line">            std::<span class="built_in">copy</span>(t[q].next, t[q].next + ALPHABET_SIZE, t[r].next);</span><br><span class="line">            t[q].link = r;</span><br><span class="line">            <span class="keyword">while</span> (t[p].next[c] == q) &#123;</span><br><span class="line">                t[p].next[c] = r;</span><br><span class="line">                p = t[p].link;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cur = ++cntNodes;</span><br><span class="line">        t[cur].len = t[p].len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!t[p].next[c]) &#123;</span><br><span class="line">            t[p].next[c] = cur;</span><br><span class="line">            p = t[p].link;</span><br><span class="line">        &#125;</span><br><span class="line">        t[cur].link = <span class="built_in">extend</span>(p, c);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; sam;</span><br></pre></td></tr></table></figure><h1 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6 动态规划"></a>6 动态规划</h1><h2 id="6-数位DP"><a href="#6-数位DP" class="headerlink" title="6. 数位DP"></a>6. 数位DP</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [l, r] 中有多少个圆数(2进制表示中0的个数不小于1的个数)</span></span><br><span class="line"><span class="comment">// 状态复用：f[pos][][] 表示[1,pos]任意填,[pos+1,len]已经填好的情况,此时memset可以最开始多组样例前</span></span><br><span class="line"><span class="comment">// 此时需要简单改动代码 if (~v &amp;&amp; !lim) return v; 以及 if (!lim) v = ans; return ans;</span></span><br><span class="line"><span class="comment">// lead:是否有前导零 lim:前面的数是否贴着边界 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="type">int</span> a[N], len;</span><br><span class="line">ll f[N][<span class="number">2</span>][<span class="number">2</span>][<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> lim, <span class="type">int</span> lead, <span class="type">int</span> cnt0, <span class="type">int</span> cnt1)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!pos) <span class="keyword">return</span> (cnt0 &gt;= cnt1);</span><br><span class="line"><span class="keyword">auto</span> &amp;v = f[pos][lim][lead][cnt0][cnt1];</span><br><span class="line">    <span class="keyword">if</span> (~v) <span class="keyword">return</span> v;</span><br><span class="line"><span class="type">int</span> up = lim ? a[pos] : <span class="number">1</span>;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++) &#123;</span><br><span class="line"><span class="type">int</span> t0 = cnt0 + (!lead &amp;&amp; i == <span class="number">0</span>);</span><br><span class="line">ans += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, lim &amp;&amp; i == up, lead &amp;&amp; i == <span class="number">0</span>, t0, cnt1 + (i == <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[pos][lim][lead][cnt0][cnt1] = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">len = <span class="number">0</span>; <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f)); </span><br><span class="line"><span class="keyword">while</span> (x) &#123;</span><br><span class="line">a[++len] = x % <span class="number">2</span>;</span><br><span class="line">x /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ll l, r;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">cout &lt;&lt; <span class="built_in">calc</span>(r) - <span class="built_in">calc</span>(l - <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-计算几何"><a href="#7-计算几何" class="headerlink" title="7. 计算几何"></a>7. 计算几何</h1><h2 id="7-1-点"><a href="#7-1-点" class="headerlink" title="7.1 点"></a>7.1 点</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(a-b);&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sqr</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">inmid</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> l,<span class="type">double</span> r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x-l)&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">sgn</span>(r-x)&gt;=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">    <span class="built_in">Point</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> xx,<span class="type">double</span> yy)&#123;x=xx;y=yy;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%Lf %Lf&quot;</span>,&amp;x,&amp;y);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">&quot;%.0f %.0f\n&quot;</span>,x,y);&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> ==(<span class="type">const</span> Point &amp;p)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x-p.x)==<span class="number">0</span>&amp;&amp;<span class="built_in">sgn</span>(y-p.y)==<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> !=(<span class="type">const</span> Point &amp;p)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x-p.x)!=<span class="number">0</span>||<span class="built_in">sgn</span>(y-p.y)!=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point &amp;p)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sgn</span>(x-p.x)&lt;<span class="number">0</span>||(<span class="built_in">sgn</span>(x-p.x)==<span class="number">0</span>&amp;&amp;<span class="built_in">sgn</span>(y-p.y)&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="type">const</span> Point &amp;p)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x+p.x,y+p.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> - (<span class="type">const</span> Point &amp;p)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x-p.x,y-p.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> * (<span class="type">double</span> k)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x*k,y*k&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span> / (<span class="type">const</span> <span class="type">double</span> &amp;k)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x/k,y/k&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dot</span><span class="params">(Point p)</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> p.x*x+p.y*y;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cross</span><span class="params">(Point p)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> x * p.y - y * p.x;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(Point p)</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">sqr</span>(x - p.x) + <span class="built_in">sqr</span>(y - p.y));&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">abs</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> <span class="built_in">hypot</span>(x,y);&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">abs2</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqr</span>(x)+<span class="built_in">sqr</span>(y);&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">rad</span><span class="params">(Point a,Point b)</span><span class="type">const</span></span>&#123;</span><br><span class="line">        Point k1=a-(*<span class="keyword">this</span>),k2=b-(*<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atan2l</span>(k1.<span class="built_in">cross</span>(k2), k1.<span class="built_in">dot</span>(k2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123; <span class="comment">// 极角排序的点</span></span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="built_in">Point</span>(ll x, ll y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; <span class="number">0</span> || y == <span class="number">0</span> &amp;&amp; x &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">cross</span><span class="params">(<span class="type">const</span> Point&amp; rhs)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x * rhs.y - rhs.x * y; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point&amp; rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">area</span>() &lt; rhs.<span class="built_in">area</span>() || <span class="built_in">area</span>() == rhs.<span class="built_in">area</span>() &amp;&amp; <span class="built_in">cross</span>(rhs) &gt; <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> Point&amp; rhs) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">area</span>() == rhs.<span class="built_in">area</span>() &amp;&amp; <span class="built_in">cross</span>(rhs) == <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022杭电多校2 Static Query on Tree|树链剖分</title>
      <link href="/p/3388199031.html"/>
      <url>/p/3388199031.html</url>
      
        <content type="html"><![CDATA[<h1 id="Static-Query-on-Tree"><a href="#Static-Query-on-Tree" class="headerlink" title="Static Query on Tree"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=7150">Static Query on Tree</a></h1><p>下面介绍树链剖分做法（即题解的第二种做法）</p><p><img src="/3388199031/image-20220722223108042.png" alt="题目描述"></p><blockquote><p>题目大意：</p><p>一棵内向树，三个集合A，B，C，每个集合里面有一些点，求特定点的个数，满足从A集合和B集合可以到达该特定点，且可以从该特定点到达C集合。</p></blockquote><p>可以把从A集合到达根节点路径中都打上A标记，把从B集合到达根节点路径中都打上B标记，那么树中被打上A和B标记的就是A和B集合都可以到达的点。（因为是内向树，所以向根节点方向走）</p><p>只需要判断这些打上A和B标记的点能否到达C节点即可，方法也是同样的，将C集合中的每个点和其子树上的点都打上C标记，只要统计树中同时被打上ABC标记的点的个数即可（此时可以用线段树维护标记）。</p><p><strong>线段树记录变量</strong></p><ul><li>$tr[u].cnt[i]$</li></ul><p>$tr[u].cnt[i]$中的$i$有三个值，0，1，2，分别代表被打上A标记的点，被打上AB标记的点，被打上ABC标记的点。</p><p>则$tr[u].cnt[i]$则共可以表示在对应的线段树节点表示的区间上被打上A标记的点的个数（$i &#x3D; 0$），被打上AB标记的点的个数（$i &#x3D; 1$），被打上ABC标记的点的个数（$i &#x3D; 2$）。</p><ul><li>$tr[u].flag[i]$</li></ul><p>共有三个值<code>-1</code>，<code>0</code>， <code>1</code></p><p>初始值等于<code>-1</code>，为<code>0</code>代表对应的区间置为0</p><p>懒标记下传方法：</p><p>在下传懒标记A时，因为A是第一次标记，无需其他条件，直接下传，记录一下<code>cnt</code>变量即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tr[u &lt;&lt; <span class="number">1</span>].cnt[i] = tr[u].flag[i] * (mid - l + <span class="number">1</span>);</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].cnt[i] = tr[u].flag[i] * (r - mid); </span><br></pre></td></tr></table></figure><p>下传懒标记B和C时，就需要有限制条件了，下传懒标记B我们需要有A标记才能求被标记A和B的节点，即被标记AB的节点的数量等于被标记A节点的数量乘对应的懒标记。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tr[u &lt;&lt; <span class="number">1</span>].cnt[i] = tr[u].flag[i] * tr[u &lt;&lt; <span class="number">1</span>].cnt[i - <span class="number">1</span>];</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].cnt[i] = tr[u].flag[i] * tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].cnt[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>接下来就是树链剖分的板子了，可以看下面链接</p><p><a href="../shupou1000">树链剖分模板题</a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">3</span>], flag[<span class="number">3</span>];</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dep[N], fa[N], son[N], sz[N];</span><br><span class="line"><span class="type">int</span> cnt, nw[N], top[N], id[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[M], h[N], ne[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    tr[u].cnt[i] = tr[u &lt;&lt; <span class="number">1</span>].cnt[i] + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].cnt[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].flag[i] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    tr[u &lt;&lt; <span class="number">1</span>].flag[i] = tr[u].flag[i];</span><br><span class="line">    tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].flag[i] = tr[u].flag[i];</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    tr[u &lt;&lt; <span class="number">1</span>].cnt[i] = tr[u].flag[i] * (mid - l + <span class="number">1</span>);</span><br><span class="line">    tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].cnt[i] = tr[u].flag[i] * (r - mid); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    tr[u &lt;&lt; <span class="number">1</span>].cnt[i] = tr[u].flag[i] * tr[u &lt;&lt; <span class="number">1</span>].cnt[i - <span class="number">1</span>];</span><br><span class="line">    tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].cnt[i] = tr[u].flag[i] * tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].cnt[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    tr[u].flag[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        tr[u].cnt[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        tr[u].flag[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= x &amp;&amp; r &lt;= y)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].flag[d] = v;</span><br><span class="line">        <span class="keyword">if</span>(d == <span class="number">0</span>)</span><br><span class="line">        tr[u].cnt[<span class="number">0</span>] = (r - l + <span class="number">1</span>) * v;</span><br><span class="line">        <span class="keyword">else</span> tr[u].cnt[d] = tr[u].cnt[d - <span class="number">1</span>] * v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(u, l, r);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, mid, x, y, d, v);</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, d, v);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= x &amp;&amp; r &lt;= y)</span><br><span class="line">    <span class="keyword">return</span> tr[u].cnt[<span class="number">2</span>] % p;</span><br><span class="line">    <span class="built_in">pushdown</span>(u, l, r);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid) ans = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, mid, x, y) % p;</span><br><span class="line">    <span class="keyword">if</span>(y &gt; mid) ans = (ans + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y)) % p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理dep[],fa[],sz[],son[](重儿子节点)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f, <span class="type">int</span> depth)</span><span class="comment">//x : 当前节点, f：父亲, depth：深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x] = depth;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mxson = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = e[i];</span><br><span class="line">        <span class="keyword">if</span>(y == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y, x, depth + <span class="number">1</span>);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        <span class="keyword">if</span>(sz[y] &gt; mxson)<span class="comment">// 记录重儿子编号</span></span><br><span class="line">        &#123;</span><br><span class="line">            son[x] = y;</span><br><span class="line">            mxson = sz[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标新序号 求id[], nw[], top[] 新id-新节点权重-链顶端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> topf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id[x] = ++cnt;</span><br><span class="line">    nw[cnt] = w[x];</span><br><span class="line">    top[x] = topf;</span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span>;<span class="comment">//无儿子返回</span></span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = e[i];</span><br><span class="line">        <span class="keyword">if</span>(y == fa[x] || y == son[x])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">queryRange</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])<span class="comment">//不在同一条链上</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x]);</span><br><span class="line">        ans %= p;</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y])</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    ans = (ans + <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y])) % p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyRange</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v %= p;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x], d, v);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y])</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y], d, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">querySon</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x] + sz[x] - <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifySon</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x] + sz[x] - <span class="number">1</span>, d, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot[<span class="number">3</span>], node[<span class="number">4</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    cin &gt;&gt; to;</span><br><span class="line">        <span class="built_in">add</span>(to, i);</span><br><span class="line">        <span class="built_in">add</span>(i, to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(r, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(r, r);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    cin &gt;&gt; tot[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot[i]; j++)</span><br><span class="line">    &#123;</span><br><span class="line">    cin &gt;&gt; node[i][j];</span><br><span class="line">    <span class="keyword">if</span>(i != <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">modifyRange</span>(<span class="number">1</span>, node[i][j], i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">modifySon</span>(node[i][j], i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">querySon</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">modifySon</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">modifySon</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">modifySon</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="comment">// t = 1;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分|模板题</title>
      <link href="/p/1046407529.html"/>
      <url>/p/1046407529.html</url>
      
        <content type="html"><![CDATA[<h1 id="树链剖分模板题"><a href="#树链剖分模板题" class="headerlink" title="树链剖分模板题"></a>树链剖分模板题</h1><p>题目链接：</p><p><a href="https://www.luogu.com.cn/problem/P3384">https://www.luogu.com.cn/problem/P3384</a></p><p><img src="/1046407529/f09feafcf66f44c0b0e215ff94c1ca40.png" alt="问题描述"></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, M = <span class="number">2</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, r, p;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span></span><br><span class="line">&#123;</span><br><span class="line">ll add, sum;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dep[N], fa[N], son[N], sz[N];</span><br><span class="line"><span class="type">int</span> cnt, nw[N], top[N], id[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[M], h[N], ne[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tr[u].sum = (tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(tr[u].add)</span><br><span class="line">&#123;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span>].add += tr[u].add;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span>].sum += <span class="number">1ll</span> * (mid - l + <span class="number">1</span>) * tr[u].add;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span>].sum %= p;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].add += tr[u].add;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum += <span class="number">1ll</span> * (r - mid) * tr[u].add;</span><br><span class="line">tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum %= p;</span><br><span class="line">tr[u].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">tr[u].sum = nw[l];</span><br><span class="line"><span class="keyword">if</span>(tr[u].sum &gt; p) tr[u].sum %= p;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line"><span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= x &amp;&amp; r &lt;= y)</span><br><span class="line">&#123;</span><br><span class="line">tr[u].sum += <span class="number">1ll</span> * (r - l + <span class="number">1</span>) * d;</span><br><span class="line">tr[u].sum %= p;</span><br><span class="line">tr[u].add += d;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(u, l, r);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, mid, x, y, d);</span><br><span class="line"><span class="keyword">if</span>(y &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, d);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= x &amp;&amp; r &lt;= y)</span><br><span class="line"><span class="keyword">return</span> tr[u].sum % p;</span><br><span class="line"><span class="built_in">pushdown</span>(u, l, r);</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= mid) ans = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, mid, x, y) % p;</span><br><span class="line"><span class="keyword">if</span>(y &gt; mid) ans = (ans + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y)) % p;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理dep[],fa[],sz[],son[](重儿子节点)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f, <span class="type">int</span> depth)</span><span class="comment">//x : 当前节点, f：父亲, depth：深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[x] = depth;</span><br><span class="line">fa[x] = f;</span><br><span class="line">sz[x] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> mxson = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> y = e[i];</span><br><span class="line"><span class="keyword">if</span>(y == f) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(y, x, depth + <span class="number">1</span>);</span><br><span class="line">sz[x] += sz[y];</span><br><span class="line"><span class="keyword">if</span>(sz[y] &gt; mxson)<span class="comment">// 记录重儿子编号</span></span><br><span class="line">&#123;</span><br><span class="line">son[x] = y;</span><br><span class="line">mxson = sz[y];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标新序号 求id[], nw[], top[] 新id-新节点权重-链顶端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> topf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">id[x] = ++cnt;</span><br><span class="line">nw[cnt] = w[x];</span><br><span class="line">top[x] = topf;</span><br><span class="line"><span class="keyword">if</span>(!son[x]) <span class="keyword">return</span>;<span class="comment">//无儿子返回</span></span><br><span class="line"><span class="built_in">dfs2</span>(son[x], topf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = h[x]; ~i; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> y = e[i];</span><br><span class="line"><span class="keyword">if</span>(y == fa[x] || y == son[x])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(y, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">queryRange</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[x] != top[y])<span class="comment">//不在同一条链上</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line">ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x]);</span><br><span class="line">ans %= p;</span><br><span class="line">x = fa[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[x] &gt; dep[y])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line">ans = (ans + <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y])) % p;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyRange</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">d %= p;</span><br><span class="line"><span class="keyword">while</span>(top[x] != top[y])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x], d);</span><br><span class="line">x = fa[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[x] &gt; dep[y])</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y], d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">querySon</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x] + sz[x] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifySon</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x] + sz[x] - <span class="number">1</span>, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cin &gt;&gt; w[i];</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line"><span class="built_in">add</span>(u, v);</span><br><span class="line"><span class="built_in">add</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(r, <span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(r, r);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> op, x, y, z;</span><br><span class="line">cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; y &gt;&gt; z;</span><br><span class="line"><span class="built_in">modifyRange</span>(x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; y;</span><br><span class="line">cout &lt;&lt; <span class="built_in">queryRange</span>(x, y) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; z;</span><br><span class="line"><span class="built_in">modifySon</span>(x, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">cout &lt;&lt; <span class="built_in">querySon</span>(x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令总结</title>
      <link href="/p/1146830909.html"/>
      <url>/p/1146830909.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>将当前用户添加到docker用户组</p><p>为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组（可以参考官方文档）：</p><p><code>sudo usermod -aG docker $USER</code></p><p>执行完此操作后，需要退出服务器，再重新登录回来，才可以省去sudo权限。</p></blockquote><h1 id="镜像（images）"><a href="#镜像（images）" class="headerlink" title="镜像（images）"></a>镜像（images）</h1><p><code>docker pull ubuntu:20.04</code>：拉取一个镜像</p><p><code>docker images</code>：列出本地所有镜像</p><p><code>docker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04</code>：删除镜像ubuntu:20.04</p><p><code>docker [container] commit CONTAINER IMAGE_NAME:TAG</code>：创建某个container的镜像</p><p><code>docker save -o ubuntu_20_04.tar ubuntu:20.04</code>：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中</p><p><code>docker load -i ubuntu_20_04.tar</code>：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来</p><h1 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h1><p><code>docker [container] create -it ubuntu:20.04</code>：利用镜像ubuntu:20.04创建一个容器。</p><p><code>docker ps -a</code>：查看本地的所有容器</p><p><code>docker [container] start CONTAINER</code>：启动容器</p><p><code>docker [container] stop CONTAINER</code>：停止容器</p><p><code>docker [container] restart CONTAINER</code>：重启容器</p><p><code>docker [contaienr] run -itd ubuntu:20.04</code>：创建并启动一个容器</p><p><code>docker [container] attach CONTAINER</code>：进入容器，先按Ctrl-p，再按Ctrl-q可以挂起容器</p><p><code>docker [container] exec CONTAINER COMMAND</code>：在容器中执行命令</p><p><code>docker [container] rm CONTAINER</code>：删除容器</p><p><code>docker container prune</code>：删除所有已停止的容器</p><p><code>docker export -o xxx.tar CONTAINER</code>：将容器CONTAINER导出到本地文件xxx.tar中</p><p><code>docker import xxx.tar image_name:tag</code>：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag</p><p><code>docker export/import</code>与<code>docker save/load</code>的区别：</p><ul><li><p>export&#x2F;import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态</p></li><li><p>save&#x2F;load会保存完整记录，体积更大</p></li></ul><p><code>docker top CONTAINER</code>：查看某个容器内的所有进程</p><p><code>docker stats</code>：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息</p><p><code>docker cp xxx CONTAINER:xxx</code> 或 <code>docker cp CONTAINER:xxx xxx</code>：在本地和容器间复制文件</p><p><code>docker rename CONTAINER1 CONTAINER2</code>：重命名容器</p><p><code>docker update CONTAINER --memory 500MB</code>：修改容器限制</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp docker_1_0.tar server_name  <span class="comment"># 将镜像上传到自己租的云端服务器</span></span><br><span class="line"></span><br><span class="line">ssh server_name  <span class="comment"># 登录自己的云端服务器</span></span><br><span class="line"></span><br><span class="line">docker load -i docker_1_0.tar  <span class="comment"># 将镜像加载到本地</span></span><br><span class="line"></span><br><span class="line">docker run -p 20000:22 --name my_docker_server -itd docker:1.0  <span class="comment"># 创建并运行docker:1.0镜像, 20000端口映射到22</span></span><br><span class="line"></span><br><span class="line">docker attach my_docker_server  <span class="comment"># 进入创建的docker容器</span></span><br></pre></td></tr></table></figure><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images <span class="comment"># 列出本地所有镜像</span></span><br><span class="line">docker ps -a <span class="comment"># 列出本地所有容器</span></span><br><span class="line">docker ps <span class="comment"># 列出运行中的容器</span></span><br></pre></td></tr></table></figure><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:20.04 <span class="comment"># 拉取一个镜像</span></span><br><span class="line">docker image <span class="built_in">rm</span> ubuntu:20.04 <span class="comment"># 删除一个镜像</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container start CONTAINER <span class="comment">#启动容器</span></span><br><span class="line">docker container stop CONTAINER <span class="comment">#停止容器</span></span><br><span class="line">docker container attach CONTAINER <span class="comment">#进入容器，先按Ctrl-p，再按Ctrl-q可以挂起容器(容器必须启动才可进入)</span></span><br></pre></td></tr></table></figure><h2 id="镜像与容器操作"><a href="#镜像与容器操作" class="headerlink" title="镜像与容器操作"></a>镜像与容器操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container create -it ubuntu:20.04 name <span class="comment"># 利用镜像ubuntu:20.04创建一个名为name的容器</span></span><br><span class="line">docker container commit CONTAINER IMAGE_NAME:TAG <span class="comment">#创建某个container的镜像</span></span><br><span class="line">docker run -p 20000:22 --name NAME -itd docker:1.0  <span class="comment"># 利用docker:1.0镜像创建一个名为NAME的容器并运行容器, 并将主机20000端口映射到容器22</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git|详解|命令</title>
      <link href="/p/1843856130.html"/>
      <url>/p/1843856130.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git命令-详解"><a href="#Git命令-详解" class="headerlink" title="Git命令 | 详解"></a>Git命令 | 详解</h1><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>Git是基于树进行维护的，每一个节点都是一个历史版本，可以进行代码管理。</p><p><img src="/1843856130/webp.webp" alt="Git图示"></p><blockquote><p>工作区（Workspace） ：就是会出现工作目录，即自己要编写的代码</p><p>暂存区（Index &#x2F; Stage）  </p><p>本地仓库（Repository）  </p><p>远程仓库（Remote）</p></blockquote><h1 id="配置Git命令"><a href="#配置Git命令" class="headerlink" title="配置Git命令"></a>配置Git命令</h1><blockquote><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p></blockquote><p><code>git config --list</code> : 显示当前的Git配置</p><p><code>git config -e [--global]</code> : 编辑Git配置文件</p><p><code>git config [--global] user.name xxx</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</p><p><code>git config [--global] user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</p><p><code>git config --global init.defaultBranch &lt;defaultBranch&gt;</code>：配置初始默认的分支名</p><p><code>git init</code>：将当前目录配置成 <code>git</code> 仓库，信息记录在隐藏的<code>.git</code>文件夹中</p><h1 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h1><p><code>git status</code>：显示有变更的文件</p><p><code>git restore XXX</code> : 将工作区的XXX文件的修改（该修改未添加到暂存区）恢复</p><p><code>git add XX</code>：将XX文件的 <strong>修改信息</strong> 添加到<strong>暂存区</strong></p><p><code>git add .</code>：将当前工作区的所有文件的修改信息加入<strong>暂存区</strong></p><p><code>git rm [file1] [file2] ...</code> : 删除工作区文件，并把这次删除加入到暂存区</p><p><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容</p><p><code>git checkout — XX</code>或<code>git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销</p><blockquote><p>更多撤销操作见下文 【撤销回退】</p></blockquote><h1 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h1><p><code>git rm --cached XX</code>：将文件XX从暂存区中删掉，停止追踪指定文件，但该文件会保留在工作区</p><p><code>git restore --staged XXX</code> ： 将<strong>暂存区</strong>的XXX清空，工作区<strong>不变</strong></p><p><code>git commit -m &quot;给自己看的备注信息&quot;</code>：将<strong>暂存区</strong>的内容提交到当前分支（可持久化）</p><p><code>git checkout [file] </code>: 恢复暂存区的指定文件到工作区（工作区文件发生改变）</p><p><code>git reset [file]</code> : 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p><blockquote><p>更多撤销操作见下文 【撤销回退】</p></blockquote><h1 id="分支相关命令"><a href="#分支相关命令" class="headerlink" title="分支相关命令"></a>分支相关命令</h1><ul><li>查看分支</li></ul><p><code>git branch </code>: 查看本地分支</p><p><code>git branch -r</code> : 列出所有远程分支</p><p><code>git branch -a</code> ： 列出所有本地分支和远程分支</p><ul><li>删除分支</li></ul><p><code>git branch -d branch_name</code>：删除本地的branch_name分支</p><p><code>git push origin --delete [branch-name]</code> ： 删除远程分支</p><ul><li>切换分支</li></ul><p><code>git checkout branch_name</code>：切换到branch_name这个分支</p><p><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支</p><h2 id="1-本地分支"><a href="#1-本地分支" class="headerlink" title="1 本地分支"></a>1 本地分支</h2><p><code>git branch </code>: 列出所有本地分支</p><p><code>git branch branch_name</code>：创建新分支，但依然停留在当前分支</p><p><code>git checkout branch_name</code>：切换到branch_name这个分支，并更新工作区</p><p><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支</p><p><code>git branch -m oldBranchName newBranchName</code> ： 修改本地分支名字</p><p><code>git merge branch_name</code>：将分支branch_name合并到当前分支上</p><p><code>git checkout - </code>： 切换到上一个分支</p><p><code>git cherry-pick [commit]</code> ： 选择一个commit，合并进当前分支</p><p><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</p><h2 id="2-远程分支"><a href="#2-远程分支" class="headerlink" title="2 远程分支"></a>2 远程分支</h2><p><code>git branch -r</code> : 列出所有远程分支</p><p><code>git branch [branch] [commit] </code>： 新建一个分支，指向指定commit</p><p><code>git push origin --delete [branch-name]</code> ： 删除远程分支</p><p><code>git branch -dr [remote/branch]</code> ： 删除远程分支</p><h2 id="3-本地和远程"><a href="#3-本地和远程" class="headerlink" title="3 本地和远程"></a>3 本地和远程</h2><p><code>git branch -a</code> ： 列出所有本地分支和远程分支</p><p><code>git branch --track [branch] [remote-branch]</code> ： 新建一个分支，与指定的远程分支建立追踪关系</p><p><code>git branch --set-upstream [branch] [remote-branch]</code> ： 建立追踪关系，在现有分支与指定的远程分支之间 （现在已经不支持）</p><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</p><h1 id="日志信息查看"><a href="#日志信息查看" class="headerlink" title="日志信息查看"></a>日志信息查看</h1><p><code>git log</code>：查看当前分支的所有版本</p><p><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）</p><p><code>git status</code> : 显示当前工作区有变更的文件</p><p><code>git log --stat</code> : 显示commit历史，以及每次commit发生变更的文件</p><p><code>git log -S [keyword] </code>: 搜索提交历史，根据关键词</p><p><code>git log [tag] HEAD --pretty=format:%s</code> : 显示某个commit之后的所有变动，每个commit占据一行</p><p><code>git log [tag] HEAD --grep feature</code> : 显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</p><p><code>git log --follow [file] </code>: 显示某个文件的版本历史，包括文件改名</p><p><code>git whatchanged [file]</code> : 显示某个文件的版本历史，包括文件改名</p><p><code>git log -p [file]</code> : 显示指定文件相关的每一次diff</p><p><code>git log -5 --pretty --oneline </code>: 显示过去5次提交</p><p><code>git shortlog -sn</code> : 显示所有提交过的用户，按提交次数排序</p><p><code>git blame [file]</code> : 显示指定文件是什么人在什么时间修改过</p><p><code>git diff</code> : 显示暂存区和工作区的差异</p><p><code>git diff --cached [file]</code> : 显示暂存区和上一个commit的差异</p><p><code>git diff HEAD </code>: 显示工作区与当前分支最新commit之间的差异</p><p><code>git diff [first-branch]...[second-branch] </code>: 显示两次提交之间的差异</p><p><code>git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</code> : 显示今天你写了多少行代码</p><p><code>git show [commit]</code> : 显示某次提交的元数据和内容变化</p><p><code>git show --name-only [commit] </code>: 显示某次提交发生变化的文件</p><p><code>git show [commit]:[filename]</code> : 显示某次提交时，某个文件的内容</p><h1 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h1><h2 id="1-仓库关联"><a href="#1-仓库关联" class="headerlink" title="1 仓库关联"></a>1 仓库关联</h2><p><code>git remote -v</code> ： 查看与远程仓库的关联</p><p><code>git remote remove origin</code> ：删除与远程仓库的关联</p><p><code>git remote add origin git@github.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</p><h2 id="2-拉取-推送-克隆"><a href="#2-拉取-推送-克隆" class="headerlink" title="2 拉取&amp;推送&amp;克隆"></a>2 拉取&amp;推送&amp;克隆</h2><h3 id="2-1-拉取"><a href="#2-1-拉取" class="headerlink" title="2.1 拉取"></a>2.1 拉取</h3><p><code>git pull</code>：将远程仓库的<strong>当前分支</strong>与本地仓库的<strong>当前分支</strong>合并</p><p><code>git pull origin branch_name</code>：将远程仓库的 <code>branch_name</code> 分支与本地仓库的当前分支合并</p><p><code>git checkout -t origin/branch_name</code>: 将远程的branch_name分支拉取到本地</p><h3 id="2-2-推送"><a href="#2-2-推送" class="headerlink" title="2.2 推送"></a>2.2 推送</h3><blockquote><p>注意 <code>push</code> 操作会默认推送到和本地分支名相同的远程仓库的分支，如果远程仓库没有同名分支，会推送到默认分支。优先级：同名分支&gt;默认分支。</p><p>如果推送到默认分支，你可能需要在远程进行merge操作了。</p></blockquote><p><code>git push -u </code> （第一次需要-u以后不需要）：将当前分支推送到远程仓库</p><p><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</p><p><code>git push --set-upstream origin branch_name</code>：将本地的branch_name分支推送到远程仓库的branch_name分支</p><blockquote><p>如果远程没有 <code>branch_name</code> 分支，会自动创建该分支。</p><p><code>git push origin main:branch_name</code>  命令类似，将 <code>main</code> 推送到 <code>branch_name</code> 分支，如果没有，便创建</p></blockquote><p><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支</p><h3 id="2-3-克隆"><a href="#2-3-克隆" class="headerlink" title="2.3 克隆"></a>2.3 克隆</h3><p>下载下来就是一个仓库，无需进行 <code>git init</code> 操作。</p><p><code>git clone git@github.com:anda522/XXX.git</code>：将远程仓库XXX下载到当前目录下</p><h1 id="撤销回退"><a href="#撤销回退" class="headerlink" title="撤销回退"></a>撤销回退</h1><p><code>git reset --hard </code>: 重置暂存区与工作区，与上一次commit保持一致</p><p><code>git reset --hard HEAD^</code> 或 <code>git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p><p><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</p><p><code>git reset --hard HEAD~100</code>：往上回滚100个版本</p><p><code>git reset --hard 版本号</code>：回滚到某一特定版本</p><p><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</p><p><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</p><p><code>git stash drop</code>：删除栈顶存储的修改</p><p><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</p><p><code>git stash list</code>：查看栈中所有元素</p><p><code>git checkout [file] </code>: 恢复暂存区的指定文件到工作区</p><p><code>git checkout [commit] [file]</code> : 恢复某个commit的指定文件到暂存区和工作区</p><p><code>git checkout .</code> : 恢复暂存区的所有文件到工作区</p><p><code>git reset [file]</code> : 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p><p><code>git reset [commit] </code>: 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p><p><code>git reset --hard [commit]</code> : 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p><p><code>git reset --keep [commit]</code> : 重置当前HEAD为指定commit，但保持暂存区和工作区不变</p><p><code>git revert [commit]</code> : 新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支</p><h1 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h1><h2 id="1-基础上传操作"><a href="#1-基础上传操作" class="headerlink" title="1 基础上传操作"></a>1 基础上传操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;备注信息&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="2-新建仓库的初始化操作"><a href="#2-新建仓库的初始化操作" class="headerlink" title="2 新建仓库的初始化操作"></a>2 新建仓库的初始化操作</h2><ol><li>远程新建仓库，默认不添加<code>README.md</code>文件</li><li>此时请注意远程仓库的主分支名为<code>main</code>还是<code>master</code></li><li>本地新建一个文件夹用来作为上传该远程仓库的文件（或者用已存在的文件夹也行），在该目录下使用<code>git init</code>命令初始化仓库</li><li>将本地仓库主分支名字设为和远端一样，例如<code>git branch -M main</code></li><li>关联远程仓库，例如<code>git remote add origin https://github.com/anda522/bot.git</code></li><li>上传的操作：</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;提交代码的备注信息&quot;</span></span><br><span class="line">git push <span class="comment">#（此代码一般会报错）</span></span><br></pre></td></tr></table></figure><blockquote><p>报错原因：新建仓库时默认仓库为空，此时没有任何分支，如果本地有分支需要上传到远程的相同的分支上，需要将远程新建一个分支进行push操作。</p><p>故代码可更新为：<code>git push --set-upstream origin main</code> 或 <code>git push origin main:main</code> </p></blockquote><h2 id="3-新建dev分支并上传"><a href="#3-新建dev分支并上传" class="headerlink" title="3 新建dev分支并上传"></a>3 新建dev分支并上传</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev <span class="comment"># 本地新建一个dev分支，并且切换到dev分支</span></span><br><span class="line">git push --set-upstream origin dev <span class="comment"># 本地在dev分支；需要上传在dev分支的操作；默认远端没有dev分支，远端将创建一个dev分支并进行push操作</span></span><br></pre></td></tr></table></figure><h2 id="4-删除久远的未被追踪的分支"><a href="#4-删除久远的未被追踪的分支" class="headerlink" title="4 删除久远的未被追踪的分支"></a>4 删除久远的未被追踪的分支</h2><p>有时候分支已经从远程分支中删除，但是本地分支并不知道当前这几个远程分支是否被删除，可以使用<code>git remote show origin</code>命令查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote show origin <span class="comment">#  会出现stale (use &#x27;git remote prune&#x27; to remove)字样</span></span><br><span class="line"><span class="comment"># git branch -a 这个可以看到远程不存在的分支还能显示出来</span></span><br><span class="line">git remote prune origin <span class="comment"># 删除未被追踪的分支</span></span><br></pre></td></tr></table></figure><h2 id="5-打tag"><a href="#5-打tag" class="headerlink" title="5 打tag"></a>5 打tag</h2><ul><li>以本地最后一个<code>commit</code>创建tag</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag &lt;tagName&gt; <span class="comment"># 基于本地最后一个commit创建一个tag</span></span><br><span class="line">git push origin &lt;tagName&gt; <span class="comment"># 将tag推送到远程仓库</span></span><br><span class="line">git push origin --tags <span class="comment"># 将所有tag推送到远程仓库</span></span><br></pre></td></tr></table></figure><ul><li>以特定的提交为tag</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline <span class="comment"># 查看当前分支的提交历史 里面包含 commit id</span></span><br><span class="line">git tag -a &lt;tagName&gt; &lt;commitId&gt;</span><br></pre></td></tr></table></figure><ul><li>查看信息</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git show &lt;tagName&gt; <span class="comment"># 查看tag的详细信息</span></span><br><span class="line">git tag <span class="comment"># 查看本地所有tag</span></span><br><span class="line">git ls-remote --tag origin <span class="comment"># 查看远程tag</span></span><br></pre></td></tr></table></figure><ul><li>删除tag</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d &lt;tagName&gt; <span class="comment"># 删除本地tag</span></span><br><span class="line">git push origin :refs/tags/&lt;tagName&gt; <span class="comment"># 删除远程tag</span></span><br></pre></td></tr></table></figure><ul><li>其他</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m <span class="string">&quot;XXX...&quot;</span> <span class="comment"># 指定标签信息</span></span><br><span class="line">git tag -a v1.0 -m <span class="string">&quot;release 0.1.0 version&quot;</span>  <span class="comment"># 创建附注标签</span></span><br><span class="line">git checkout [tagname] <span class="comment"># 切换标签</span></span><br></pre></td></tr></table></figure><h2 id="6-git-fetch和git-pull对比"><a href="#6-git-fetch和git-pull对比" class="headerlink" title="6 git fetch和git pull对比"></a>6 git fetch和git pull对比</h2><ul><li><code>git fetch</code>：将远程更新信息全部取回本地</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; //这个命令将某个远程主机的更新全部取回本地</span><br></pre></td></tr></table></figure><p>如果只想取回特定分支，可以指定分支名</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt; //注意之间有空格</span><br></pre></td></tr></table></figure><p>常见命令：</p><p>取回<code>origin</code> 主机的<code>master</code> 分支：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure><p>取回更新后会返回一个<code>FETCH_HEAD</code> ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p FETCH_HEAD</span><br></pre></td></tr></table></figure><p>可以看到返回的信息包括更新的文件名，更新的作者和时间，以及更新的代码。我们可以通过这些信息来判断是否产生冲突，以确定是否将更新merge到当前分支。 </p><hr><ul><li><code>git pull</code>：拉取并合并</li></ul><p>可以理解为两个过程：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch origin master //从远程主机的master分支拉取最新内容 </span><br><span class="line">git merge FETCH_HEAD    //将拉取下来的最新内容合并到当前所在的分支中</span><br></pre></td></tr></table></figure><p>完整命令：将远程主机的某个分支的更新取回，并与本地指定的分支合并</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><p>如果是与当前分支合并，则冒号后面的可以省略，例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><h2 id="7-远程仓库名改动"><a href="#7-远程仓库名改动" class="headerlink" title="7 远程仓库名改动"></a>7 远程仓库名改动</h2><p>需要进行仓库名改动，先改动了远程仓库名，本地目录名不变就行。</p><p>之后就要进行重新关联远程仓库，因为远程仓库名发生变化，仓库地址也就发生了变化。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v // 可以先查看与远程仓库的关联</span><br><span class="line">git remote remove origin // 然后删除与远程仓库的关联</span><br><span class="line">git remote add origin git@github.com:xxx/XXX.git // 将本地仓库关联到远程仓库</span><br></pre></td></tr></table></figure><h2 id="8-设置不同的fetch和push源"><a href="#8-设置不同的fetch和push源" class="headerlink" title="8 设置不同的fetch和push源"></a>8 设置不同的fetch和push源</h2><p>我希望拉取公共的大项目代码，然后自己进行修改，上传到我的个人仓库中。所以fetch源需要是非个人源，push源为个人仓库的源。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote set-url origin  git://g.csail.mit.edu/xv6-labs-2021</span><br><span class="line">git remote set-url --add --push origin git@github.com:anda522/XV6-LAB.git</span><br></pre></td></tr></table></figure><p>再用 <code>git remote -v</code> 命令可以查看已经修改完成。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">origin git://g.csail.mit.edu/xv6-labs-2021 (push)</span><br><span class="line">origin git@github.com:anda522/XV6-LAB.git (fetch)</span><br></pre></td></tr></table></figure><p>然后就可以用下面代码进行操作了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 如何设置git代理：<a href="https://ericclose.github.io/git-proxy-config.html">https://ericclose.github.io/git-proxy-config.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZZU2020物联期末回顾</title>
      <link href="/p/454636061.html"/>
      <url>/p/454636061.html</url>
      
        <content type="html"><![CDATA[<p>本文知识点均为从网络或其他地方搜集整理而来，提到的习题均无答案，完全不具备权威性质，作者不对看本文造成的后果负责，请合理参考。</p><blockquote><p>本人为ZZU2020级网安学院物联考生，以下是我对实际考试的考后记录，仅供复习参考。</p><p>2023-12-30 Update：对复习资料进行了简要整理</p></blockquote><h1 id="2021-大二上期末回顾"><a href="#2021-大二上期末回顾" class="headerlink" title="2021 大二上期末回顾"></a>2021 大二上期末回顾</h1><h2 id="1-Linux"><a href="#1-Linux" class="headerlink" title="1 Linux"></a>1 Linux</h2><p>指令基本都是基本指令，输入输出流，统计行数，复制，文件权限修改等等</p><p>大题会考swap分区构建的具体步骤</p><p>考软硬链接文件复制文件和源文件的区别</p><p>脚本题是对两个文件判存在不存在，不存在询问建文件不建，只有当两个文件时都存在合并并排序</p><h2 id="2-计算机组成原理"><a href="#2-计算机组成原理" class="headerlink" title="2 计算机组成原理"></a>2 计算机组成原理</h2><p>大题考的主要是课后习题和课本例题</p><p>选择填空：</p><p>微指令内容感觉有点多，占了两三道选择<br>填空：带宽计算，速度计算</p><p>计算：</p><ul><li><p>补码加减法以及判溢出</p></li><li><p>时钟周期机器周期计算带宽</p></li><li><p>命中率，效率，平均访存时间</p></li><li><p>计算cache映射主存地址位数计算，四路组相连计算</p></li><li><p>一地址指令格式设计，操作方式种类数给了，寻址特征几种有了，设计地址，计算直接寻址范围和间接寻址范围</p></li></ul><p>综合：</p><ul><li>屏蔽字设计，画多级中断图</li><li>CPU和存储器连接画图</li></ul><h2 id="3-毛概"><a href="#3-毛概" class="headerlink" title="3 毛概"></a>3 毛概</h2><h3 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h3><ul><li>为什么说中国共产党领导的整个中国革命运动，包括新民主主义革命和社会主义革命两个阶段？</li><li>谈谈你对毛泽东思想活的灵魂的理解？</li></ul><h3 id="材料分析题"><a href="#材料分析题" class="headerlink" title="材料分析题"></a>材料分析题</h3><ul><li>对建党精神的理解</li><li>新民主主义革命和社会主义革命时期党是如何建设发展的</li></ul><h2 id="4-近代史"><a href="#4-近代史" class="headerlink" title="4 近代史"></a>4 近代史</h2><p>材料题：</p><ul><li>问法：材料提到的事件是什么：辛亥革命，本事件的性质是什么</li><li>该事件的意义</li><li>失败原因及教训</li><li>为什么中国共产党是孙中山革命事业的继承者</li></ul><p>论述题：</p><ul><li>1.为什么中国共产党应运而生</li><li>2.以毛泽东为代表的中国共产党如何探索开辟中国革命道路</li><li>3.建党百年的取得成就</li></ul><h2 id="5-数据结构"><a href="#5-数据结构" class="headerlink" title="5 数据结构"></a>5 数据结构</h2><p>填空：有一个联通分量计算</p><p>填空选择涉及了二叉树节点个数性质，一些基础知识涉及的比较多，涉及了一个地址计算（二维数组相关）</p><p>其他的已经忘记了。</p><h3 id="综合题1"><a href="#综合题1" class="headerlink" title="综合题1"></a>综合题1</h3><p>第一个给了一个程序（如下），进行复杂度分析</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x &lt; n / <span class="number">2</span>) &#123;</span><br><span class="line">x *= <span class="number">2</span>;</span><br><span class="line">count ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求count的值（用n表示），求时间复杂度和空间复杂度</p><h3 id="综合题2"><a href="#综合题2" class="headerlink" title="综合题2"></a>综合题2</h3><p>给出一个队列的描述，让你画描述队列的图，指出队首队尾，队列如何判满和判空</p><p>一个队列，给了在其中的元素个数及内容和头指针的位置，让画出队列图，又进行出队和入队操作，再让画一次队列图（哪个位置存的什么元素）</p><h3 id="综合题3"><a href="#综合题3" class="headerlink" title="综合题3"></a>综合题3</h3><p>第三个给了一个图，画出临接矩阵，然后是dfs序列，最小生成树</p><h3 id="综合题4"><a href="#综合题4" class="headerlink" title="综合题4"></a>综合题4</h3><p>一个序列，建立哈夫曼树，求WPL和叶子节点编码</p><h3 id="综合题5"><a href="#综合题5" class="headerlink" title="综合题5"></a>综合题5</h3><p>哈希查找画哈希表，求asl</p><h3 id="综合题6"><a href="#综合题6" class="headerlink" title="综合题6"></a>综合题6</h3><p>一个序列，快排第一趟之后是啥，堆排初始化建立的大根堆是啥</p><h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><p>编程是第一问编写初始化带头节点的单链表，第二问编写在单链表查找 <code>x</code> 的程序</p><h2 id="6-数电"><a href="#6-数电" class="headerlink" title="6 数电"></a>6 数电</h2><h3 id="选择填空"><a href="#选择填空" class="headerlink" title="选择填空"></a>选择填空</h3><p>选择触发器涉及的不多，都是些逻辑表达式分析之类的，最小项分析，触发器涉及的都是基础知识，什么存在约束项，什么可以避免空翻，什么抗干扰不抗之类的</p><h3 id="综合计算"><a href="#综合计算" class="headerlink" title="综合计算"></a>综合计算</h3><p>计算题：</p><ul><li><p>补码加减法</p></li><li><p>写TTL电路逻辑表达式</p></li><li><p>写cmos电路逻辑表达式</p><p>上面写表达式的课本出现过原题，请复习课后题</p></li><li><p>用卡诺图化简最简式子</p></li><li><p>用74l138实现某个逻辑表达式</p></li><li><p>画主从rs触发器波形图</p></li></ul><p>综合题：</p><ul><li><p>数码管设计，真值表</p></li><li><p>8421bcd码，实现相关功能，画真值表，设计电路</p></li></ul><blockquote><p>另外给出 <a href="https://wwm.lanzouv.com/iJoc40h3kqfc">2020年数电试卷</a> <a href="https://wwm.lanzouv.com/iJoc40h3kqfc">https://wwm.lanzouv.com/iJoc40h3kqfc</a> 请认真对待进行复习，仅供参考。</p></blockquote><h1 id="大二下"><a href="#大二下" class="headerlink" title="大二下"></a>大二下</h1><p>因为疫情，线上考试，没有记录，题型和线下也大不一样</p><h1 id="2022-2023大三上"><a href="#2022-2023大三上" class="headerlink" title="2022-2023大三上"></a>2022-2023大三上</h1><h2 id="1-人工智能"><a href="#1-人工智能" class="headerlink" title="1 人工智能"></a>1 人工智能</h2><p>我总结了知识点（复习笔记），请跳转查看：<a href="https://blog.csdn.net/qq_50285142/article/details/129283243">https://blog.csdn.net/qq_50285142/article/details/129283243</a></p><blockquote><p>注意：其中标 :star: 的都是重点，选择填空大题都可能考到，具体靠的类型可能是什么，自己把握。</p></blockquote><p>大题考的内容有：</p><ul><li>人工智能研究方法，及其与三学派关系</li><li>人工智能，机器学习，深度学习的关系</li><li>A*算法，启发式搜索</li><li>状态空间表示法概念</li><li>确定性推理和不确定推理的关系</li></ul><p>下面是两道计算题：</p><ul><li>可信度计算</li><li>决策树计算</li></ul><hr><p>当时询问得知的 <strong>2022年信安期末大题</strong> （那时是线上考试）：</p><ul><li>遗传算法概念和主要流程<ul><li>是一种模仿生物遗传学和自然选择机理的优化搜索算法，是进化计算的一种重要的形式。有选择算子，交叉算子，变异算子。</li><li>流程<ul><li>初始化群体，群体中的每一个个体都是染色体，由二进制串组成，所以算法中会牵扯到编码和解码操作</li><li>计算所有个体的适应度（适应度函数由用户自定义，保证适应度大的个体质量更好）</li><li>选择：选择方法一般有赌轮选择和联赛选择。赌轮选择：每个个体有一个选择的概率，可以定为个体的适应度除以群体总的适应度，产生随机数选择一个个体。联赛选择：随机选择m个个体，选择适应度最大的个体。选择之后要进行解码操作。</li><li>以某一概率进行交叉。（交叉分为一点交叉和两点交叉）</li><li>以某一概率进行突变</li><li>直至满足某种停止条件，否则一直进行适应度计算往下的操作</li><li>输出适应度最优的染色体作为最优解</li></ul></li></ul></li><li>知识表示的几种方法，并解释主要概念<ul><li>状态空间表示法</li><li>问题归约表示法</li><li>谓词逻辑表示法</li><li>语义网络表示法</li><li>框架表示</li><li>过程表示</li></ul></li><li>人工智能的应用</li><li>解释<ul><li>人工神经网络三要素</li><li>神经元</li><li>网络拓扑结构</li><li>学习算法</li></ul></li><li>启发式搜索的解释，A*算法的解释，相关步骤</li><li>决策树的计算，通过信息熵和信息增益计算最终打不打网球</li><li>梵塔问题四圆盘状态表示图画法</li><li>不确定性推理的计算</li></ul><blockquote><p>对应文件可查看：<a href="https://github.com/anda522/CourseReview/tree/main/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E8%94%A1%E8%87%AA%E5%85%B4">2022年信安人工智能期末重点和期末大题</a>  </p></blockquote><h2 id="2-传感器"><a href="#2-传感器" class="headerlink" title="2 传感器"></a>2 传感器</h2><p>主要是课后题，记得并没有考特别麻烦的式子。</p><blockquote><p>附上 <a href="https://wwwi.lanzouy.com/i7X8r1jeti2j">传感器课后题汇总</a> 密码:9jon</p></blockquote><h2 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3 数据库"></a>3 数据库</h2><blockquote><p>附上我当时做的数据库xmind思维导图：<a href="https://wwwi.lanzouy.com/iPM3F1jett9c%EF%BC%8C%E5%AF%86%E7%A0%81:cxb6">https://wwwi.lanzouy.com/iPM3F1jett9c，密码:cxb6</a></p><p>思维导图PDF文件格式：<a href="https://wwwi.lanzouy.com/i5kuN1jeu62d">数据库复习思维导图</a></p></blockquote><h1 id="2023大三下"><a href="#2023大三下" class="headerlink" title="2023大三下"></a>2023大三下</h1><h2 id="1-RFID"><a href="#1-RFID" class="headerlink" title="1 RFID"></a>1 RFID</h2><p>两个大题：</p><ul><li>画不同编码方式的编码图</li><li>EPC系统的介绍（解释）</li></ul><p>看的是给出的雨课堂习题</p><blockquote><p>在此附上汇总的雨课堂和课后题 <a href="https://wwwi.lanzouy.com/icgAu1jesakd">RFID雨课堂和课后习题汇总</a></p></blockquote><h2 id="2-无线通信"><a href="#2-无线通信" class="headerlink" title="2 无线通信"></a>2 无线通信</h2><p>主要看PPT，以及PPT上面的习题</p><blockquote><p>另外附上我的复习笔记，非常全面： <a href="https://wwwi.lanzouy.com/iCmZw1jeszle">无线通信复习笔记</a> </p></blockquote><h2 id="3-软件工程"><a href="#3-软件工程" class="headerlink" title="3 软件工程"></a>3 软件工程</h2><ul><li>软件工程不太好说，内容太多，基本都是要记的内容</li><li>记得大题考了一个需求分析的特点</li></ul><blockquote><p>麻了，软件工程 <a href="https://blog.csdn.net/weixin_46232841/article/details/111387192">https://blog.csdn.net/weixin_46232841/article/details/111387192</a> 这文里出现很多选择原题，我写错好几个，考后有人发链接。</p><p>另外附上我整理的复习笔记：<a href="https://wwwi.lanzouy.com/i8k9H1jerhqf">软件工程复习笔记</a></p></blockquote><h2 id="4-物联网安全"><a href="#4-物联网安全" class="headerlink" title="4 物联网安全"></a>4 物联网安全</h2><p>物联网安全复习的内容太多了</p><p>简答题考了：</p><ul><li>简述物联网秘钥管理</li><li>数字签名和消息认证的区别</li><li>无线个域网和无线局域网的区别</li><li>简述使用数字证书认证的过程（存在CA认证中心）</li><li>简述AES算法的过程</li><li>物联网安全和互联网安全的关系</li></ul><h2 id="5-数据挖掘"><a href="#5-数据挖掘" class="headerlink" title="5 数据挖掘"></a>5 数据挖掘</h2><p>选择：</p><p>有个皮尔逊相关系数，选择那个数是最不相关的，应该选0</p><p>简答：</p><ul><li>简述数据仓库与数据挖掘的关系</li><li>说明数据清理的任务</li><li>什么是粒度，数据仓库数据组织的四种形式</li><li>给两个对象数据，计算曼哈顿距离和切比雪夫距离</li><li>什么是聚类，和分类有何不同，列举常见聚类算法</li><li>说出DBSCAN的优缺点</li></ul><p>综合：</p><ul><li>根据事务表构建FP树</li><li>根据几个二维点，用K-means算法进行聚类</li><li>【开放类型题】有一个系统，从数据预处理，模型选择，模型训练，评估等步骤说明如何构建一个预测系统（题目有对该系统的相关介绍）</li></ul><blockquote><p>另外附上我当时整理的考试笔记：<a href="https://wwwi.lanzoup.com/ixr6V0znp1di">数据挖掘复习笔记</a> </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 课程记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年度总结</title>
      <link href="/p/3756014507.html"/>
      <url>/p/3756014507.html</url>
      
        <content type="html"><![CDATA[<h1 id="2021年度总结"><a href="#2021年度总结" class="headerlink" title="2021年度总结"></a>2021年度总结</h1><p>许多应用都有他们自己的年度总结，那我是不是也要搞一份总结。</p><p>今年真的是有很多不顺，也有很多收获。</p><p>今年从考试周开始，到考试周结束。</p><p>接下来回顾一下我普普通通的2021年，只希望之后看回来能够吸取之前的相关教训和经验。</p><blockquote><p>很像流水账，但是我喜欢这样的时间记录，之后回看会很容易看到自己所走的历程。</p></blockquote><h2 id="大一上"><a href="#大一上" class="headerlink" title="大一上"></a>大一上</h2><ul><li>2021年的开始是大一上学期的考试周，当时几乎什么都不懂，很多都不会。性格内敛，心理上懵懵懂懂。之前比较幸运擦边进了acm实验室，也比较幸运地进了一个北三的团队。（之后发现在这里能够收获很多东西）</li><li>记得考试周晚上在看《西部世界》，离谱了，考试周有幸度过。</li><li>寒假开始了艰难的acm学习。一个寒假跟着校acm实验室就学了一点，之后发现太难都不会就自己学去了。记得刚开始dfs就给我整吐了，一个寒假，绝望了多少次，啥都不会，看啥看不懂，还得硬看别人的代码，不然还是啥都不会。我真是一个菜鸡（垃圾）。</li><li>寒假应该是中后期我开始了在CSDN的创作，当时是写C++STL总结，那时几乎没有代码水平的，现在想想，要是没有这篇总结，我都不会写博客了。</li><li>大一的寒假延长了，我是没想到的，没想到大学的寒假竟然有两个多月之多，离大谱了。3月13号差不多才返校。</li></ul><h2 id="大一下"><a href="#大一下" class="headerlink" title="大一下"></a>大一下</h2><ul><li><p>也许是上学期考试考的自我感觉良好了，下学期明显有点飘，干啥啥不中。</p></li><li><p>开学我就继续进行了acm的训练，当然以我当时非常菜的水平，刷题是几乎不会有很大的提高的，刷的几乎都是水题，也没有很大的效率。</p></li><li><p>3月底，参加天梯选拔赛，结果只能说是很不行，wa穿了，肯定是很菜的，自己算什么东西，当然是没有选上了，记得排名很靠后。</p></li><li><p>四月初志愿者监考acm招新赛，看着一大批大佬乱杀，真的很厉害。源佬和熊佬杀的真的很猛，自愧不如。</p></li><li><p>之后几天参加蓝桥杯，不出所料，只能用两个字形容，“垃圾”，会的几乎没有，铁是必然的。</p></li><li><p>期间经历了很多次无助，自己看什么都看不懂，学什么都学不会。看着nb的人，他们真的难以被超越，完虐。acm什么都没教会我，倒是教会我了如何完美地被虐。</p></li><li><p>五月初有幸傍上一个大佬，过了ICPC省赛选拔赛，大概接近五月底参加了ICPC省赛。这次比赛或许是我唯一一次线下的比赛，去农大免费游玩了两天，吃着免费的饭，这转转，那转转，还是很爽的。但是到做题的时候，就很难受了，几乎什么都不会，还是一个垃圾。不过有幸在大佬的带领下拿了银，记得当时因为时间冲突还鸽了学校的一个循迹小车比赛（这个比赛的小车还是一百块钱买的，呜呜呜）。</p></li><li><p>接近期末参加了社团的换届竞选，选上计算机学术交流协会的会长我是没想到的。</p></li><li><p>接下来就是我的期末了，考的比较差，概率论有大题原题也一点没有写出来，而且自己还做过，现在想来真的是非常伤啊，期末多科都考的不行，应该是自己没有认真复习，考前还在看美剧吧。</p></li><li><p>考试后的小学期实习还碰上了有史以来的720大暴雨，当时我断水断电我记得还出去转了一圈呢，水是直接漫到大腿处，断水断电断网了几天，终于是挺过去了。</p></li><li><p>暑假在家刷了很多题，进度缓慢的进行，前前后后刷了两三百道吧（当时暑假又延期了，延期了大概一个月10月10号左右才上学），题数上去了，但是感觉实力没有多大的提高。呜呜呜，好菜啊。</p></li><li><p>接近8月底我带队参加物联网设计大赛（华为杯），又是因为疫情，比赛线上，本来能去西安线下比赛的，呜呜呜。可能因为线上才让我们获得了不错的成绩吧，西北赛区一等奖，可以晋级总决赛了。8月底，我们又线上参加了总决赛（本来线下是要在湖南大学比的），最后我想只要拿个奖都不错了。当时念获奖队伍的时候想一直不念我们的队，难道是寄了吗。最后真的出乎意料，得了一等奖。我的第一个国一。</p></li><li><p>高考出分之后几乎都开始干社团宣传的活了，当个会长确实挺累的。</p></li></ul><h2 id="大二上"><a href="#大二上" class="headerlink" title="大二上"></a>大二上</h2><ul><li>这学期真的是忙，开学开的晚，社团会长还得干活。办新生赛，扫楼，迎新，开见面会，交各种材料，答辩等等……</li><li>10月底和队友打了省CCPC，在队友的努力带领下，最后拿了银，还是很菜。</li><li>11月初在老社长的怂恿下，租了个三年的服务器，现在想来真的有用。上Linux课直接拿平板远程操控了，在服务器上搭网站，各种玩。</li><li>11月21，ICPC沈阳站，这一天是绝望的一天。事实证明自己就是一菜比，五百多队，四百多名，题目狠磕，但是还是做不出来。铁又来了。比较难受，但确实证明了自己真的是非常的菜。</li><li>快11月底国励到账，爽了。</li><li>11月底学了不到一天，在服务器上成功运行了QQ机器人，现在功能慢慢变得已经比较完善了。</li><li>12月底还是考试周，临时通知考试周提前，本来就来得晚，现在考的变早了两三个星期，课程很赶，啥都学不会，考试复习根本没时间，结课后下一天就考试。不过考试还是结束了，希望结果是是好的吧。</li></ul><p>2021过的有很多不顺利，出现了很多苦难和挫折，有些解决了，有些短时间无法解决或者无法解决（比如说菜这个事情），但是还是出现了一点成就的。今年许多不顺，希望之后遇到能够尽量解决吧。希望之后越来越好！</p>]]></content>
      
      
      <categories>
          
          <category> 哲思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阶段性总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1181C Flag-子矩阵数量统计</title>
      <link href="/p/2396599521.html"/>
      <url>/p/2396599521.html</url>
      
        <content type="html"><![CDATA[<h1 id="CF1181C-Flag子矩阵数量统计"><a href="#CF1181C-Flag子矩阵数量统计" class="headerlink" title="CF1181C Flag子矩阵数量统计"></a>CF1181C Flag子矩阵数量统计</h1><h2 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h2><p>题目链接：</p><p><a href="https://codeforces.com/problemset/problem/1181/C">https://codeforces.com/problemset/problem/1181/C</a></p><blockquote><p>大意：有个人想要卖国旗。</p><p>一面国旗可以抽象为一个 $n \times m$ 的矩形，每一个位置有一个颜色。这个矩形由自上而下三条横向的颜色带组成，每一条颜色带宽度相等，而且相邻两个颜色带颜色不能相同。</p><p>现在你有一个 $n \times m$ 的矩形，你需要计算其中能够称为国旗的子矩形数量</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="维护变量"><a href="#维护变量" class="headerlink" title="维护变量"></a>维护变量</h3><p>统计子矩阵一般都需要维护一些数组，大部分都是纵向维护或者横向维护。</p><p>本题维护两个数组：</p><p>$d[i][j]$ : $(i, j)$位置向下最多延伸相同颜色的块数</p><p>$r[i][j]$：$(i, j)$位置向右最多延伸相同颜色的块数</p><p>我们先考虑宽度为$1$的情况，统计该列的贡献时再考虑该列横向向右能达到的最大贡献。</p><p>同时需要再维护两个横向延伸的最小值数组：</p><p>$r[i][j]$ ：<strong>前缀</strong>（横向数组）最小值，$(x, j)$到$(i, j),x &lt; i$横向向右的延伸长度的最小值，保证$(x, j)$到$(i, j)$的颜色相同，只有在颜色相同时才会更新最小值</p><blockquote><p>$r[i][j]$和声明的一样，但是此$r[i][j]$是利用上述数组更新来的（具体见代码）</p></blockquote><p>$lmn[i][j]$ : <strong>后缀</strong>（横向数组）最小值，$(x, j)$到$(i, j), x &gt; i$横向向右的延伸长度的最小值，保证$(x, j)$到$(i, j)$的颜色相同，只有在颜色相同时才会更新最小值</p><hr><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>先考虑宽度为1时，在纵向方向上能否构成国旗</p><p>即下面的条件（满足的旗子共三行，如题要求）</p><ul><li><p>$i + 3 \times d[i][j] - 1 &lt;&#x3D; n$  第三行的旗子不越界</p></li><li><p>$d[i][j] &#x3D;&#x3D; d[i + d[i][j]][j]$ 第二行和第一行的长度相同</p></li><li><p>$d[i + 2 \times d[i][j]][j] &gt;&#x3D; d[i][j]$ 第三行的长度<strong>大于等于</strong>上面的行长度（大于等于请思考为什么，只要大于等于就能统计上）</p></li></ul><p>纵向能够形成旗子，那么考虑改纵向旗子的贡献。</p><blockquote><p>求贡献：</p><p>因为每一个满足条件的纵向旗子都会求贡献，所以每个纵向旗子求贡献只用向右求就行。</p><p>以下为举例：</p><p>AAA</p><p>BBB</p><p>CCC</p><p>最左边一列，可形成3种情况</p><p>中间一列，可形成2种情况</p><p>最右边一列，可形成1种情况</p><p>包含了所有的情况，总贡献就是 3 + 2 + 1</p><p>其实就是$n(n + 1) &#x2F; 2$，亦或是递推式$f[i] &#x3D; f[i - 1] + i$，思想基本一样</p></blockquote><p>那么就要求贡献了</p><p>我们肯定需要找<strong>最小</strong>的向右扩展的长度才能算当前整体的贡献，最小向右扩展长度需要是<strong>上中下</strong>三部分的最小值。</p><p>故需要用到上述最小值（前缀和后缀）数组。</p><blockquote><p> 为什么要用到后缀数组?</p><p>以下为举例：满足情况的列用粗体标明</p><p>A （无关紧要行）</p><p><strong>A</strong></p><p><strong>A</strong></p><p><strong>B</strong></p><p><strong>B</strong></p><p><strong>C</strong></p><p><strong>C</strong></p><p>C（无关紧要行）</p><p>但是上下各多出一个字母，如果统计最小值时，上面部分用到前缀最小值数组，就会把第一行向右扩展的长度统计上去，造成统计错误。下面部分同理。</p><p>故上面部分需要用到后缀数组，下面部分需要用到前缀数组，中间部分无所谓</p></blockquote><p>则当前列能够造成的贡献为 $min(lmn[i][j], r[i + 2 \times d[i][j] - 1][j], r[i + 3 \times d[i][j] - 1][j])$</p><p>具体整体实现见代码。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N][N], r[N][N], lmn[N][N];</span><br><span class="line"><span class="type">char</span> s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">cin &gt;&gt; (s[i] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n; i; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = m; j; j--)</span><br><span class="line">&#123;</span><br><span class="line">d[i][j] = d[i + <span class="number">1</span>][j], r[i][j] = r[i][j + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s[i][j] == s[i + <span class="number">1</span>][j])</span><br><span class="line">d[i][j] ++;</span><br><span class="line"><span class="keyword">else</span> d[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s[i][j] == s[i][j + <span class="number">1</span>])</span><br><span class="line">r[i][j] ++;</span><br><span class="line"><span class="keyword">else</span> r[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n; i; i--)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line">lmn[i][j] = r[i][j];</span><br><span class="line"><span class="keyword">if</span>(i &lt; n &amp;&amp; s[i + <span class="number">1</span>][j] == s[i][j])</span><br><span class="line">lmn[i][j] = <span class="built_in">min</span>(lmn[i][j], lmn[i + <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i][j] == s[i - <span class="number">1</span>][j])</span><br><span class="line">r[i][j] = <span class="built_in">min</span>(r[i][j], r[i - <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i + <span class="number">3</span> * d[i][j] - <span class="number">1</span> &lt;= n &amp;&amp; d[i][j] == d[i + d[i][j]][j] &amp;&amp; d[i + <span class="number">2</span> * d[i][j]][j] &gt;= d[i][j])</span><br><span class="line">ans += <span class="built_in">min</span>(&#123;lmn[i][j], r[i + <span class="number">2</span> * d[i][j] - <span class="number">1</span>][j], r[i + <span class="number">3</span> * d[i][j] - <span class="number">1</span>][j]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/medias/gzh.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CF </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阶乘逆元和线性逆元</title>
      <link href="/p/652576208.html"/>
      <url>/p/652576208.html</url>
      
        <content type="html"><![CDATA[<h1 id="逆元简介"><a href="#逆元简介" class="headerlink" title="逆元简介"></a>逆元简介</h1><p>$a \times b \equiv  1 ( mod,,p)$,可以称<code>a</code>是<code>b</code>在模<code>p</code>情况下的逆元.</p><p>逆元其实就是可以看作倒数</p><h1 id="阶乘逆元"><a href="#阶乘逆元" class="headerlink" title="阶乘逆元"></a>阶乘逆元</h1><p><strong>方式一:</strong></p><p>通过费马小定理求逆元：</p><p>当<code>p</code>为素数，并且<code>gcd(a,p)=1</code>时，我们有$a^{p−1}≡1(mod\ p)$。那么就有$a^{p−2}×a≡1(mod\ p)$，则<code>a</code>的逆元就是$a^{p−2}$</p><p>下面<code>ksm</code>函数为快速幂</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">inv[i] = <span class="built_in">ksm</span>(fact[i], mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>方式二：</strong></p><p>通过式子$\frac{1}{(n+1)!}\times (n+1)&#x3D;\frac{1}{n!}$倒推接近线性求阶乘逆元</p><p>$\frac{1}{(n+1)!}$其实就可以看作${(n+1)!}$的逆元</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">inv[n] = <span class="built_in">ksm</span>(fact[n], mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br></pre></td></tr></table></figure><hr><h1 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h1><p>求$[1,N-1]$关于<code>mod</code>的逆元时，可以做到在$O(N)$时间内解决</p><p>设模数为<code>p</code></p><p>对于当前的<code>i</code>，设$p&#x3D;k×i+r$，则</p><p>$\begin{aligned}<br>k \times i + r &amp; \equiv   0  &amp;,,(mod ,, p) \<br>k \times i \times ( i^{-1} \times r ^{-1}) + r \times (i^{-1} \times r^{-1}) &amp;\equiv 0 &amp;,,( mod ,, p) \<br>k \times r^{-1} + i ^ {-1} &amp; \equiv 0 &amp;,, (mod ,, p)\<br>i^{-1} &amp; \equiv -k \times r^{-1} &amp;,, (mod ,, p) \<br>i^{-1} &amp; \equiv - \left \lfloor \frac{p}{i}\right \rfloor \times r^{-1} &amp;,,(mod,,p)<br>\end{aligned}$</p><p>注意：</p><p>$inv[1]$一定要初始化为1，需要从2开始递推，不能从1开始递推</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">inv[i] = inv[mod % i] * (mod - mod / i) % mod;</span><br></pre></td></tr></table></figure><p>同时可以通过线性求逆元求<strong>阶乘逆元</strong>：</p><p>只需要再将逆元用类似阶乘的形式乘起来即可，求得的<code>inv[i]</code>即为$i!$的逆元</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">inv[i] = inv[i - <span class="number">1</span>] * inv[i] % mod;</span><br></pre></td></tr></table></figure><hr><h1 id="组合数计算"><a href="#组合数计算" class="headerlink" title="组合数计算"></a>组合数计算</h1><p>$C_n^m$计算</p><ul><li>方式一：公式计算<br>计算都是在逆元或者阶乘基础上计算的<br>$C_n^m &#x3D; \frac{n!}{m!*(n-m)!}$</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方式二：递推方式<br>需要建表,所以如果计算范围比较大时需要的空间也大<br>递推公式 ： $C_n^m &#x3D; C_{n-1}^{m} + C_{n-1}^{m-1}$</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == j || j == <span class="number">0</span>) c[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + c[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/23481/J">https://ac.nowcoder.com/acm/contest/23481/J</a></p><p>题目描述：求<br>$$<br>\sum \limits_{i_1 &#x3D; 1}^n \sum \limits_{i_2 &#x3D; i_1 + 1}^n \cdots \sum \limits_{i_k &#x3D; i_{k - 1} + 1}^n a_{i_1} \times a_{i_2} \times \cdots \times a_{i_k}<br>$$</p><blockquote><p>就是在数组中选中k个值相乘，最后把结果相加即可</p></blockquote><hr><p>因为数组中的数大小只有三种情况。所以可以根据这个进行切入口。</p><p>首先$0$可以不用考虑，接下考虑有$n$个$1$和$m$个$2$，如果上述和式中$1$出现了$i$个，那么$2$需要出现$k-i$个，于是答案为</p><p>$$<br>\sum \limits_{i&#x3D;0}^k C_n^i C_m^{k-i}2^{k-i}<br>$$</p><hr><p>代码中注意各种初始化<br>线性求逆元中初始化：<code>inv[1] = 1</code></p><p><code>fac[i]</code>:$2^i$</p><p><code>fact[i]</code>:$i!$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">5</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll fac[N], fact[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fact[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">fac[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">fac[<span class="number">0</span>] = fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">fac[i] = fac[i - <span class="number">1</span>] * <span class="number">2</span> % mod;</span><br><span class="line">fact[i] = fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">inv[i] = inv[mod % i] * (mod - mod / i) % mod; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">inv[i] = inv[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="type">int</span> o = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">if</span>(a[i] == <span class="number">1</span>) o ++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i] == <span class="number">2</span>) t ++;</span><br><span class="line">&#125;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">&#123;</span><br><span class="line">res += <span class="built_in">C</span>(o, i) * <span class="built_in">C</span>(t, k - i) % mod * fac[k - i] % mod;</span><br><span class="line">res %= mod;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="comment">//cin &gt;&gt; t;</span></span><br><span class="line">t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(t--) <span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 逆元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容斥定理</title>
      <link href="/p/1292892888.html"/>
      <url>/p/1292892888.html</url>
      
        <content type="html"><![CDATA[<p>﻿﻿# 容斥定理</p><h2 id="基本描述"><a href="#基本描述" class="headerlink" title="基本描述"></a>基本描述</h2><p><img src="https://oi-wiki.org/math/combinatorics/images/incexcp.png" alt="简单版本"></p><p>对于上述图片，求$|A\cup B \cup C|$</p><p>结果为$|A\cup B\cup C|&#x3D;|A|+|B|+|C|-|A\cap B|-|B\cap C|-|C\cap A|+|A\cap B\cap C|$</p><h2 id="一般描述"><a href="#一般描述" class="headerlink" title="一般描述"></a>一般描述</h2><p>公式：$\left|\bigcup_{i&#x3D;1}^{n}S_i\right|&#x3D;\sum_{m&#x3D;1}^n(-1)^{m-1}\sum_{a_i&lt;a_{i+1} }\left|\bigcap_{i&#x3D;1}^mS_{a_i}\right|$</p><p>大家应该是看不懂吧，反正我是看不懂</p><p>我理解的通俗的意思就是：</p><p><code>n</code>个集合的并集<strong>等于</strong><code>n</code>个集合选择一个的情况中所有情况的交-<code>n</code>个集合中选择两个所有情况中两两的交+<code>n</code>个集合中选择三个中所有情况三个的交-选择四种的交+选择五种的交-……</p><p>稍微用公式表示一下：<br>$|A_1\cup…\cup A_n| &#x3D; \<br>|A_1|+|A_2|+…+|A_n|\<br>-(|A_1 \cap A_2|+…+|A_i \cap A_j|)\<br>+(|A_1 \cap A_2 \cap A_3|+…+|A_i \cap A_j \cap A_k|)\<br>-(四个之间的交)\<br>+(五个之间的交)\<br>……$</p><p>大概就是这个意思。</p><ul><li>选择的个数为偶数次，前面符号为负</li><li>选择的个数为奇数次，前面符号为正</li></ul><p>参考链接：<br><a href="https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/">https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/</a></p><h2 id="例题1-能被整除的数"><a href="#例题1-能被整除的数" class="headerlink" title="例题1 能被整除的数"></a>例题1 能被整除的数</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/892/">https://www.acwing.com/problem/content/892/</a></p><blockquote><p>给定一个整数 <code>n</code>和 <code>m</code> 个不同的质数 $p_1,p_2,…,p_m$。<br>请你求出 1∼n 中能被 $p_1,p_2,…,p_m$中的至少一个数整除的整数有多少个。</p></blockquote><hr><p><strong>思路：</strong></p><blockquote><p>先简单的举个例子：<br>质数有2，3，5，7，11五个<br>能被2整除的有2，4，6，8 ….<br>能被3整除的有3，6，9，12….<br>…<br>问的是被至少一个整除就行，那么上述例子中6是重复的<br>也就是我们可以把能被<strong>一个质数整除的个数</strong>当作<strong>一个集合</strong>，这么多质数组成的集合有重合的，我们要求的是这么多集合的并集，满足容斥定理</p></blockquote><p>在<code>1-n</code>中能被<code>x</code>整除的个数：$\lfloor \frac{n}{x}\rfloor$<br>在<code>1-n</code>中能被<code>x,y</code>整除的个数：$\lfloor \frac{n}{xy}\rfloor$<br>在<code>1-n</code>中能被<code>x,y,z</code>整除的个数：$\lfloor \frac{n}{xyz}\rfloor$<br>……<br>然后就可以根据公式求结果，有<code>m</code>个质数，共有<code>m</code>个集合，每次会选中若干个集合，代表几个之间的交集（参照上面容斥定理公式）</p><blockquote><p>几个集合之间的交集：就是一个数能<strong>同时</strong>被这选中的几个质数整除</p></blockquote><p>选中集合个数为偶数，前面符号为<strong>负</strong><br>选中集合个数为奇数，前面符号为<strong>正</strong></p><blockquote><p>枚举所有的集合：<br>我们采用二进制的方法，枚举$[1,2^{m}-1]$,统计其中<code>1</code>的个数即可</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) cin&gt;&gt;p[i];</span><br><span class="line"></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt; <span class="number">1</span>&lt;&lt;m ;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">ll t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( i&gt;&gt;j &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cnt ++ ;<span class="comment">//统计选中的个数</span></span><br><span class="line"><span class="keyword">if</span>(t * p[j] &gt; n)<span class="comment">//不满足条件，因为大于n了</span></span><br><span class="line">&#123;</span><br><span class="line">t = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">t *= p[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt%<span class="number">2</span>) res += n/t;</span><br><span class="line"><span class="keyword">else</span> res -= n/t; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/216/">https://www.acwing.com/problem/content/216/</a></p><blockquote><p>Devu 有 <code>N</code> 个盒子，第 <code>i</code> 个盒子中有 $A_i$ 枝花。同一个盒子内的花颜色相同，不同盒子内的花颜色不同。Devu 要从这些盒子中选出 <code>m</code> 枝花组成一束，求共有多少种方案。若两束花每种颜色的花的数量都相同，则认为这两束花是相同的方案。结果需对 $10^9+7$ 取模之后方可输出</p></blockquote><hr><p><strong>思路</strong></p><ul><li>理想情况</li></ul><p>首先去掉限制考虑理想情况，即每个盒子的花的个数有无限个，设第$i$个盒子取出$x_i$朵花</p><p>则$x_1+x_2+x_3+…+x_n&#x3D;  m,x_i \geq 0$,总方案数为$C_{n+m-1}^{n-1}$种</p><p>可以参考链接查看如何计算 :<br><a href="https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/">https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/</a></p><hr><ul><li>有限制的情况</li></ul><p>限制条件下：<br>$x_1+x_2+x_3+…+x_n&#x3D;  m,x_1&lt;&#x3D;A_1,x_2&lt;&#x3D;A_2,x_3&lt;&#x3D;A_3……x_n&lt;&#x3D;A_n$</p><p>$x_1,x_2,…,x_n$同时满足限制条件才可，我们考虑从补集去求（总情况数减去相反的情况）</p><p>补集情况下：</p><p>$x_1+x_2+x_3+…+x_n&#x3D;  m,x_1&gt;A_1,x_2&gt;A_2,x_3&gt;A_3……x_n&gt;A_n$<br>第<code>i</code>个限制（$x_i&gt;A_i$）的情况满足个数我们当作一个集合$s_i$</p><ul><li>总数：$C_{n+m-1}^{n-1}$</li><li>题目的补集：$|s_1\bigcup s_2\bigcup s_3……\bigcup s_n|$</li><li>结果为：$C_{m+n-1}^{n-1}-|s_1\bigcup s_2\bigcup s_3……\bigcup s_n|$</li></ul><p>考虑求满足$s_1$的情况数<br>即第一个必须取至少$A_i+1$支花，那么接下来就化为从<code>n</code>组里面选花，$x_1&gt;&#x3D;A_1+1,x_2&gt;&#x3D;0,x_3&gt;&#x3D;0,…,x_n&gt;&#x3D;0$的情况，可以直接取出$A_i+1$支花放在第一组，那么总数就变成$m-(A_1+1)$支花，就化为<strong>理想情况</strong>(见上文)下的问题了，总数为$C_{m+n-1-(A_1+1)}^{n-1}$</p><p>$s_1\cap s_2$同理<br>答案为$C_{m+n-1-(A_1+1)-(A_2+1)}^{n-1}$</p><p>最后枚举所有的情况数，使用二进制方法进行枚举，枚举$[0,2^n-1]$,统计二进制位<code>1</code>的个数</p><p>奇数个<code>1</code>符号为负<br>偶数个<code>1</code>符号位正</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>,mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll a[N];</span><br><span class="line">ll d = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fast</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res * a % mod;</span><br><span class="line">a = a * a % mod;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &lt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ll u = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i = x;i&gt;x-y;i--) u = i % mod * u % mod;</span><br><span class="line"><span class="keyword">return</span> u * d % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n,m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) d = d * i % mod;</span><br><span class="line">d = <span class="built_in">fast</span>(d,mod<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">ll res = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; <span class="number">1</span>&lt;&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//组合数的下角标   上角标</span></span><br><span class="line">ll down = n + m <span class="number">-1</span>,up = n<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> sign = <span class="number">1</span>;<span class="comment">//标记的符号位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">down -= a[j]+<span class="number">1</span>;<span class="comment">//下角标减去对应的个数</span></span><br><span class="line">sign *= <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res = (res + <span class="built_in">C</span>(down,up) * sign)%mod; <span class="comment">//计算组合数，统计答案</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(res + mod) % mod&lt;&lt;endl; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="例题3-ABC-297-F-Minimum-Bounding-Box-2"><a href="#例题3-ABC-297-F-Minimum-Bounding-Box-2" class="headerlink" title="例题3 ABC 297 F Minimum Bounding Box 2"></a>例题3 ABC 297 F Minimum Bounding Box 2</h2><p><a href="https://atcoder.jp/contests/abc297/tasks/abc297_f">AtCoder Beginner Contest 297 F Minimum Bounding Box 2</a></p><p><img src="https://img-blog.csdnimg.cn/5f1ff6e83b1140129786c6cbf187c9e3.png" alt="方法描述"></p><p>枚举矩形的长h和宽w，长h宽w的矩形的情况数总共有 $(H - h + 1) \times (W - w + 1)$ 个，每个矩形框对应的分数为 $h \times w$</p><p>容斥时，共有四个变量，对应4个二进制位， 对应上下左右四个方向是否收缩1个单位，收缩的总数为奇数时，符号为负，为偶数时，符号为正。</p><blockquote><p>注意容斥变量s是从0开始，0刚好对应总的情况数，所以不用额外计算总的情况数</p></blockquote><p>最后再除以总的情况数 $C_{h * w} ^ k$ 即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">ll res = <span class="number">1</span>;</span><br><span class="line">a %= mod;</span><br><span class="line"><span class="keyword">while</span>(b) &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">a = a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h, w, k;</span><br><span class="line">cin &gt;&gt; h &gt;&gt; w &gt;&gt; k;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">fac</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">inv</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line">inv[N] = <span class="built_in">ksm</span>(fac[N], mod - <span class="number">2</span>);</span><br><span class="line">inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> C = [&amp;](ll n, ll m) -&gt; ll &#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt; m || m &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; j++) &#123;</span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt; <span class="number">16</span>; s++) &#123;</span><br><span class="line"><span class="type">int</span> u = __builtin_popcount(s &amp; <span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> v = __builtin_popcount(s &amp; <span class="number">12</span>);</span><br><span class="line">res += ((u + v) &amp; <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>) * <span class="built_in">C</span>(<span class="built_in">max</span>(<span class="number">0</span>, i - u) * <span class="built_in">max</span>(<span class="number">0</span>, j - v), k) % mod;</span><br><span class="line">res %= mod;</span><br><span class="line">&#125;</span><br><span class="line">ans += res * (h - i + <span class="number">1</span>) % mod * (w - j + <span class="number">1</span>) % mod * i % mod * j % mod;</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans *= <span class="built_in">ksm</span>(<span class="built_in">C</span>(h * w, k), mod - <span class="number">2</span>);</span><br><span class="line">ans %= mod;</span><br><span class="line">cout &lt;&lt; (ans + mod) % mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL超全总结</title>
      <link href="/p/16970766.html"/>
      <url>/p/16970766.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-STL常用内容总结"><a href="#C-STL常用内容总结" class="headerlink" title="C++ STL常用内容总结"></a>C++ STL常用内容总结</h1><p>我是以打算法竞赛的角度整理的STL知识点，<strong>强调使用方法</strong>，并不强调原理。</p><p>下面会介绍很多C++ STL库里面的模板，在编程中STL犹如神器，实用简洁好用。<br>STL绝对让你受益无穷！</p><h2 id="👉1-vector动态数组👈"><a href="#👉1-vector动态数组👈" class="headerlink" title="👉1.vector动态数组👈"></a>👉<a href="https://blog.csdn.net/qq_50285142/article/details/122303529">1.vector动态数组</a>👈</h2><h2 id="👉2-stack栈👈"><a href="#👉2-stack栈👈" class="headerlink" title="👉2.stack栈👈"></a>👉<a href="https://blog.csdn.net/qq_50285142/article/details/122303786">2.stack栈</a>👈</h2><h2 id="👉3-queue队列👈"><a href="#👉3-queue队列👈" class="headerlink" title="👉3.queue队列👈"></a>👉<a href="https://blog.csdn.net/qq_50285142/article/details/122304056">3.queue队列</a>👈</h2><h2 id="👉4-deque双端队列👈"><a href="#👉4-deque双端队列👈" class="headerlink" title="👉4.deque双端队列👈"></a>👉<a href="https://blog.csdn.net/qq_50285142/article/details/114079022">4.deque双端队列</a>👈</h2><h2 id="👉5-priority-queue优先队列👈"><a href="#👉5-priority-queue优先队列👈" class="headerlink" title="👉5.priority_queue优先队列👈"></a>👉<a href="https://blog.csdn.net/qq_50285142/article/details/114078695">5.priority_queue优先队列</a>👈</h2><h2 id="👉6-map映射👈"><a href="#👉6-map映射👈" class="headerlink" title="👉6.map映射👈"></a>👉<a href="https://blog.csdn.net/qq_50285142/article/details/120368977">6.map映射</a>👈</h2><h2 id="👉7-set集合👈"><a href="#👉7-set集合👈" class="headerlink" title="👉7.set集合👈"></a>👉<a href="https://blog.csdn.net/qq_50285142/article/details/122304728">7.set集合</a>👈</h2><h2 id="👉8-pair二元组👈"><a href="#👉8-pair二元组👈" class="headerlink" title="👉8.pair二元组👈"></a>👉<a href="https://blog.csdn.net/qq_50285142/article/details/122304842">8.pair二元组</a>👈</h2><h2 id="👉9-string字符串👈"><a href="#👉9-string字符串👈" class="headerlink" title="👉9.string字符串👈"></a>👉<a href="https://blog.csdn.net/qq_50285142/article/details/114156051">9.string字符串</a>👈</h2><h2 id="👉10-bitset👈"><a href="#👉10-bitset👈" class="headerlink" title="👉10.bitset👈"></a>👉<a href="https://blog.csdn.net/qq_50285142/article/details/114186789">10.bitset</a>👈</h2><h2 id="👉11-array数组👈"><a href="#👉11-array数组👈" class="headerlink" title="👉11.array数组👈"></a>👉<a href="https://blog.csdn.net/qq_50285142/article/details/122932215">11.array数组</a>👈</h2><h2 id="👉12-tuple元组👈"><a href="#👉12-tuple元组👈" class="headerlink" title="👉12.tuple元组👈"></a>👉<a href="https://blog.csdn.net/qq_50285142/article/details/123000835">12.tuple元组</a>👈</h2><h1 id="STL相关内容"><a href="#STL相关内容" class="headerlink" title="STL相关内容"></a>STL相关内容</h1><h2 id="C-STL函数总结"><a href="#C-STL函数总结" class="headerlink" title="C++ STL函数总结"></a><a href="https://wyq666.blog.csdn.net/article/details/120632337">C++ STL函数总结</a></h2><hr><p>由于作者水平有限，内容纯手敲，整理可能有误。<br>如果有哪些不足或者错误的地方，也希望大家督促我尽快改正哦，我会及时回复的。</p><p>如有疑问，请加QQ交流群</p><p>点击链接加入群聊： <a href="https://jq.qq.com/?_wv=1027&k=tcepNzVd">https://jq.qq.com/?_wv&#x3D;1027&amp;k&#x3D;tcepNzVd</a></p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习总结 </tag>
            
            <tag> CPP </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年度总结</title>
      <link href="/p/41345582.html"/>
      <url>/p/41345582.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇总结实际2023-11整理时候才从云笔记搬来补上，实际20年还没有建立此站。</p></blockquote><h1 id="2020年度总结"><a href="#2020年度总结" class="headerlink" title="2020年度总结"></a>2020年度总结</h1><p>2020已经圆满结束🔚🔚🔚2021新的一天已经开始。</p><p>回望2020，上半年还因疫情在家中备战高考下半年就已完成高考，过渡暑假，步入大学。</p><p>在家中，抱怨过网络，经历过寒冷，有过隔离，经历高考延期，两次百日冲刺，有激动也有慌张。学习简直是废寝忘食，钉钉上课，远程教育，使坏了👀眼睛。看到了这个世界的温情与冷漠，坚持与退缩。我也算是历史的书写者，也是历史的见证者😂😂。</p><p>终于回了学校，五楼风光，五楼路程，远距缓慢就餐，但却有同学的陪伴。一直在考试，有悲有欢，有苦有乐，而高考却给了我重头一击。</p><p>进入大学，如无头苍蝇一样乱跑，但所幸加入了机器人实验室，加入了这个团队，这个集体，让我有了归属。慢慢的，我才明白，大学并不是那么重要，重要的是自己享受自己的生活，热爱自己所选的专业。在这里，学习竟一下子变得那么遥远，各种高中不曾有的陋习，突然出现在了自己的生活中，我想这应该是大学生的通病。还好，在这个团队里，我初探了HTML，css，python，java，c++，扩展了知识的广度。我也很幸运地通过acm院赛加入到了acm实验室，又让我认识了一群超级大佬，金牌大佬。在他们的指引下，我接触了acm比赛和算法知识，体验了烧脑时刻，也为后路划明了方向。参加过校园吉尼斯，背π小数点，记扑克，双冠让我重拾了记忆，口语考试也得到了应用，而目前政治考试效果如何不好说，反正记忆法确实厉害，但自己是否入门还真不好说，之后的路怎么走，还要看自己，但是目前它确实带来了不一般的效果，虽然过程艰辛。我又参加了校园冬训，拼命，汗水，坚持等一些词语似乎在这里变得重要，我恰巧进了自己最不擅长的项目，好像上天在帮我弥补缺陷。冬训组里一群伙伴，互相训练，共同坚持的氛围多好。</p><p>目前，考试到来，复习只能突击，全新的体验😂😂</p><p>2020确实不平凡，有颇多经历</p><p>2021希望不简单，盼良好成绩</p><p>就此别过从前的自己，新的一年新的一天新的开始，继续努力进发，加油加油加油！！！</p>]]></content>
      
      
      <categories>
          
          <category> 哲思 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阶段性总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
